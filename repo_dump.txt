
===== FILE: eclipse_ai/__init__.py =====

"""Eclipse AI: parse board images, build state, search actions, and recommend plays."""

__version__ = "0.1.0"

from .game_models import (
    ActionType,
    Resources,
    ShipDesign,
    Pieces,
    Planet,
    Hex,
    TechDisplay,
    PlayerState,
    MapState,
    GameState,
    Action,
    Score,
    Disc,
    ColonyShips,
)
from .main import recommend
from .search_policy import MCTSPlanner, Plan, PlanStep
from .overlay import plan_overlays
from .species_data import SpeciesConfig, get_species, all_species, get_registry
from .uncertainty import BeliefState, DiscreteHMM, TileParticleFilter, TileParticle

__all__ = [
    "recommend",
    "ActionType",
    "Resources",
    "ShipDesign",
    "Pieces",
    "Planet",
    "Hex",
    "TechDisplay",
    "PlayerState",
    "MapState",
    "GameState",
    "Action",
    "Score",
    "Disc",
    "ColonyShips",
    "MCTSPlanner",
    "Plan",
    "PlanStep",
    "plan_overlays",
    "BeliefState",
    "DiscreteHMM",
    "TileParticleFilter",
    "TileParticle",
    "SpeciesConfig",
    "get_species",
    "all_species",
    "get_registry",
    "__version__",
]

===== FILE: eclipse_ai/alliances.py =====

"""Alliance management and helper utilities."""
from __future__ import annotations

from typing import Dict, Iterable, List, Optional, Set, Tuple

from .game_models import Alliance, GameState, PlayerState, Hex, Pieces
from . import diplomacy


class AllianceError(RuntimeError):
    """Raised when an illegal alliance operation is attempted."""


_MAX_ROUND = 9


def are_allied(state: GameState, a_id: str, b_id: str) -> bool:
    if a_id == b_id:
        return True
    player_a = state.players.get(a_id) if state else None
    player_b = state.players.get(b_id) if state else None
    if player_a is None or player_b is None:
        return False
    if not player_a.alliance_id or not player_b.alliance_id:
        return False
    return player_a.alliance_id == player_b.alliance_id


def allies_for_player(state: GameState, player_id: str) -> List[str]:
    player = state.players.get(player_id) if state else None
    if player is None or not player.alliance_id:
        return []
    alliance = state.alliances.get(player.alliance_id)
    if alliance is None:
        return []
    return [pid for pid in alliance.members if pid != player_id]


def can_found_alliance(state: GameState, a_id: str, b_id: str, third_id: Optional[str] = None) -> bool:
    if not state or not state.players:
        return False
    if not state.feature_flags.get("rotA"):
        return False
    if state.round >= _MAX_ROUND:
        return False
    if a_id == b_id:
        return False
    a = state.players.get(a_id)
    b = state.players.get(b_id)
    if a is None or b is None:
        return False
    if a.alliance_id or b.alliance_id:
        return False
    if a.alliance_tile == "-3" or b.alliance_tile == "-3":
        return False
    if not diplomacy.has_diplomatic_relation(state, a_id, b_id):
        return False
    player_count = len(state.players)
    allow_third = player_count >= 6
    if third_id:
        if not allow_third:
            return False
        third = state.players.get(third_id)
        if third is None:
            return False
        if third.alliance_id or third.alliance_tile == "-3":
            return False
        if not diplomacy.has_diplomatic_relation(state, third_id, a_id):
            return False
        if not diplomacy.has_diplomatic_relation(state, third_id, b_id):
            return False
    else:
        third = None
    return True


def found_alliance(state: GameState, a_id: str, b_id: str, third_id: Optional[str] = None) -> Alliance:
    if not can_found_alliance(state, a_id, b_id, third_id):
        raise AllianceError("Alliance requirements not met")
    alliance_id = _next_alliance_id(state)
    members = [a_id, b_id]
    if third_id:
        members.append(third_id)
    alliance = Alliance(id=alliance_id, members=list(members), founded=True)
    state.alliances[alliance_id] = alliance
    for pid in members:
        player = state.players[pid]
        player.alliance_id = alliance_id
        player.alliance_tile = "+2"
    return alliance


def join_alliance(state: GameState, alliance_id: str, player_id: str) -> None:
    alliance = state.alliances.get(alliance_id)
    if alliance is None or not alliance.founded:
        raise AllianceError("Alliance not available")
    if state.round >= _MAX_ROUND:
        raise AllianceError("Cannot join on the final round")
    player = state.players.get(player_id)
    if player is None:
        raise AllianceError("Unknown player")
    if player.alliance_id:
        raise AllianceError("Player already in alliance")
    if player.alliance_tile == "-3":
        raise AllianceError("Betrayers cannot rejoin an alliance")
    if len(alliance.members) >= 3:
        raise AllianceError("Alliance is at capacity")
    if len(state.players) < 6:
        raise AllianceError("Alliance cannot add members in small games")
    for member_id in alliance.members:
        if not diplomacy.has_diplomatic_relation(state, player_id, member_id):
            raise AllianceError("Joining player lacks diplomacy with alliance member")
    alliance.members.append(player_id)
    player.alliance_id = alliance_id
    player.alliance_tile = "+2"


def leave_alliance(state: GameState, player_id: str) -> None:
    player = state.players.get(player_id)
    if player is None or not player.alliance_id:
        raise AllianceError("Player is not in an alliance")
    if state.round >= _MAX_ROUND:
        raise AllianceError("Cannot leave on the final round")
    alliance = state.alliances.get(player.alliance_id)
    if alliance is None:
        raise AllianceError("Alliance not found")

    player.alliance_tile = "-3"
    alliance.betrayers.add(player_id)

    allies = list(alliance.members)
    if player_id in allies:
        allies.remove(player_id)

    for ally_id in allies:
        if _counts_as_attack(state, player_id, ally_id):
            diplomacy.break_diplomacy(state, player_id, ally_id)
        else:
            diplomacy.clear_diplomacy(state, player_id, ally_id)

    if player_id in alliance.members:
        alliance.members.remove(player_id)
    player.alliance_id = None

    if not alliance.members and alliance.id in state.alliances:
        del state.alliances[alliance.id]


def ship_presence(state: GameState, hex_obj: Hex, player_id: str) -> Tuple[int, int]:
    """Return ``(friendly, enemy)`` ship counts for pinning checks."""
    if not hex_obj:
        return (0, 0)
    friendly = allied_strength_in(state, hex_obj, player_id)
    enemy = int(hex_obj.ancients or 0)
    for owner, pieces in (hex_obj.pieces or {}).items():
        if owner == player_id or are_allied(state, owner, player_id):
            continue
        enemy += _ship_count(pieces)
    return friendly, enemy


def allied_strength_in(state: GameState, hex_obj: Hex, player_id: str) -> int:
    """Return the total ship strength contributed by the player and their allies."""

    if not hex_obj:
        return 0
    total = 0
    for owner, pieces in (hex_obj.pieces or {}).items():
        if owner == player_id or are_allied(state, owner, player_id):
            total += _ship_count(pieces)
    return total


def merge_combat_sides(state: GameState, defenders: Iterable[str], attackers: Iterable[str]) -> Tuple[List[str], List[str], bool]:
    """Return combat sides, merging alliances and resolving defender initiative."""
    defender_side: List[str] = []
    attacker_side: List[str] = []

    for pid in defenders:
        defender_side.extend(_expand_allied_members(state, pid))
    defender_side = _unique_preserve_order(defender_side)

    for pid in attackers:
        members = _expand_allied_members(state, pid)
        if any(member in defender_side for member in members):
            for member in members:
                if member not in defender_side:
                    defender_side.append(member)
            continue
        attacker_side.extend(members)

    attacker_side = [pid for pid in _unique_preserve_order(attacker_side) if pid not in defender_side]
    defender_tie_advantage = bool(defender_side)
    return defender_side, attacker_side, defender_tie_advantage


def _expand_allied_members(state: GameState, player_id: str) -> List[str]:
    player = state.players.get(player_id)
    if player is None:
        return []
    if not player.alliance_id:
        return [player_id]
    alliance = state.alliances.get(player.alliance_id)
    if alliance is None:
        return [player_id]
    return list(alliance.members)


def _ship_count(pieces: Pieces) -> int:
    total = int(pieces.starbase or 0)
    total += sum(int(v) for v in (pieces.ships or {}).values())
    return total


def _next_alliance_id(state: GameState) -> str:
    idx = 1
    while True:
        candidate = f"alliance-{idx}"
        if candidate not in state.alliances:
            return candidate
        idx += 1


def _counts_as_attack(state: GameState, player_id: str, ally_id: str) -> bool:
    if not state or not state.map or not state.map.hexes:
        return False
    for hx in state.map.hexes.values():
        pieces_player = hx.pieces.get(player_id) if hx.pieces else None
        pieces_ally = hx.pieces.get(ally_id) if hx.pieces else None
        player_controls = bool(pieces_player and int(pieces_player.discs) > 0)
        ally_controls = bool(pieces_ally and int(pieces_ally.discs) > 0)
        player_has_ships = bool(pieces_player and _ship_count(pieces_player) > 0)
        ally_has_ships = bool(pieces_ally and _ship_count(pieces_ally) > 0)
        if ally_controls and player_has_ships:
            return True
        if player_controls and (ally_has_ships or bool(pieces_ally and int(pieces_ally.discs) > 0)):
            return True
    return False


def _unique_preserve_order(ids: Iterable[str]) -> List[str]:
    seen: Set[str] = set()
    ordered: List[str] = []
    for pid in ids:
        if pid in seen:
            continue
        seen.add(pid)
        ordered.append(pid)
    return ordered


__all__ = [
    "AllianceError",
    "are_allied",
    "allies_for_player",
    "can_found_alliance",
    "found_alliance",
    "join_alliance",
    "leave_alliance",
    "ship_presence",
    "allied_strength_in",
    "merge_combat_sides",
]

===== FILE: eclipse_ai/board_parser.py =====

from __future__ import annotations
from typing import Dict, Any, List, Optional, Tuple
from dataclasses import dataclass, field
import os, json, math

try:
    import cv2  # type: ignore
    import numpy as np  # type: ignore
except Exception:  # OpenCV optional
    cv2 = None  # type: ignore
    np = None   # type: ignore

from .game_models import MapState, Hex, Planet, Pieces

# ============================================================
# Config
# ============================================================

@dataclass
class BoardParseConfig:
    # Player color ranges in HSV for discs/cubes/ships. Tunable.
    hsv_ranges: Dict[str, Tuple[Tuple[int,int,int], Tuple[int,int,int]]] = field(default_factory=lambda: {
        # lower HSV, upper HSV
        "orange": ((5,  80, 60),  (25, 255, 255)),
        "blue":   ((90, 60, 60),  (130,255, 255)),
        "green":  ((40, 60, 60),  (85, 255, 255)),
        "purple": ((130,60, 60),  (160,255, 255)),
        "red1":   ((0,  80, 60),  (5,  255, 255)),
        "red2":   ((170,80, 60),  (180,255, 255)),
        "yellow": ((25, 80, 60),  (35, 255, 255)),
        "black":  ((0,   0,  0),  (180, 255, 50)),
        "white":  ((0,   0,180),  (180, 50, 255)),
    })
    # How many hex rings to project if grid hint missing
    default_rings: int = 2
    # Minimum contour area to consider as token
    min_token_area: int = 80
    # Use sidecar if present
    prefer_sidecar: bool = True

@dataclass
class GridHint:
    # Axial grid hint using pixel vectors
    origin: Tuple[float,float] = (0.0, 0.0)   # pixel coords for axial (q=0,r=0)
    q_vec: Tuple[float,float] = (80.0, 0.0)   # pixel delta for +q
    r_vec: Tuple[float,float] = (40.0, 70.0)  # pixel delta for +r
    rings: int = 2

# ============================================================
# Public API
# ============================================================

def parse_board(cal_img, config: Optional[BoardParseConfig]=None) -> MapState:
    """
    Board parser with three modes:
      1) Sidecar annotations (robust): <image_path>.annotations.json
      2) CV-assisted token detection if OpenCV available + optional grid hint in cal_img.metadata['grid_hint']
      3) Fallback: small demo map (keeps pipeline alive)

    Sidecar schema (preferred):
    {
      "hexes": [
        {
          "id": "H-010",
          "ring": 2,
          "wormholes": [0,2,4],
          "planets": [{"type":"yellow","colonized_by":"you"},{"type":"blue","colonized_by":null}],
          "pieces": [
            {"owner":"you","ships":{"interceptor":2},"starbase":0,"discs":1,"cubes":{"y":1,"b":0,"p":0}},
            {"owner":"blue","ships":{"cruiser":2},"discs":1}
          ]
        }
      ]
    }
    """
    cfg = config or BoardParseConfig()
    # 1) Sidecar
    if cfg.prefer_sidecar:
        data = _load_sidecar(cal_img.path)
        if data:
            return _mapstate_from_annotations(data)

    # 2) CV flow
    if cv2 is not None and np is not None:
        try:
            img = cv2.imread(cal_img.path, cv2.IMREAD_COLOR)
            if img is not None:
                grid = _grid_from_meta(cal_img.metadata) or _guess_grid(img.shape, cfg.default_rings)
                tokens = _detect_tokens(img, cfg)
                hex_centers, hex_ids, rings = _project_hex_centers(grid)
                hex_map: Dict[str, Hex] = {}
                # Initialize hexes
                for hid, (cx, cy), ring in zip(hex_ids, hex_centers, rings):
                    hex_map[hid] = Hex(id=hid, ring=ring, wormholes=[], planets=[], pieces={})
                # Assign tokens to nearest hex center
                for t in tokens:
                    hid = _nearest_hex_id((t["cx"], t["cy"]), hex_centers, hex_ids)
                    if hid is None:
                        continue
                    owner = t["owner"]
                    hx = hex_map[hid]
                    if owner not in hx.pieces:
                        hx.pieces[owner] = Pieces(ships={}, starbase=0, discs=0, cubes={})
                    p = hx.pieces[owner]
                    if t["kind"] == "disc":
                        p.discs += 1
                    elif t["kind"] == "cube":
                        # Heuristic: map cube color to resource initial; here we store generic
                        ckey = t.get("res_key","y")
                        p.cubes[ckey] = p.cubes.get(ckey, 0) + 1
                    elif t["kind"] == "ship":
                        cls = t.get("cls","interceptor")
                        p.ships[cls] = p.ships.get(cls, 0) + 1
                    elif t["kind"] == "starbase":
                        p.starbase += 1
                # Remove empty hexes
                hex_map = {k:v for k,v in hex_map.items() if v.pieces}
                if hex_map:
                    return MapState(hexes=hex_map)
        except Exception:
            pass

    # 3) Fallback demo
    hexes: Dict[str, Hex] = {}
    h = Hex(id="H-010", ring=2, wormholes=[0,2,4], planets=[Planet("yellow","you"), Planet("blue", None)])
    h.pieces["you"] = Pieces(ships={"interceptor":2}, discs=1, cubes={"y":1})
    h.pieces["blue"] = Pieces(ships={"cruiser":2}, discs=1)
    hexes[h.id] = h
    return MapState(hexes=hexes)

# ============================================================
# Sidecar annotations
# ============================================================

def _sidecar_path(image_path: str) -> Optional[str]:
    base = image_path
    if not os.path.exists(base):
        return None
    cand = base + ".annotations.json"
    return cand if os.path.exists(cand) else None

def _load_sidecar(image_path: str) -> Optional[Dict[str, Any]]:
    p = _sidecar_path(image_path)
    if not p:
        return None
    try:
        with open(p, "r", encoding="utf-8") as f:
            return json.load(f)
    except Exception:
        return None

def _mapstate_from_annotations(data: Dict[str, Any]) -> MapState:
    hex_map: Dict[str, Hex] = {}
    for hx in data.get("hexes", []):
        h = Hex(
            id=str(hx.get("id","H-000")),
            ring=int(hx.get("ring", 0)),
            wormholes=list(hx.get("wormholes", [])),
            planets=[Planet(p.get("type","yellow"), p.get("colonized_by")) for p in hx.get("planets", [])],
            pieces={}
        )
        for p in hx.get("pieces", []):
            owner = str(p.get("owner","unknown"))
            pieces = Pieces(
                ships=dict(p.get("ships", {})),
                starbase=int(p.get("starbase", 0)),
                discs=int(p.get("discs", 0)),
                cubes=dict(p.get("cubes", {})),
                discovery=int(p.get("discovery", 0)),
            )
            h.pieces[owner] = pieces
        hex_map[h.id] = h
    return MapState(hexes=hex_map)

# ============================================================
# Grid helpers
# ============================================================

def _grid_from_meta(meta: Dict[str, Any]) -> Optional[GridHint]:
    gh = meta.get("grid_hint") if isinstance(meta, dict) else None
    if not gh:
        return None
    try:
        origin = tuple(gh.get("origin", (0.0,0.0)))
        q_vec = tuple(gh.get("q_vec", (80.0,0.0)))
        r_vec = tuple(gh.get("r_vec", (40.0,70.0)))
        rings = int(gh.get("rings", 2))
        return GridHint(origin=origin, q_vec=q_vec, r_vec=r_vec, rings=rings)
    except Exception:
        return None

def _guess_grid(shape, rings: int) -> GridHint:
    h, w = shape[:2]
    # Rough guess: center the grid; set vectors based on image width
    scale = max(40.0, min(w, h) / 10.0)
    origin = (w/2.0, h/2.0)
    q_vec = (scale, 0.0)
    r_vec = (scale*0.5, scale*0.866)  # 60 degrees
    return GridHint(origin=origin, q_vec=q_vec, r_vec=r_vec, rings=rings)

def _project_hex_centers(grid: GridHint) -> Tuple[List[Tuple[float,float]], List[str], List[int]]:
    centers: List[Tuple[float,float]] = []
    ids: List[str] = []
    rings: List[int] = []
    # Axial coords within N rings
    N = grid.rings
    idx = 0
    for q in range(-N, N+1):
        r1 = max(-N, -q-N)
        r2 = min(N, -q+N)
        for r in range(r1, r2+1):
            x = grid.origin[0] + q*grid.q_vec[0] + r*grid.r_vec[0]
            y = grid.origin[1] + q*grid.q_vec[1] + r*grid.r_vec[1]
            centers.append((x, y))
            ids.append(f"H-{idx:03d}")
            rings.append(max(abs(q), abs(r), abs(-q-r)))
            idx += 1
    return centers, ids, rings

def _nearest_hex_id(pt: Tuple[float,float], centers: List[Tuple[float,float]], ids: List[str]) -> Optional[str]:
    if not centers:
        return None
    px, py = pt
    best_d2 = 1e18
    best_id = None
    for (cx, cy), hid in zip(centers, ids):
        d2 = (px - cx)**2 + (py - cy)**2
        if d2 < best_d2:
            best_d2 = d2
            best_id = hid
    return best_id

# ============================================================
# CV token detection
# ============================================================

def _detect_tokens(img, cfg: BoardParseConfig) -> List[Dict[str, Any]]:
    """
    Detect colored tokens using HSV thresholds + contour analysis.
    Returns a list of dicts: {"owner":<color_name>,"kind":"disc|cube|ship|starbase","cx":float,"cy":float,"cls":optional}
    """
    tokens: List[Dict[str, Any]] = []
    if cv2 is None or np is None:
        return tokens
    hsv = cv2.cvtColor(img, cv2.COLOR_BGR2HSV)

    # Build masks per color; red requires two ranges (red1, red2)
    color_masks: Dict[str, Any] = {}
    for name, (lo, hi) in cfg.hsv_ranges.items():
        lo_np = np.array(lo, dtype=np.uint8)
        hi_np = np.array(hi, dtype=np.uint8)
        mask = cv2.inRange(hsv, lo_np, hi_np)
        if name == "red2":
            # Merge with red1
            prev = color_masks.get("red1")
            color_masks["red"] = cv2.bitwise_or(prev, mask) if prev is not None else mask
        elif name != "red1":
            color_masks[name] = mask

    # For each color, find contours and classify rough shape
    for color_name, mask in color_masks.items():
        if mask is None:
            continue
        cnts, _ = cv2.findContours(mask, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
        for c in cnts:
            area = cv2.contourArea(c)
            if area < cfg.min_token_area:
                continue
            x,y,w,h = cv2.boundingRect(c)
            cx, cy = x + w/2.0, y + h/2.0
            # circularity to separate discs vs cubes
            perim = cv2.arcLength(c, True)
            circ = 0.0 if perim <= 0 else 4*math.pi*area/(perim*perim)
            aspect = w/float(h) if h>0 else 1.0
            kind = "ship"
            if 0.70 <= circ <= 1.25 and 0.8 <= aspect <= 1.25:
                kind = "disc"
            elif 0.3 <= circ < 0.7 and 0.85 <= aspect <= 1.35:
                kind = "cube"
            # Heuristic: very large circular-ish -> starbase
            if kind == "disc" and area > 6_000:
                kind = "starbase"

            tokens.append({"owner": color_name, "kind": kind, "cx": cx, "cy": cy})
    return tokens


===== FILE: eclipse_ai/data/constants.py =====

"""Victory point constants for Eclipse endgame scoring."""
from __future__ import annotations

TECH_TRACK_VP = {4: 1, 5: 2, 6: 3, 7: 5}
DISCOVERY_TILE_VP = 2
MONOLITH_VP = 3
TRAITOR_PENALTY = -2
ALLIANCE_TILE_FACEUP_VP = 2
ALLIANCE_TILE_BETRAYER_VP = -3
ANCIENT_KILL_VP = 1

===== FILE: eclipse_ai/data/exploration_tiles.py =====

"""Structured access to Eclipse exploration hex data."""
from __future__ import annotations

import csv
import os
from dataclasses import dataclass, field
from functools import lru_cache
from typing import Dict, Iterable, List, Optional


@dataclass(frozen=True)
class ExplorationTileRecord:
    """Metadata describing a single exploration hex tile."""

    tile_number: str
    ring: int
    ancient_resistance: int = 0
    resources: Dict[str, int] = field(default_factory=dict)
    advanced_resources: Dict[str, int] = field(default_factory=dict)
    discovery_tile: bool = False
    victory_points: int = 0
    has_black_hole: bool = False
    has_wormhole: bool = False
    has_anomalies: bool = False
    has_supernova: bool = False
    has_nebula: bool = False
    ancient_hive: int = 0
    has_pulsar: bool = False


def _csv_path(csv_override: Optional[str] = None) -> str:
    base_path = os.path.join(os.path.dirname(__file__), "..", "..", "eclipse_tiles.csv")
    return os.path.abspath(csv_override or base_path)


def _to_int(value: Optional[str]) -> int:
    if value is None:
        return 0
    value = value.strip()
    if not value:
        return 0
    try:
        return int(float(value))
    except ValueError:
        return 0


def _to_bool(value: Optional[str]) -> bool:
    if value is None:
        return False
    value = value.strip().lower()
    return value in {"1", "true", "yes"}


@lru_cache()
def load_exploration_tiles(csv_override: Optional[str] = None) -> Dict[str, ExplorationTileRecord]:
    """Parse the exploration CSV into structured records keyed by tile id."""

    path = _csv_path(csv_override)
    if not os.path.exists(path):
        return {}

    records: Dict[str, ExplorationTileRecord] = {}
    with open(path, newline="", encoding="utf-8") as handle:
        reader = csv.DictReader(handle)
        for row in reader:
            tile_id = (row.get("TileNumber") or "").strip()
            ring = _to_int(row.get("Sector"))
            if not tile_id or ring <= 0:
                continue

            record = ExplorationTileRecord(
                tile_number=tile_id,
                ring=ring,
                ancient_resistance=_to_int(row.get("AncientResistance")),
                resources={
                    "money": _to_int(row.get("Money")),
                    "science": _to_int(row.get("Science")),
                    "materials": _to_int(row.get("Materials")),
                    "white": _to_int(row.get("White")),
                },
                advanced_resources={
                    "money": _to_int(row.get("AdvMoney")),
                    "science": _to_int(row.get("AdvScience")),
                    "materials": _to_int(row.get("AdvMaterials")),
                    "white": _to_int(row.get("AdvWhite")),
                },
                discovery_tile=_to_bool(row.get("DiscoveryTile")),
                victory_points=_to_int(row.get("VictoryPoints")),
                has_black_hole=_to_bool(row.get("BlackHole")),
                has_wormhole=_to_bool(row.get("Wormhole")),
                has_anomalies=_to_bool(row.get("Anomalies")),
                has_supernova=_to_bool(row.get("Supernova")),
                has_nebula=_to_bool(row.get("Nebula")),
                ancient_hive=_to_int(row.get("AncientHive")),
                has_pulsar=_to_bool(row.get("Pulsar")),
            )
            records[record.tile_number] = record
    return records


@lru_cache()
def tile_numbers_by_ring() -> Dict[int, List[str]]:
    """Return tile ids grouped by sector ring."""

    grouped: Dict[int, List[str]] = {}
    for record in load_exploration_tiles().values():
        grouped.setdefault(record.ring, []).append(record.tile_number)
    for entries in grouped.values():
        entries.sort()
    return grouped


@lru_cache()
def tiles_by_ring(ring: int) -> List[ExplorationTileRecord]:
    """Return a list of tile records for the specified ring."""

    tiles = [rec for rec in load_exploration_tiles().values() if rec.ring == ring]
    tiles.sort(key=lambda rec: rec.tile_number)
    return tiles


@lru_cache()
def tile_counts_by_ring() -> Dict[int, int]:
    """Summarise how many tiles exist in each exploration ring."""

    return {ring: len(ids) for ring, ids in tile_numbers_by_ring().items()}


def iter_tiles() -> Iterable[ExplorationTileRecord]:
    """Iterate over all known exploration tiles."""

    return load_exploration_tiles().values()


__all__ = [
    "ExplorationTileRecord",
    "iter_tiles",
    "load_exploration_tiles",
    "tile_counts_by_ring",
    "tile_numbers_by_ring",
    "tiles_by_ring",
]

===== FILE: eclipse_ai/data/species.json =====

{
  "_meta": {
    "schema": "eclipse.species.config.v1",
    "sources": [
      "Eclipse Second Dawn rulebook",
      "Rise of the Ancients",
      "Shadows of the Rift"
    ],
    "notes": "Trade rate is expressed as trade goods required -> resources gained. starting_storage uses resource track capacity pips shown on faction boards."
  },
  "terrans": {
    "name": "Terrans",
    "expansion": "base",
    "starting_sector": 101,
    "trade_rate": {"goods": 3, "resources": 1},
    "starting_storage": {"money": 3, "science": 3, "materials": 3},
    "starting_resources": {"money": 2, "science": 2, "materials": 2},
    "starting_colonies": {"home": {"money": 1, "science": 1, "materials": 1}},
    "starting_ships": {"home": {"interceptor": 2, "cruiser": 0, "dreadnought": 0, "starbase": 0}},
    "starting_structures": {"home": {"orbital": 0, "monolith": 0}},
    "starting_techs": [],
    "starting_discs_delta": 0,
    "colony_ships": 3,
    "action_overrides": {},
    "build_limits": {},
    "vp_bonuses": {},
    "cannot_build": [],
    "notes": [
      "Baseline faction shared by Terran subfactions (Directorate, Federation, Union, Republic)."
    ]
  },
  "eridani": {
    "name": "Eridani Empire",
    "expansion": "base",
    "starting_sector": 224,
    "trade_rate": {"goods": 3, "resources": 1},
    "starting_storage": {"money": 4, "science": 2, "materials": 3},
    "starting_resources": {"money": 0, "science": 0, "materials": 0},
    "starting_colonies": {"home": {"money": 1, "science": 1, "materials": 1}},
    "starting_ships": {"home": {"interceptor": 1, "cruiser": 1, "dreadnought": 0, "starbase": 0}},
    "starting_structures": {"home": {"orbital": 0, "monolith": 0}},
    "starting_techs": ["Gauss Shield", "Fusion Drive", "Plasma Cannon"],
    "starting_discs_delta": -2,
    "colony_ships": 3,
    "action_overrides": {},
    "build_limits": {},
    "vp_bonuses": {},
    "cannot_build": [],
    "notes": [
      "Begins with two fewer influence discs and an advanced cruiser focus."
    ]
  },
  "hydran": {
    "name": "Hydran Progress",
    "expansion": "base",
    "starting_sector": 226,
    "trade_rate": {"goods": 3, "resources": 1},
    "starting_storage": {"money": 2, "science": 4, "materials": 3},
    "starting_resources": {"money": 0, "science": 3, "materials": 0},
    "starting_colonies": {"home": {"science": 2, "materials": 1}},
    "starting_ships": {"home": {"interceptor": 2, "cruiser": 0, "dreadnought": 0, "starbase": 0}},
    "starting_structures": {"home": {"orbital": 0, "monolith": 0}},
    "starting_techs": ["Advanced Labs"],
    "starting_discs_delta": 0,
    "colony_ships": 3,
    "action_overrides": {"research_per_action": 2},
    "build_limits": {},
    "vp_bonuses": {},
    "cannot_build": [],
    "notes": [
      "Research focused economy. Hydran Evolution tiles integrate with Octantis Evolution rules when that module is active."
    ]
  },
  "planta": {
    "name": "Planta",
    "expansion": "base",
    "starting_sector": 228,
    "trade_rate": {"goods": 3, "resources": 1},
    "starting_storage": {"money": 3, "science": 2, "materials": 4},
    "starting_resources": {"money": 0, "science": 0, "materials": 3},
    "starting_colonies": {"home": {"materials": 2}},
    "starting_ships": {"home": {"interceptor": 1, "cruiser": 0, "dreadnought": 0, "starbase": 0}},
    "starting_structures": {"home": {"orbital": 0, "monolith": 0}},
    "starting_techs": ["Starbase"],
    "starting_discs_delta": 0,
    "colony_ships": 3,
    "action_overrides": {"explores_per_action": 2},
    "build_limits": {},
    "vp_bonuses": {"hex_control": 1},
    "cannot_build": [],
    "notes": [
      "Root Network: treat controlled hexes as adjacent for movement and influence.",
      "In two-player games Planta is considered stronger and often recommended to avoid for balance."
    ]
  },
  "mechanema": {
    "name": "Mechanema",
    "expansion": "base",
    "starting_sector": 227,
    "trade_rate": {"goods": 3, "resources": 1},
    "starting_storage": {"money": 3, "science": 4, "materials": 2},
    "starting_resources": {"money": 0, "science": 2, "materials": 1},
    "starting_colonies": {"home": {"science": 2, "materials": 1}},
    "starting_ships": {"home": {"interceptor": 2, "cruiser": 0, "dreadnought": 0, "starbase": 0}},
    "starting_structures": {"home": {"orbital": 0, "monolith": 0}},
    "starting_techs": ["Positron Computer"],
    "starting_discs_delta": 0,
    "colony_ships": 3,
    "action_overrides": {"upgrade_parts_per_action": 3},
    "build_limits": {"build_discount": "mechanema"},
    "vp_bonuses": {},
    "cannot_build": [],
    "notes": [
      "May upgrade up to three ship parts per Upgrade action."
    ]
  },
  "orion": {
    "name": "Orion Hegemony",
    "expansion": "base",
    "starting_sector": 230,
    "trade_rate": {"goods": 3, "resources": 1},
    "starting_storage": {"money": 4, "science": 2, "materials": 3},
    "starting_resources": {"money": 2, "science": 1, "materials": 2},
    "starting_colonies": {"home": {"money": 1, "science": 1, "materials": 1}},
    "starting_ships": {"home": {"interceptor": 0, "cruiser": 1, "dreadnought": 0, "starbase": 0}},
    "starting_structures": {"home": {"orbital": 0, "monolith": 0}},
    "starting_techs": ["Neutron Bombs", "Gauss Shield"],
    "starting_discs_delta": 0,
    "colony_ships": 3,
    "action_overrides": {},
    "build_limits": {"builds_per_action": 3},
    "vp_bonuses": {},
    "cannot_build": [],
    "notes": [
      "Aggressive faction with cheaper build actions (up to three ships/structures per action)."
    ]
  },
  "draco": {
    "name": "Descendants of Draco",
    "expansion": "base",
    "starting_sector": 229,
    "trade_rate": {"goods": 3, "resources": 1},
    "starting_storage": {"money": 3, "science": 3, "materials": 3},
    "starting_resources": {"money": 1, "science": 1, "materials": 1},
    "starting_colonies": {"home": {"money": 1, "science": 1, "materials": 1}},
    "starting_ships": {"home": {"interceptor": 1, "cruiser": 0, "dreadnought": 0, "starbase": 0}},
    "starting_structures": {"home": {"orbital": 0, "monolith": 0}},
    "starting_techs": [],
    "starting_discs_delta": 0,
    "colony_ships": 3,
    "action_overrides": {},
    "build_limits": {},
    "vp_bonuses": {"ancients_remaining": 1},
    "cannot_build": [],
    "notes": [
      "May share hexes with Ancients without combat and cannot take their discoveries.",
      "Considered strong in two-player games; often omitted for balance."
    ]
  },
  "rho_indi": {
    "name": "Rho Indi Syndicate",
    "expansion": "rise",
    "starting_sector": 237,
    "trade_rate": {"goods": 3, "resources": 2},
    "starting_storage": {"money": 4, "science": 2, "materials": 3},
    "starting_resources": {"money": 3, "science": 0, "materials": 0},
    "starting_colonies": {"home": {"money": 2}},
    "starting_ships": {"home": {"interceptor": 2, "cruiser": 0, "dreadnought": 0, "starbase": 0}},
    "starting_structures": {"home": {"orbital": 0, "monolith": 0}},
    "starting_techs": ["Gluon Computer"],
    "starting_discs_delta": 0,
    "colony_ships": 3,
    "action_overrides": {},
    "build_limits": {},
    "vp_bonuses": {},
    "cannot_build": [],
    "notes": [
      "Pillage: gain 1 money when drawing reputation for winning battles."
    ]
  },
  "enlightened": {
    "name": "Enlightened of Lyra",
    "expansion": "rise",
    "starting_sector": 238,
    "trade_rate": {"goods": 3, "resources": 1},
    "starting_storage": {"money": 3, "science": 4, "materials": 2},
    "starting_resources": {"money": 1, "science": 2, "materials": 1},
    "starting_colonies": {"home": {"science": 2, "materials": 1}},
    "starting_ships": {"home": {"interceptor": 1, "cruiser": 0, "dreadnought": 0, "starbase": 0}},
    "starting_structures": {"home": {"orbital": 0, "monolith": 0, "shrine": 0}},
    "starting_techs": [],
    "starting_discs_delta": 0,
    "colony_ships": 2,
    "action_overrides": {"move_ship_activations": 4},
    "build_limits": {},
    "vp_bonuses": {"shrine_vp": 1},
    "cannot_build": [],
    "notes": [
      "May reroll combat dice by flipping Colony Ships and ignore Traitor penalty.",
      "Starts with two colony ships instead of three."
    ]
  },
  "exiles": {
    "name": "The Exiles",
    "expansion": "rise",
    "starting_sector": 239,
    "trade_rate": {"goods": 3, "resources": 1},
    "starting_storage": {"money": 3, "science": 2, "materials": 4},
    "starting_resources": {"money": 2, "science": 0, "materials": 2},
    "starting_colonies": {"home": {"money": 1, "materials": 1}},
    "starting_ships": {"home": {"interceptor": 1, "cruiser": 0, "dreadnought": 0, "starbase": 0}},
    "starting_structures": {"home": {"orbital": 1, "monolith": 0}},
    "starting_techs": ["Cloaking Device", "Orbital"],
    "starting_discs_delta": 0,
    "colony_ships": 3,
    "action_overrides": {},
    "build_limits": {},
    "vp_bonuses": {},
    "cannot_build": ["starbase"],
    "notes": [
      "Orbitals count as ships without drives. When destroyed an opponent draws reputation.",
      "Cannot build Starbases."
    ]
  },
  "magellan": {
    "name": "Magellan",
    "expansion": "rise",
    "starting_sector": 234,
    "trade_rate": {"goods": 3, "resources": 1},
    "starting_storage": {"money": 3, "science": 2, "materials": 4},
    "starting_resources": {"money": 0, "science": 0, "materials": 3},
    "starting_colonies": {"home": {"materials": 2}},
    "starting_ships": {"home": {"interceptor": 2, "cruiser": 0, "dreadnought": 0, "starbase": 0}},
    "starting_structures": {"home": {"orbital": 0, "monolith": 0}},
    "starting_techs": ["Fusion Source"],
    "starting_discs_delta": 0,
    "colony_ships": 3,
    "action_overrides": {},
    "build_limits": {},
    "vp_bonuses": {"orbital_vp": 1},
    "cannot_build": [],
    "notes": [
      "Variants: Keepers, Sentinels, Wardens. May flip a Colony Ship at any time for a resource of choice."
    ]
  },
  "shapers": {
    "name": "Shapers of Dorado",
    "expansion": "sotr",
    "starting_discs_delta": 0,
    "starting_resources": { "money": null, "science": null, "materials": null },
    "starting_techs": ["Soliton Cannon"],
    "rare_techs_starting": [],
    "starting_ships": { "home": { "interceptor": 1, "cruiser": 0, "dreadnought": 0, "starbase": 0 } },
    "starting_structures": { "home": { "orbital": 0, "monolith": 0 } },
    "trade_rate_money": [3,1],
    "action_overrides": {},
    "build_overrides": {},
    "explore_overrides": {},
    "move_overrides": { "move_ship_activations_per_action": 2 },
    "cannot_build": [],
    "vp_bonuses": {},
    "special_rules": {
      "time_distortion_enabled": true,
      "distortion_pool_size": 2
    },
    "notes": [
      "Starts with Soliton Cannon technology and maintains a Distortion pool for Time Distortion tiles."
    ]
  },
  "unity": {
    "name": "Pyxis Unity",
    "expansion": "sotr",
    "starting_discs_delta": 0,
    "starting_resources": { "money": 0, "science": 0, "materials": 0 },
    "starting_techs": ["Advanced Robotics"],
    "rare_techs_starting": [],
    "starting_ships": { "home": { "interceptor": 1, "cruiser": 0, "dreadnought": 0, "starbase": 0 } },
    "starting_structures": { "home": { "orbital": 0, "monolith": 0, "deathmoon": 0 } },
    "trade_rate_money": [3,1],
    "action_overrides": { "combination_actions_enabled": true },
    "build_overrides": {},
    "explore_overrides": {},
    "move_overrides": { "move_ship_activations_per_action": 2 },
    "cannot_build": ["starbase"],
    "vp_bonuses": { "endgame_per_deathmoon": 4 },
    "special_rules": {
      "single_resource_transmatter": true,
      "starbase_minis_are_deathmoons": true,
      "destroy_deathmoon_opponent_rep_draw": 3
    },
    "notes": [
      "Starbases are treated as Deathmoons with Transmatter logistics and cannot be built as standard Starbases."
    ]
  },
  "octantis_autonomy": {
    "name": "Octantis Autonomy",
    "expansion": "sotr",
    "starting_discs_delta": 0,
    "starting_resources": { "money": null, "science": null, "materials": null },
    "starting_techs": ["Fusion Drive"],
    "rare_techs_starting": [],
    "starting_ships": { "home": { "interceptor": 1, "cruiser": 0, "dreadnought": 0, "starbase": 0 } },
    "starting_structures": { "home": { "orbital": 0, "monolith": 0 } },
    "trade_rate_money": [3,1],
    "action_overrides": {},
    "build_overrides": {},
    "explore_overrides": {},
    "move_overrides": { "move_ship_activations_per_action": 2 },
    "cannot_build": [],
    "vp_bonuses": {},
    "special_rules": {
      "evolution_enabled": true,
      "evolution_pool_size": 5,
      "mutagen_production_per_round": 2,
      "colony_update_evolution_pool": true,
      "colony_update_distortion_pool": true
    },
    "notes": [
      "Evolution: maintain a five-tile Evolution pool refreshed via Colony Ships and produce Mutagen each round."
    ]
  },
  "octantis_vanguard": {
    "name": "Octantis Vanguard",
    "expansion": "sotr",
    "starting_discs_delta": 0,
    "starting_resources": { "money": null, "science": null, "materials": null },
    "starting_techs": ["Fusion Drive"],
    "rare_techs_starting": [],
    "starting_ships": { "home": { "interceptor": 1, "cruiser": 0, "dreadnought": 0, "starbase": 0 } },
    "starting_structures": { "home": { "orbital": 0, "monolith": 0 } },
    "trade_rate_money": [3,1],
    "action_overrides": {},
    "build_overrides": {},
    "explore_overrides": {},
    "move_overrides": { "move_ship_activations_per_action": 2 },
    "cannot_build": [],
    "vp_bonuses": {},
    "special_rules": {
      "evolution_enabled": true,
      "evolution_pool_size": 5,
      "mutagen_production_per_round": 2,
      "colony_update_evolution_pool": true,
      "colony_update_distortion_pool": true
    },
    "notes": [
      "Evolution: maintain a five-tile Evolution pool refreshed via Colony Ships and produce Mutagen each round."
    ]
  }
}

===== FILE: eclipse_ai/data/tech.json =====

{
  "techs": [
    {
      "id": "neutron_bombs",
      "name": "Neutron Bombs",
      "category": "Military",
      "is_rare": false,
      "base_cost": 2,
      "cost_range": [2, 2],
      "grants_parts": [],
      "grants_structures": [],
      "immediate_effect": null,
      "prerequisites": [],
      "notes": "",
      "sources": []
    },
    {
      "id": "starbase",
      "name": "Starbase",
      "category": "Military",
      "is_rare": false,
      "base_cost": 3,
      "cost_range": [3, 4],
      "grants_parts": [],
      "grants_structures": ["starbase"],
      "immediate_effect": null,
      "prerequisites": [],
      "notes": "Allows construction of Starbases.",
      "sources": []
    },
    {
      "id": "plasma_cannon",
      "name": "Plasma Cannon",
      "category": "Military",
      "is_rare": false,
      "base_cost": 4,
      "cost_range": [4, 6],
      "grants_parts": ["plasma_cannon"],
      "grants_structures": [],
      "immediate_effect": null,
      "prerequisites": [],
      "notes": "Unlocks Plasma Cannon ship part.",
      "sources": []
    },
    {
      "id": "phase_shield",
      "name": "Phase Shield",
      "category": "Military",
      "is_rare": false,
      "base_cost": 5,
      "cost_range": [5, 8],
      "grants_parts": [],
      "grants_structures": [],
      "immediate_effect": null,
      "prerequisites": [],
      "notes": "",
      "sources": []
    },
    {
      "id": "advanced_mining",
      "name": "Advanced Mining",
      "category": "Military",
      "is_rare": false,
      "base_cost": 6,
      "cost_range": [6, 10],
      "grants_parts": [],
      "grants_structures": [],
      "immediate_effect": {"materials": 3},
      "prerequisites": [],
      "notes": "Immediate Materials windfall for mining operations.",
      "sources": []
    },
    {
      "id": "tachyon_source",
      "name": "Tachyon Source",
      "category": "Military",
      "is_rare": false,
      "base_cost": 6,
      "cost_range": [6, 12],
      "grants_parts": [],
      "grants_structures": [],
      "immediate_effect": null,
      "prerequisites": [],
      "notes": "",
      "sources": []
    },
    {
      "id": "gluon_computer",
      "name": "Gluon Computer",
      "category": "Military",
      "is_rare": false,
      "base_cost": 7,
      "cost_range": [7, 14],
      "grants_parts": [],
      "grants_structures": [],
      "immediate_effect": null,
      "prerequisites": [],
      "notes": "",
      "sources": []
    },
    {
      "id": "plasma_missile",
      "name": "Plasma Missile",
      "category": "Military",
      "is_rare": false,
      "base_cost": 8,
      "cost_range": [8, 16],
      "grants_parts": ["plasma_missile"],
      "grants_structures": [],
      "immediate_effect": null,
      "prerequisites": [],
      "notes": "Unlocks Plasma Missile ship part.",
      "sources": []
    },

    {
      "id": "gauss_shield",
      "name": "Gauss Shield",
      "category": "Grid",
      "is_rare": false,
      "base_cost": 2,
      "cost_range": [2, 2],
      "grants_parts": ["gauss_shield"],
      "grants_structures": [],
      "immediate_effect": null,
      "prerequisites": [],
      "notes": "Unlocks Gauss Shield ship part.",
      "sources": []
    },
    {
      "id": "fusion_source",
      "name": "Fusion Source",
      "category": "Grid",
      "is_rare": false,
      "base_cost": 3,
      "cost_range": [3, 4],
      "grants_parts": ["fusion_source"],
      "grants_structures": [],
      "immediate_effect": null,
      "prerequisites": [],
      "notes": "Unlocks Fusion Source energy part.",
      "sources": []
    },
    {
      "id": "improved_hull",
      "name": "Improved Hull",
      "category": "Grid",
      "is_rare": false,
      "base_cost": 4,
      "cost_range": [4, 6],
      "grants_parts": ["improved_hull"],
      "grants_structures": [],
      "immediate_effect": null,
      "prerequisites": [],
      "notes": "Unlocks Improved Hull ship part.",
      "sources": []
    },
    {
      "id": "positron_computer",
      "name": "Positron Computer",
      "category": "Grid",
      "is_rare": false,
      "base_cost": 5,
      "cost_range": [5, 8],
      "grants_parts": ["positron_computer"],
      "grants_structures": [],
      "immediate_effect": null,
      "prerequisites": [],
      "notes": "Unlocks Positron Computer ship part.",
      "sources": []
    },
    {
      "id": "advanced_economy",
      "name": "Advanced Economy",
      "category": "Grid",
      "is_rare": false,
      "base_cost": 6,
      "cost_range": [6, 10],
      "grants_parts": [],
      "grants_structures": [],
      "immediate_effect": {"money": 3},
      "prerequisites": [],
      "notes": "Immediate money boost for economic planning.",
      "sources": []
    },
    {
      "id": "tachyon_drive",
      "name": "Tachyon Drive",
      "category": "Grid",
      "is_rare": false,
      "base_cost": 6,
      "cost_range": [6, 12],
      "grants_parts": [],
      "grants_structures": [],
      "immediate_effect": null,
      "prerequisites": [],
      "notes": "",
      "sources": []
    },
    {
      "id": "antimatter_cannon",
      "name": "Antimatter Cannon",
      "category": "Grid",
      "is_rare": false,
      "base_cost": 7,
      "cost_range": [7, 14],
      "grants_parts": [],
      "grants_structures": [],
      "immediate_effect": null,
      "prerequisites": [],
      "notes": "",
      "sources": []
    },
    {
      "id": "quantum_grid",
      "name": "Quantum Grid",
      "category": "Grid",
      "is_rare": false,
      "base_cost": 8,
      "cost_range": [8, 16],
      "grants_parts": ["quantum_grid"],
      "grants_structures": ["quantum_generator"],
      "immediate_effect": null,
      "prerequisites": [],
      "notes": "",
      "sources": []
    },

    {
      "id": "nanorobots",
      "name": "Nanorobots",
      "category": "Nano",
      "is_rare": false,
      "base_cost": 2,
      "cost_range": [2, 2],
      "grants_parts": [],
      "grants_structures": [],
      "immediate_effect": {"materials": 2},
      "prerequisites": [],
      "notes": "Immediate Materials boost.",
      "sources": []
    },
    {
      "id": "fusion_drive",
      "name": "Fusion Drive",
      "category": "Nano",
      "is_rare": false,
      "base_cost": 3,
      "cost_range": [3, 4],
      "grants_parts": ["fusion_drive"],
      "grants_structures": [],
      "immediate_effect": null,
      "prerequisites": [],
      "notes": "Unlocks Fusion Drive ship part.",
      "sources": []
    },
    {
      "id": "orbital",
      "name": "Orbital",
      "category": "Nano",
      "is_rare": false,
      "base_cost": 4,
      "cost_range": [4, 6],
      "grants_parts": [],
      "grants_structures": ["orbital"],
      "immediate_effect": null,
      "prerequisites": [],
      "notes": "Allows construction of Orbitals.",
      "sources": []
    },
    {
      "id": "advanced_robotics",
      "name": "Advanced Robotics",
      "category": "Nano",
      "is_rare": false,
      "base_cost": 5,
      "cost_range": [5, 8],
      "grants_parts": [],
      "grants_structures": [],
      "immediate_effect": null,
      "prerequisites": [],
      "notes": "",
      "sources": []
    },
    {
      "id": "advanced_labs",
      "name": "Advanced Labs",
      "category": "Nano",
      "is_rare": false,
      "base_cost": 6,
      "cost_range": [6, 10],
      "grants_parts": [],
      "grants_structures": [],
      "immediate_effect": {"science": 2},
      "prerequisites": [],
      "notes": "Immediate Science boost.",
      "sources": []
    },
    {
      "id": "monolith",
      "name": "Monolith",
      "category": "Nano",
      "is_rare": false,
      "base_cost": 6,
      "cost_range": [6, 12],
      "grants_parts": [],
      "grants_structures": ["monolith"],
      "immediate_effect": null,
      "prerequisites": [],
      "notes": "Allows construction of Monoliths.",
      "sources": []
    },
    {
      "id": "wormhole_generator",
      "name": "Wormhole Generator",
      "category": "Nano",
      "is_rare": false,
      "base_cost": 7,
      "cost_range": [7, 14],
      "grants_parts": [],
      "grants_structures": [],
      "immediate_effect": {"wormhole_generator": true},
      "prerequisites": [],
      "notes": "Allows one Jump ignoring wormholes per activation.",
      "sources": []
    },
    {
      "id": "artifact_key",
      "name": "Artifact Key",
      "category": "Nano",
      "is_rare": false,
      "base_cost": 8,
      "cost_range": [8, 16],
      "grants_parts": [],
      "grants_structures": [],
      "immediate_effect": null,
      "prerequisites": [],
      "notes": "",
      "sources": []
    },

    {
      "id": "absorption_shield",
      "name": "Absorption Shield",
      "category": "Rare",
      "is_rare": true,
      "base_cost": 6,
      "cost_range": [6, 7],
      "grants_parts": [],
      "grants_structures": [],
      "immediate_effect": null,
      "prerequisites": [],
      "notes": "",
      "sources": []
    },
    {
      "id": "antimatter_splitter",
      "name": "Antimatter Splitter",
      "category": "Rare",
      "is_rare": true,
      "base_cost": 5,
      "cost_range": [5, 5],
      "grants_parts": [],
      "grants_structures": [],
      "immediate_effect": null,
      "prerequisites": [],
      "notes": "",
      "sources": []
    },
    {
      "id": "cloaking_device",
      "name": "Cloaking Device",
      "category": "Rare",
      "is_rare": true,
      "base_cost": 6,
      "cost_range": [6, 7],
      "grants_parts": [],
      "grants_structures": [],
      "immediate_effect": null,
      "prerequisites": [],
      "notes": "",
      "sources": []
    },
    {
      "id": "conifold_field",
      "name": "Conifold Field",
      "category": "Rare",
      "is_rare": true,
      "base_cost": 5,
      "cost_range": [5, 5],
      "grants_parts": [],
      "grants_structures": [],
      "immediate_effect": null,
      "prerequisites": [],
      "notes": "",
      "sources": []
    },
    {
      "id": "flux_missile",
      "name": "Flux Missile",
      "category": "Rare",
      "is_rare": true,
      "base_cost": 8,
      "cost_range": [8, 11],
      "grants_parts": [],
      "grants_structures": [],
      "immediate_effect": null,
      "prerequisites": [],
      "notes": "",
      "sources": []
    },
    {
      "id": "improved_logistics",
      "name": "Improved Logistics",
      "category": "Rare",
      "is_rare": true,
      "base_cost": 6,
      "cost_range": [6, 7],
      "grants_parts": [],
      "grants_structures": [],
      "immediate_effect": {"influence_disk": 1},
      "prerequisites": [],
      "notes": "",
      "sources": []
    },
    {
      "id": "metasynthesis",
      "name": "Metasynthesis",
      "category": "Rare",
      "is_rare": true,
      "base_cost": 11,
      "cost_range": [11, 17],
      "grants_parts": [],
      "grants_structures": [],
      "immediate_effect": null,
      "prerequisites": [],
      "notes": "",
      "sources": []
    },
    {
      "id": "neutron_absorber",
      "name": "Neutron Absorber",
      "category": "Rare",
      "is_rare": true,
      "base_cost": 5,
      "cost_range": [5, 5],
      "grants_parts": [],
      "grants_structures": [],
      "immediate_effect": null,
      "prerequisites": [],
      "notes": "",
      "sources": []
    },
    {
      "id": "rift_cannon",
      "name": "Rift Cannon",
      "category": "Rare",
      "is_rare": true,
      "base_cost": 7,
      "cost_range": [7, 9],
      "grants_parts": [],
      "grants_structures": [],
      "immediate_effect": null,
      "prerequisites": [],
      "notes": "",
      "sources": []
    },
    {
      "id": "sentient_hull",
      "name": "Sentient Hull",
      "category": "Rare",
      "is_rare": true,
      "base_cost": 5,
      "cost_range": [5, 5],
      "grants_parts": [],
      "grants_structures": [],
      "immediate_effect": null,
      "prerequisites": [],
      "notes": "",
      "sources": []
    },
    {
      "id": "soliton_cannon",
      "name": "Soliton Cannon",
      "category": "Rare",
      "is_rare": true,
      "base_cost": 7,
      "cost_range": [7, 9],
      "grants_parts": [],
      "grants_structures": [],
      "immediate_effect": null,
      "prerequisites": [],
      "notes": "",
      "sources": []
    },
    {
      "id": "transition_drive",
      "name": "Transition Drive",
      "category": "Rare",
      "is_rare": true,
      "base_cost": 7,
      "cost_range": [7, 9],
      "grants_parts": [],
      "grants_structures": [],
      "immediate_effect": null,
      "prerequisites": [],
      "notes": "",
      "sources": []
    },
    {
      "id": "zero_point_source",
      "name": "Zero-Point Source",
      "category": "Rare",
      "is_rare": true,
      "base_cost": 10,
      "cost_range": [10, 15],
      "grants_parts": [],
      "grants_structures": [],
      "immediate_effect": {"money": 4},
      "prerequisites": [],
      "notes": "Immediate money windfall.",
      "sources": []
    }
  ]
}

===== FILE: eclipse_ai/data/tech_costs_second_dawn.json =====

{
  "regular_tech": {
    "Military": [
      {"name": "Neutron Bombs", "min_cost": 2, "max_cost": 2},
      {"name": "Starbase", "min_cost": 3, "max_cost": 4},
      {"name": "Plasma Cannon", "min_cost": 4, "max_cost": 6},
      {"name": "Phase Shield", "min_cost": 5, "max_cost": 8},
      {"name": "Advanced Mining", "min_cost": 6, "max_cost": 10},
      {"name": "Tachyon Source", "min_cost": 6, "max_cost": 12},
      {"name": "Gluon Computer", "min_cost": 7, "max_cost": 14},
      {"name": "Plasma Missile", "min_cost": 8, "max_cost": 16}
    ],
    "Grid": [
      {"name": "Gauss Shield", "min_cost": 2, "max_cost": 2},
      {"name": "Fusion Source", "min_cost": 3, "max_cost": 4},
      {"name": "Improved Hull", "min_cost": 4, "max_cost": 6},
      {"name": "Positron Computer", "min_cost": 5, "max_cost": 8},
      {"name": "Advanced Economy", "min_cost": 6, "max_cost": 10},
      {"name": "Tachyon Drive", "min_cost": 6, "max_cost": 12},
      {"name": "Antimatter Cannon", "min_cost": 7, "max_cost": 14},
      {"name": "Quantum Grid", "min_cost": 8, "max_cost": 16}
    ],
    "Nano": [
      {"name": "Nanorobots", "min_cost": 2, "max_cost": 2},
      {"name": "Fusion Drive", "min_cost": 3, "max_cost": 4},
      {"name": "Orbital", "min_cost": 4, "max_cost": 6},
      {"name": "Advanced Robotics", "min_cost": 5, "max_cost": 8},
      {"name": "Advanced Labs", "min_cost": 6, "max_cost": 10},
      {"name": "Monolith", "min_cost": 6, "max_cost": 12},
      {"name": "Wormhole Generator", "min_cost": 7, "max_cost": 14},
      {"name": "Artifact Key", "min_cost": 8, "max_cost": 16}
    ]
  },
  "rare_technologies": [
    {"name": "Absorption Shield", "min_cost": 6, "max_cost": 7},
    {"name": "Antimatter Splitter", "min_cost": 5, "max_cost": 5},
    {"name": "Cloaking Device", "min_cost": 6, "max_cost": 7},
    {"name": "Conifold Field", "min_cost": 5, "max_cost": 5},
    {"name": "Flux Missile", "min_cost": 8, "max_cost": 11},
    {"name": "Improved Logistics", "min_cost": 6, "max_cost": 7},
    {"name": "Metasynthesis", "min_cost": 11, "max_cost": 17},
    {"name": "Neutron Absorber", "min_cost": 5, "max_cost": 5},
    {"name": "Rift Cannon", "min_cost": 7, "max_cost": 9},
    {"name": "Sentient Hull", "min_cost": 5, "max_cost": 5},
    {"name": "Soliton Cannon", "min_cost": 7, "max_cost": 9},
    {"name": "Transition Drive", "min_cost": 7, "max_cost": 9},
    {"name": "Zero-Point Source", "min_cost": 10, "max_cost": 15}
  ]
}

===== FILE: eclipse_ai/diplomacy.py =====

"""Diplomatic relation management."""
from __future__ import annotations

from typing import Dict, Iterable, Optional, Tuple

from .game_models import GameState, PlayerState, Hex, Pieces
from .map.connectivity import has_full_wormhole


class DiplomacyError(RuntimeError):
    """Raised when attempting to perform an illegal diplomatic action."""


def can_form_diplomacy(state: GameState, a_id: str, b_id: str) -> bool:
    """Return ``True`` when two players may legally form diplomatic relations."""
    if not state or not state.players:
        return False
    if a_id == b_id:
        return False
    if len(state.players) <= 3:
        return False
    player_a = state.players.get(a_id)
    player_b = state.players.get(b_id)
    if player_a is None or player_b is None:
        return False
    if player_a.has_traitor or player_b.has_traitor:
        return False
    if player_a.ambassadors.get(b_id) or player_b.ambassadors.get(a_id):
        return False
    if not (_has_available_population(player_a) and _has_available_population(player_b)):
        return False

    for hex_a in _controlled_hexes(state, a_id):
        for hex_b in _controlled_hexes(state, b_id):
            if not has_full_wormhole(state.map, hex_a.id, hex_b.id):
                continue
            if _has_other_player_ships(hex_a, b_id):
                continue
            if _has_other_player_ships(hex_b, a_id):
                continue
            return True
    return False


def form_diplomacy(state: GameState, a_id: str, b_id: str) -> None:
    """Establish mutual ambassadors and spend population cubes."""
    if not can_form_diplomacy(state, a_id, b_id):
        raise DiplomacyError("Diplomatic relation requirements not met")

    player_a = state.players[a_id]
    player_b = state.players[b_id]
    color_a = _spend_population_cube(player_a)
    color_b = _spend_population_cube(player_b)

    player_a.ambassadors[b_id] = True
    player_b.ambassadors[a_id] = True
    player_a.diplomacy[b_id] = color_a
    player_b.diplomacy[a_id] = color_b


def break_diplomacy(state: GameState, attacker_id: str, defender_id: str) -> None:
    """Break diplomatic relations due to hostile action."""
    removed = _remove_ambassadors(state, attacker_id, defender_id)
    if not removed:
        return
    attacker = state.players.get(attacker_id)
    if attacker:
        attacker.has_traitor = True


def clear_diplomacy(state: GameState, a_id: str, b_id: str) -> None:
    """Remove ambassadors for a pair without assigning the Traitor penalty."""
    _remove_ambassadors(state, a_id, b_id)


def has_diplomatic_relation(state: GameState, a_id: str, b_id: str) -> bool:
    player_a = state.players.get(a_id) if state else None
    player_b = state.players.get(b_id) if state else None
    if player_a is None or player_b is None:
        return False
    return bool(player_a.ambassadors.get(b_id) and player_b.ambassadors.get(a_id))


# ----- Internal helpers -----

def _remove_ambassadors(state: GameState, a_id: str, b_id: str) -> bool:
    player_a = state.players.get(a_id) if state else None
    player_b = state.players.get(b_id) if state else None
    if player_a is None or player_b is None:
        return False
    removed = False
    color_a = player_a.diplomacy.pop(b_id, None)
    color_b = player_b.diplomacy.pop(a_id, None)
    if color_a:
        player_a.population[color_a] = player_a.population.get(color_a, 0) + 1
        removed = True
    if color_b:
        player_b.population[color_b] = player_b.population.get(color_b, 0) + 1
        removed = True
    if player_a.ambassadors.pop(b_id, None):
        removed = True
    if player_b.ambassadors.pop(a_id, None):
        removed = True
    return removed


def _controlled_hexes(state: GameState, player_id: str) -> Iterable[Hex]:
    if not state or not state.map or not state.map.hexes:
        return []
    result = []
    for hx in state.map.hexes.values():
        pieces = hx.pieces.get(player_id) if hx.pieces else None
        if pieces and int(pieces.discs) > 0:
            result.append(hx)
    return result


def _has_other_player_ships(hex_obj: Hex, player_id: str) -> bool:
    if not hex_obj or not hex_obj.pieces:
        return False
    pieces = hex_obj.pieces.get(player_id)
    if pieces is None:
        return False
    return _has_ships(pieces)


def _has_ships(pieces: Pieces) -> bool:
    if pieces.starbase:
        return True
    return any(int(count) > 0 for count in pieces.ships.values())


def _has_available_population(player: Optional[PlayerState]) -> bool:
    if player is None:
        return False
    return any(count > 0 for count in player.population.values())


def _spend_population_cube(player: PlayerState) -> str:
    for color, count in player.population.items():
        if count > 0:
            player.population[color] = count - 1
            return color
    raise DiplomacyError("Player lacks population cubes to become ambassador")


__all__ = [
    "DiplomacyError",
    "can_form_diplomacy",
    "form_diplomacy",
    "break_diplomacy",
    "clear_diplomacy",
    "has_diplomatic_relation",
]

===== FILE: eclipse_ai/eclipse_test/board.jpg.annotations.json =====

{
  "hexes": [
    {
      "id": "H-010",
      "ring": 2,
      "wormholes": [0,2,4],
      "planets": [
        {"type":"yellow","colonized_by":"you"},
        {"type":"blue","colonized_by":null}
      ],
      "pieces": [
        {"owner":"you","ships":{"interceptor":2},"starbase":0,"discs":1,"cubes":{"y":1}},
        {"owner":"blue","ships":{"cruiser":2},"starbase":0,"discs":1}
      ]
    }
  ]
}

===== FILE: eclipse_ai/eclipse_test/cases/ancient/board.jpg.annotations.json =====

{
  "hexes": [
    {
      "id": "H-101",
      "ring": 2,
      "wormholes": [1,3,5],
      "planets": [{"type":"brown","colonized_by":null},{"type":"yellow","colonized_by":null}],
      "ancients": 1,
      "pieces": [
        {"owner":"you","ships":{"interceptor":2,"cruiser":1},"discs":1},
        {"owner":"blue","ships":{"cruiser":1}}
      ]
    }
  ]
}

===== FILE: eclipse_ai/eclipse_test/cases/ancient/tech.jpg.tech.json =====

{
  "available": ["Ion Cannon","Advanced Mining","Wormhole Generator"],
  "tier_counts": {"I":5,"II":6,"III":4}
}

===== FILE: eclipse_ai/eclipse_test/render_report.py =====

"""Generate a simple SVG summary for a saved test run."""

from __future__ import annotations

import argparse
import json
import textwrap
from pathlib import Path
from typing import Iterable
from xml.sax.saxutils import escape


SVG_WIDTH = 900
HEADER_Y = 40
LEFT_MARGIN = 30
RIGHT_MARGIN = 30
CARD_PADDING = 16
CARD_SPACING = 20
TITLE_FONT_SIZE = 18
BODY_FONT_SIZE = 14
TITLE_LINE_HEIGHT = 24
LINE_HEIGHT = 20


def _risk_color(risk: float | None) -> str:
    if risk is None:
        return "#f5f5f5"
    if risk < 0.2:
        return "#d0f0c0"
    if risk < 0.4:
        return "#fff4b3"
    if risk < 0.6:
        return "#ffdab9"
    return "#ffc0cb"


def _fmt_number(value, percent: bool = False) -> str:
    if value is None:
        return "N/A"
    if percent:
        return f"{value * 100:.1f}%"
    return f"{value:.2f}"


def _format_payload(payload) -> str:
    if payload is None or payload == {}:
        return ""
    if isinstance(payload, (str, int, float)):
        return str(payload)
    return json.dumps(payload, ensure_ascii=False)


def _plan_body_lines(plan: dict) -> tuple[str, list[str]]:
    title = plan.get("label") or plan.get("action") or "Plan"
    score = _fmt_number(plan.get("score"))
    risk = _fmt_number(plan.get("risk"), percent=True)
    header = f"Score: {score}    Risk: {risk}"

    lines: list[str] = [header, ""]
    steps: Iterable[dict] = plan.get("steps", [])
    if not steps:
        lines.append("No detailed steps provided.")
        return title, lines

    for idx, step in enumerate(steps, start=1):
        action = step.get("action", "?")
        payload = _format_payload(step.get("payload"))
        stats_parts = []
        if step.get("ev") is not None:
            stats_parts.append(f"EV {_fmt_number(step['ev'])}")
        if step.get("risk") is not None:
            stats_parts.append(f"Risk {_fmt_number(step['risk'], percent=True)}")
        stats = f" ({', '.join(stats_parts)})" if stats_parts else ""
        raw_line = f"{idx}. {action}: {payload}{stats}"
        wrapped = textwrap.wrap(raw_line, width=80) or [raw_line]
        lines.extend(wrapped)
    return title, lines


def render_report(data: dict, output_path: Path, *, title: str | None = None) -> None:
    plans = data.get("plans", [])
    if not plans:
        raise ValueError("No plans were found in the provided test output.")

    cards = []
    for plan in plans:
        plan_title, body_lines = _plan_body_lines(plan)
        color = _risk_color(plan.get("risk"))
        line_count = len(body_lines)
        card_height = CARD_PADDING * 2 + TITLE_LINE_HEIGHT + line_count * LINE_HEIGHT
        cards.append((plan_title, body_lines, color, card_height))

    total_height = HEADER_Y + 30  # space for header text
    for _, _, _, card_height in cards:
        total_height += card_height + CARD_SPACING

    total_height += CARD_SPACING

    round_no = data.get("round")
    active_player = data.get("active_player")
    composed_title = title or "Eclipse AI Test Run"
    meta_parts = []
    if round_no is not None:
        meta_parts.append(f"Round {round_no}")
    if active_player is not None:
        meta_parts.append(f"Active: {active_player}")
    if meta_parts:
        composed_title += "  " + "  ".join(meta_parts)

    svg_parts = [
        f'<svg xmlns="http://www.w3.org/2000/svg" width="{SVG_WIDTH}" height="{total_height}" viewBox="0 0 {SVG_WIDTH} {total_height}">',
        '<style>'
        'text { font-family: "DejaVu Sans", "Helvetica", "Arial", sans-serif; fill: #1a1a1a; }'
        '</style>',
        f'<text x="{LEFT_MARGIN}" y="{HEADER_Y}" font-size="24" font-weight="bold">{escape(composed_title)}</text>',
    ]

    y = HEADER_Y + 30
    card_width = SVG_WIDTH - LEFT_MARGIN - RIGHT_MARGIN

    for plan_title, body_lines, color, card_height in cards:
        svg_parts.append(
            f'<rect x="{LEFT_MARGIN}" y="{y}" width="{card_width}" height="{card_height}" rx="16" ry="16" fill="{color}" stroke="#cccccc" stroke-width="1" />'
        )
        text_y = y + CARD_PADDING + TITLE_LINE_HEIGHT
        svg_parts.append(
            f'<text x="{LEFT_MARGIN + 14}" y="{text_y}" font-size="{TITLE_FONT_SIZE}" font-weight="bold">{escape(plan_title)}</text>'
        )
        body_y = text_y + BODY_FONT_SIZE
        for line in body_lines:
            svg_parts.append(
                f'<text x="{LEFT_MARGIN + 14}" y="{body_y}" font-size="{BODY_FONT_SIZE}">{escape(line)}</text>'
            )
            body_y += LINE_HEIGHT
        y += card_height + CARD_SPACING

    svg_parts.append("</svg>")

    output_path.parent.mkdir(parents=True, exist_ok=True)
    output_path.write_text("\n".join(svg_parts), encoding="utf-8")


def main() -> None:
    parser = argparse.ArgumentParser(description=__doc__)
    parser.add_argument("input", type=Path, help="Path to a JSON file saved by run_test.")
    parser.add_argument(
        "--output",
        type=Path,
        default=Path("tests") / "test_report.svg",
        help="Destination path for the rendered SVG report.",
    )
    parser.add_argument("--title", help="Optional custom title for the report header.")
    args = parser.parse_args()

    with args.input.open("r", encoding="utf-8") as fh:
        data = json.load(fh)

    render_report(data, args.output, title=args.title)


if __name__ == "__main__":
    main()

===== FILE: eclipse_ai/eclipse_test/run_test.py =====

import os, sys, json, argparse
sys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), "..", "..")))
try:
    from eclipse_ai import recommend
    from eclipse_ai.game_models import GameState
except Exception:
    # fallback: try installed package
    from eclipse_ai import recommend
    from eclipse_ai.game_models import GameState


ORION_ROUND1_STATE = {
    "round": 1,
    "active_player": "orion",
    "players": {
        "orion": {
            "player_id": "orion",
            "color": "purple",
            "known_techs": ["Gauss Shield"],
            "resources": {"money": 2, "science": 1, "materials": 2},
            "ship_designs": {
                "interceptor": {
                    "computer": 1,
                    "shield": 1,
                    "initiative": 2,
                    "hull": 1,
                    "cannons": 1,
                    "missiles": 0,
                    "drive": 1,
                },
                "cruiser": {
                    "computer": 1,
                    "shield": 1,
                    "initiative": 3,
                    "hull": 1,
                    "cannons": 1,
                    "missiles": 0,
                    "drive": 1,
                },
            },
        },
        "terran": {
            "player_id": "terran",
            "color": "orange",
            "known_techs": ["Fusion Drive"],
            "resources": {"money": 3, "science": 2, "materials": 2},
            "ship_designs": {
                "interceptor": {
                    "computer": 1,
                    "shield": 0,
                    "initiative": 2,
                    "hull": 1,
                    "cannons": 1,
                    "missiles": 0,
                    "drive": 1,
                }
            },
        },
        "mechanema": {
            "player_id": "mechanema",
            "color": "teal",
            "known_techs": ["Positron Computer"],
            "resources": {"money": 1, "science": 3, "materials": 1},
            "ship_designs": {
                "interceptor": {
                    "computer": 1,
                    "shield": 0,
                    "initiative": 2,
                    "hull": 1,
                    "cannons": 1,
                    "missiles": 0,
                    "drive": 1,
                }
            },
        },
        "magellan": {
            "player_id": "magellan",
            "color": "green",
            "known_techs": ["Ion Thruster"],
            "resources": {"money": 1, "science": 1, "materials": 3},
            "ship_designs": {
                "interceptor": {
                    "computer": 1,
                    "shield": 0,
                    "initiative": 2,
                    "hull": 1,
                    "cannons": 1,
                    "missiles": 0,
                    "drive": 1,
                }
            },
        },
        "rho_indi": {
            "player_id": "rho_indi",
            "color": "yellow",
            "known_techs": ["Gluon Computer"],
            "resources": {"money": 4, "science": 0, "materials": 1},
            "ship_designs": {
                "interceptor": {
                    "computer": 1,
                    "shield": 0,
                    "initiative": 2,
                    "hull": 1,
                    "cannons": 1,
                    "missiles": 0,
                    "drive": 1,
                },
                "cruiser": {
                    "computer": 1,
                    "shield": 0,
                    "initiative": 3,
                    "hull": 1,
                    "cannons": 1,
                    "missiles": 0,
                    "drive": 1,
                },
            },
        },
    },
    "map": {
        "hexes": {
            "230": {
                "id": "230",
                "ring": 1,
                "wormholes": [0, 3, 5],
                "planets": [
                    {"type": "yellow", "colonized_by": "orion"},
                    {"type": "blue", "colonized_by": "orion"},
                    {"type": "brown", "colonized_by": "orion"},
                ],
                "pieces": {
                    "orion": {
                        "ships": {"interceptor": 2, "cruiser": 1},
                        "starbase": 0,
                        "discs": 1,
                        "cubes": {"yellow": 1, "blue": 1, "brown": 1},
                    }
                },
            },
            "terran_home": {
                "id": "terran_home",
                "ring": 1,
                "wormholes": [1, 4],
                "planets": [
                    {"type": "yellow", "colonized_by": "terran"},
                    {"type": "blue", "colonized_by": "terran"},
                    {"type": "brown", "colonized_by": "terran"},
                ],
                "pieces": {
                    "terran": {
                        "ships": {"interceptor": 2},
                        "starbase": 0,
                        "discs": 1,
                        "cubes": {"yellow": 1, "blue": 1, "brown": 1},
                    }
                },
            },
            "mechanema_home": {
                "id": "mechanema_home",
                "ring": 1,
                "wormholes": [0, 2, 5],
                "planets": [
                    {"type": "blue", "colonized_by": "mechanema"},
                    {"type": "blue", "colonized_by": "mechanema"},
                    {"type": "brown", "colonized_by": "mechanema"},
                ],
                "pieces": {
                    "mechanema": {
                        "ships": {"interceptor": 2},
                        "starbase": 0,
                        "discs": 1,
                        "cubes": {"blue": 2, "brown": 1},
                    }
                },
            },
            "magellan_home": {
                "id": "magellan_home",
                "ring": 1,
                "wormholes": [1, 3, 4],
                "planets": [
                    {"type": "brown", "colonized_by": "magellan"},
                    {"type": "brown", "colonized_by": "magellan"},
                    {"type": "yellow", "colonized_by": "magellan"},
                ],
                "pieces": {
                    "magellan": {
                        "ships": {"interceptor": 2},
                        "starbase": 0,
                        "discs": 1,
                        "cubes": {"brown": 2, "yellow": 1},
                    }
                },
            },
            "rho_home": {
                "id": "rho_home",
                "ring": 1,
                "wormholes": [0, 2, 4],
                "planets": [
                    {"type": "yellow", "colonized_by": "rho_indi"},
                    {"type": "yellow", "colonized_by": "rho_indi"},
                    {"type": "blue", "colonized_by": None},
                ],
                "pieces": {
                    "rho_indi": {
                        "ships": {"cruiser": 1},
                        "starbase": 0,
                        "discs": 1,
                        "cubes": {"yellow": 2},
                    }
                },
            },
            "outer_frontier": {
                "id": "outer_frontier",
                "ring": 2,
                "wormholes": [1, 4],
                "explored": False,
                "planets": [
                    {"type": "yellow", "colonized_by": None},
                    {"type": "blue", "colonized_by": None},
                    {"type": "brown", "colonized_by": None},
                ],
                "pieces": {},
            },
        }
    },
    "tech_display": {
        "available": [
            "Plasma Cannon I",
            "Fusion Drive I",
            "Advanced Mining",
            "Positron Computer",
            "Gauss Shield",
            "Neutron Absorber",
        ],
        "tier_counts": {"I": 6, "II": 4, "III": 2},
    },
    "bags": {
        "R1": {"unknown": 5},
        "R2": {"unknown": 4},
    },
}

p = argparse.ArgumentParser()
p.add_argument("--board", default="board.jpg")
p.add_argument("--tech",  default="tech.jpg")
p.add_argument("--sims",  type=int, default=200)
p.add_argument("--depth", type=int, default=2)
p.add_argument("--topk",  type=int, default=5)
p.add_argument(
    "--output",
    help="Optional path to write the summarized test result JSON."
)
args = p.parse_args()

manual = {"_planner": {"simulations": args.sims, "depth": args.depth, "risk_aversion": 0.25}}
state = GameState.from_dict(ORION_ROUND1_STATE)
out = recommend(args.board, args.tech, prior_state=state, manual_inputs=manual, top_k=args.topk)

summary = {
    "round": out.get("round"),
    "active_player": out.get("active_player"),
    "plans": out.get("plans")[:3],   # show top 3
    "enemy_posteriors": out.get("enemy_posteriors", {}),
    "expected_bags": out.get("expected_bags", {}),
}

if args.output:
    with open(args.output, "w", encoding="utf-8") as fh:
        json.dump(summary, fh, indent=2)

print(json.dumps(summary, indent=2))

===== FILE: eclipse_ai/eclipse_test/tech.jpg.tech.json =====

{
  "available": ["Plasma Cannon","Fusion Drive","Positron Computer"],
  "tier_counts": {"I":6,"II":5,"III":4}
}

===== FILE: eclipse_ai/evaluator.py =====

from __future__ import annotations
from typing import Dict, Any, Optional, Tuple, List
from dataclasses import dataclass
import math

from .game_models import GameState, Action, Score, ActionType, PlayerState, Hex, Planet, Pieces, ShipDesign
from .simulators.combat import score_combat
from .explore_eval import explore_ev
from .simulators.exploration import exploration_ev

# ===== Public API =====

def evaluate_action(state: GameState, action: Action) -> Score:
    """
    Heuristic + simulator-backed scoring to an expected VP delta and risk.
    Robust to missing fields. Uses conservative defaults.
    """
    t = action.type
    pid = state.active_player or "you"
    if t == ActionType.EXPLORE:
        return _score_explore(state, pid, action.payload)
    if t == ActionType.MOVE:
        return _score_move(state, pid, action.payload)
    if t == ActionType.BUILD:
        return _score_build(state, pid, action.payload)
    if t == ActionType.RESEARCH:
        return _score_research(state, pid, action.payload)
    if t == ActionType.UPGRADE:
        return _score_upgrade(state, pid, action.payload)
    if t == ActionType.INFLUENCE:
        return _score_influence(state, pid, action.payload)
    if t == ActionType.DIPLOMACY:
        return _score_diplomacy(state, pid, action.payload)
    if t == ActionType.PASS:
        return Score(expected_vp=0.0, risk=0.0, details={})
    return Score(expected_vp=0.0, risk=0.5, details={"unknown_action": str(t)})

# ===== Explore =====

def _score_explore(state: GameState, pid: str, payload: Dict[str, Any]) -> Score:
    tile_payload = payload.get("tile")
    target_hex = payload.get("pos") or payload.get("position") or payload.get("hex")
    if tile_payload and target_hex:
        orient = int(payload.get("orient", payload.get("orientation", 0)))
        try:
            ev_value = explore_ev(state, pid, tile_payload, str(target_hex), orient)
            risk = 0.25
            return Score(expected_vp=float(ev_value), risk=risk, details={"heuristic": "tile_ev"})
        except Exception:
            pass

    ring = int(payload.get("ring", 2))
    bag = dict(state.bags.get(f"R{ring}", {}))
    if not bag:
        return Score(expected_vp=0.0, risk=0.35, details={"reason":"no_bag_data","ring": ring})

    you = state.players.get(pid) if state.players else None
    draws = int(payload.get("draws", 1))
    owned = you.owned_tech_ids if you and you.owned_tech_ids else set()
    wormhole_gen = ("wormhole_generator" in owned) or bool(payload.get("wormhole_generator", False))
    discs_available = int(payload.get("discs_available", 1))
    colony_ships = dict(payload.get("colony_ships", {"yellow":1,"blue":1,"brown":1,"wild":0}))
    p_connect_default = float(payload.get("p_connect_default", 0.70))

    q = {
        "ring": ring,
        "bag": bag,
        "draws": draws,
        "wormhole_generator": wormhole_gen,
        "discs_available": discs_available,
        "colony_ships": colony_ships,
        "p_connect_default": p_connect_default,
        "n_sims": int(payload.get("n_sims", 4000)),
    }
    # If the caller wants to model Ancients clearing EV, pass a combat query through
    if "ancient_combat_query" in payload:
        q["ancient_combat_query"] = payload["ancient_combat_query"]

    ev = exploration_ev(q)

    # Risk: chance to hit an Ancient or fail connection dominates.
    total = max(1, sum(bag.values()))
    p_anc = float(bag.get("ancient", 0)) / total
    base_risk = 0.2 + 0.5 * p_anc + 0.2 * (1.0 - (1.0 if wormhole_gen else p_connect_default))
    base_risk = max(0.05, min(0.95, base_risk))

    return Score(expected_vp=float(ev.expected_value_vp), risk=base_risk, details={"explore_notes": ev.notes})

# ===== Move (with optional combat) =====

def _score_move(state: GameState, pid: str, payload: Dict[str, Any]) -> Score:
    src = payload.get("from")
    dst = payload.get("to")
    if not dst:
        return Score(expected_vp=0.0, risk=0.2, details={"reason":"missing_destination"})
    h_from = _get_hex(state, src) if src else None
    h_to = _get_hex(state, dst)

    # Fleet to move
    move_ships: Dict[str,int] = dict(payload.get("ships", {}))
    if not move_ships and h_from and pid in h_from.pieces:
        # Default: move all small ships if unspecified
        move_ships = dict(h_from.pieces[pid].ships)

    # If destination empty of enemies and ancients, movement is positional.
    enemy_presence = _enemy_presence_in_hex(state, pid, h_to) if h_to else 0
    ancients = int(h_to.ancients) if h_to else 0

    if (enemy_presence + ancients) == 0:
        terr_ev = _territory_value_of_hex(h_to)
        # Slight bonus for consolidating fleets
        fleet_bonus = 0.05 * sum(move_ships.values())
        return Score(expected_vp=terr_ev + fleet_bonus, risk=0.1, details={"positional": True, "territory_ev": round(terr_ev,3)})

    # Build combat query from state + payload
    cq = _combat_query_from_state(state, pid, h_from, h_to, move_ships, ancient_count=ancients)
    cq["n_sims"] = int(payload.get("n_sims", 50))
    res = score_combat(cq)

    # Post-control EV if attacker wins: ability to claim planets / monolith
    post_ctrl_ev = 0.0
    if h_to:
        post_ctrl_ev = _territory_value_of_hex(h_to) * res.win_prob

    expected_vp = float(res.expected_vp_swing) + post_ctrl_ev
    risk = max(0.05, min(0.95, 1.0 - float(res.win_prob)))

    details = {
        "combat_win_prob": round(res.win_prob, 3),
        "post_control_ev": round(post_ctrl_ev, 3),
        "expected_losses_attacker": round(res.expected_losses_attacker, 3),
        "expected_losses_defender": round(res.expected_losses_defender, 3),
    }
    return Score(expected_vp=expected_vp, risk=risk, details=details)

def _combat_query_from_state(state: GameState, pid: str, h_from: Optional[Hex], h_to: Optional[Hex], move_ships: Dict[str,int], ancient_count: int = 0) -> Dict[str,Any]:
    # Attacker
    you = state.players.get(pid) if state.players else None
    atk_designs = _designs_from_player(you)
    attacker = {"ships": dict(move_ships), "designs": atk_designs}

    # Defender union of all enemies + ancients in hex
    def_ships: Dict[str,int] = {}
    def_designs: Dict[str,Any] = {}

    if h_to:
        for opp_id, pieces in h_to.pieces.items():
            if opp_id == pid:
                continue
            # merge ships
            for cls, n in pieces.ships.items():
                def_ships[cls] = def_ships.get(cls, 0) + int(n)
                if cls not in def_designs:
                    def_designs[cls] = _default_enemy_design(cls)
            if pieces.starbase:
                def_ships["starbase"] = def_ships.get("starbase", 0) + int(pieces.starbase)
                if "starbase" not in def_designs:
                    def_designs["starbase"] = _default_enemy_design("starbase")
    if ancient_count > 0:
        def_ships["ancient"] = def_ships.get("ancient", 0) + ancient_count
        def_designs["ancient"] = _default_enemy_design("ancient")

    defender = {"ships": def_ships, "designs": def_designs}
    return {"attacker": attacker, "defender": defender, "targeting":"focus_fire"}

def _designs_from_player(p: Optional[PlayerState]) -> Dict[str,Any]:
    designs: Dict[str,Any] = {}
    if not p or not p.ship_designs:
        return designs
    for cls, d in p.ship_designs.items():
        if not isinstance(d, ShipDesign):
            # tolerate dict-like
            comp = int(d.get("computer", 0))
            sh = int(d.get("shield", 0))
            ini = int(d.get("initiative", 2))
            hull = int(d.get("hull", 1))
            cann = int(d.get("cannons", 1))
            mis = int(d.get("missiles", 0))
        else:
            comp, sh, ini, hull, cann, mis = d.computer, d.shield, d.initiative, d.hull, d.cannons, d.missiles
        designs[cls] = {"initiative": ini, "hull": hull, "computer": comp, "shield": sh, "weapons":{"ion": max(0,int(cann))}, "missiles": max(0,int(mis))}
    return designs

def _default_enemy_design(cls: str) -> Dict[str,Any]:
    # Reasonable generic enemy designs
    table = {
        "interceptor": {"initiative":3,"hull":1,"computer":0,"shield":0,"weapons":{"ion":1},"missiles":0},
        "cruiser":     {"initiative":2,"hull":2,"computer":0,"shield":0,"weapons":{"ion":2},"missiles":0},
        "dreadnought": {"initiative":1,"hull":3,"computer":0,"shield":0,"weapons":{"ion":3},"missiles":0},
        "starbase":    {"initiative":4,"hull":2,"computer":0,"shield":0,"weapons":{"ion":2},"missiles":0},
        "ancient":     {"initiative":2,"hull":2,"computer":1,"shield":1,"weapons":{"ion":2},"missiles":0}
    }
    return dict(table.get(cls, {"initiative":2,"hull":1,"computer":0,"shield":0,"weapons":{"ion":1},"missiles":0}))

def _enemy_presence_in_hex(state: GameState, pid: str, hx: Optional[Hex]) -> int:
    if not hx:
        return 0
    count = 0
    for owner, p in hx.pieces.items():
        if owner == pid:
            continue
        count += int(p.starbase)
        for n in p.ships.values():
            count += int(n)
    return count

def _territory_value_of_hex(hx: Optional[Hex]) -> float:
    if not hx:
        return 0.0
    # Convert planets and monoliths to VP-equivalent present value
    counts = {"yellow":0, "blue":0, "brown":0, "wild":0}
    for pl in hx.planets:
        if pl.colonized_by is None:  # available potential
            if pl.type in counts:
                counts[pl.type] += 1
            elif pl.type.lower().startswith("y"):
                counts["yellow"] += 1
            elif pl.type.lower().startswith("b"):
                counts["blue"] += 1
            elif pl.type.lower().startswith("p") or pl.type.lower().startswith("m"):
                counts["brown"] += 1
            elif pl.type.lower().startswith("w"):
                counts["wild"] += 1
    # Basic PV weights similar to exploration module
    pv = _present_value_factor(3, 0.90)
    ev = (counts["yellow"] + counts["blue"] + counts["brown"]) * 0.20 * pv
    if hx.monolith:
        ev += 3.0 * 0.5
    return ev

# ===== Build =====

def _score_build(state: GameState, pid: str, payload: Dict[str, Any]) -> Score:
    ships = dict(payload.get("ships", {}))
    starbase = int(payload.get("starbase", 0))
    # Econ/position proxy values
    v = 0.15*ships.get("interceptor",0) + 0.45*ships.get("cruiser",0) + 0.90*ships.get("dreadnought",0) + 0.70*starbase
    # Slight threat bonus if building in contested hex
    hx = _get_hex(state, payload.get("hex"))
    threat = 0.15 if _enemy_presence_in_hex(state, pid, hx) > 0 else 0.0
    expected_vp = v + threat
    risk = 0.12 if threat == 0.0 else 0.22
    return Score(expected_vp=expected_vp, risk=risk, details={"ships": ships, "starbase": starbase, "contested": threat > 0})

# ===== Research =====

def _score_research(state: GameState, pid: str, payload: Dict[str, Any]) -> Score:
    tech = str(payload.get("tech", ""))
    if not tech:
        return Score(expected_vp=0.0, risk=0.1, details={"reason":"no_tech"})
    # Base weights
    weights = {
        "plasma": 0.8, "positron": 0.7, "fusion": 0.7, "gauss": 0.6, "ion": 0.4,
        "shield": 0.5, "drive": 0.5, "hull": 0.4,
        "advanced mining": 0.6, "advanced labs": 0.6, "nanorobots": 0.5,
        "wormhole": 0.7, "starbase": 0.4,
    }
    key = tech.lower()
    base = 0.35
    for k, w in weights.items():
        if k in key:
            base = max(base, w)

    # Scale by pressure: more enemies -> more value for combat tech
    pressure = _global_enemy_pressure(state, pid)
    combat_bias = 1.0 + 0.3*pressure
    econ_bias = 1.0 + 0.2*max(0.0, 1.0-pressure)

    if any(k in key for k in ("plasma","positron","gauss","ion","shield","drive","hull","starbase")):
        score = base * combat_bias
    elif any(k in key for k in ("mining","labs","nanorobots")):
        score = base * econ_bias
    elif "wormhole" in key:
        score = base * (1.0 + 0.15)  # improves connectivity
    else:
        score = base

    risk = 0.10
    return Score(expected_vp=score, risk=risk, details={"tech": tech, "pressure": round(pressure,2)})

def _global_enemy_pressure(state: GameState, pid: str) -> float:
    # 0..1 proxy of how contested the map looks
    enemy_ships = 0
    your_hexes = 0
    contested = 0
    for hx in state.map.hexes.values():
        you_here = pid in hx.pieces and any(v>0 for v in hx.pieces[pid].ships.values())
        if you_here:
            your_hexes += 1
        e_here = _enemy_presence_in_hex(state, pid, hx)
        enemy_ships += e_here
        if you_here and e_here>0:
            contested += 1
    if your_hexes == 0:
        return 0.5 if enemy_ships>0 else 0.0
    frac_contested = contested/your_hexes
    return max(0.0, min(1.0, 0.2 + 0.6*frac_contested + 0.2*(enemy_ships/ max(1, len(state.map.hexes)))))

# ===== Upgrade =====

def _score_upgrade(state: GameState, pid: str, payload: Dict[str, Any]) -> Score:
    """
    Evaluate design upgrades by estimating delta fleet power across existing ships.
    payload may include:
      {"apply": {"interceptor":{"cannons":+1,"computer":+1}, "cruiser":{"shield":+1}}}
    """
    you = state.players.get(pid) if state.players else None
    if not you:
        return Score(expected_vp=0.2, risk=0.1, details={"note":"no_player_state"})
    old_power = _fleet_power(state, pid, you.ship_designs)
    new_designs = _apply_design_changes(you.ship_designs, payload.get("apply", {}))
    new_power = _fleet_power(state, pid, new_designs)
    delta = max(0.0, new_power - old_power)
    # Map power delta to VP-equivalent
    expected_vp = 0.25 * delta
    return Score(expected_vp=expected_vp, risk=0.12, details={"delta_power": round(delta,3)})

def _apply_design_changes(designs: Dict[str,ShipDesign], changes: Dict[str,Dict[str,int]]) -> Dict[str,ShipDesign]:
    out: Dict[str,ShipDesign] = {}
    for cls, d in designs.items():
        out[cls] = ShipDesign(**{k:getattr(d,k) for k in ("computer","shield","initiative","hull","cannons","missiles","drive")})
    for cls, mods in changes.items():
        if cls not in out:
            out[cls] = ShipDesign()
        sd = out[cls]
        for k, dv in mods.items():
            if hasattr(sd, k):
                setattr(sd, k, max(0, getattr(sd, k) + int(dv)))
    return out

def _fleet_power(state: GameState, pid: str, designs: Dict[str,ShipDesign]) -> float:
    # Power = sum over ships on board of (guns + 0.8*computer + 0.6*missiles + 0.5*hull + 0.4*shield + 0.3*initiative)
    counts: Dict[str,int] = {}
    for hx in state.map.hexes.values():
        p = hx.pieces.get(pid)
        if not p:
            continue
        for cls, n in p.ships.items():
            counts[cls] = counts.get(cls, 0) + int(n)
        if p.starbase:
            counts["starbase"] = counts.get("starbase", 0) + int(p.starbase)
    power = 0.0
    for cls, n in counts.items():
        d = designs.get(cls, ShipDesign())
        g = max(0, d.cannons)
        power += n * (g + 0.8*d.computer + 0.6*d.missiles + 0.5*d.hull + 0.4*d.shield + 0.3*d.initiative)
    return power

# ===== Influence =====

def _score_influence(state: GameState, pid: str, payload: Dict[str, Any]) -> Score:
    # If income deltas provided, compute PV. Else modest default.
    income = payload.get("income_delta", {})  # {"yellow": +1, "blue": 0, "brown": -1}
    pv = _present_value_factor(int(payload.get("horizon_rounds", 3)), float(payload.get("discount", 0.90)))
    rates = {"yellow":0.20, "blue":0.20, "brown":0.20}
    rates.update(payload.get("vp_per_income", {}))
    ev = 0.0
    for k, dv in income.items():
        if k in ("yellow","blue","brown"):
            ev += float(dv) * float(rates[k]) * pv
    if ev == 0.0:
        ev = 0.25  # typical influence has some tempo value
    return Score(expected_vp=ev, risk=0.08, details={"pv": round(pv,3), "income_delta": income})

# ===== Diplomacy =====

def _score_diplomacy(state: GameState, pid: str, payload: Dict[str, Any]) -> Score:
    # Small positive by default; can increase if targeting the current main rival.
    target = payload.get("with")
    base = 0.3
    # Heuristic: if target has many ships, alliance yields more.
    ships = 0
    if target and state.map:
        for hx in state.map.hexes.values():
            p = hx.pieces.get(target)
            if p:
                ships += sum(int(n) for n in p.ships.values()) + int(p.starbase)
    bonus = 0.1 if ships >= 4 else 0.0
    return Score(expected_vp=base + bonus, risk=0.05, details={"ally": target, "ally_ships": ships})

# ===== Utilities =====

def _get_hex(state: GameState, hex_id: Optional[str]) -> Optional[Hex]:
    if not hex_id or not state or not state.map:
        return None
    return state.map.hexes.get(hex_id)

def _present_value_factor(h: int, d: float) -> float:
    if h <= 0: return 0.0
    if abs(d - 1.0) < 1e-9:
        return float(h)
    return (1.0 - d**h) / (1.0 - d)



===== FILE: eclipse_ai/explore.py =====

from __future__ import annotations

from dataclasses import dataclass, field
from typing import Any, Dict, Optional

from .map.hex import Hex, MapGraph, rotated_wormholes
from .map.decks import ExplorationDecks, HexTile, DiscoveryTile, ResourcePool
from .pathing import compute_connectivity, is_pinned


@dataclass
class PlayerExploreState:
    player_id: str
    resources: ResourcePool = field(default_factory=ResourcePool)
    has_wormhole_generator: bool = False
    influence_discs: int = 0
    discovery_vp: int = 0
    kept_discoveries: list[str] = field(default_factory=list)
    ancient_tech: int = 0
    ancient_cruisers: int = 0
    ancient_parts: int = 0
    turn_ended: bool = False
    colony_ships: Dict[str, int] = field(default_factory=lambda: {"yellow": 0, "blue": 0, "brown": 0, "wild": 0})


@dataclass
class ExploreState:
    map: MapGraph
    decks: ExplorationDecks
    players: Dict[str, PlayerExploreState]
    feature_flags: Dict[str, bool] = field(default_factory=dict)
    connectivity_metrics: Dict[str, Dict[str, Any]] = field(default_factory=dict)

    def end_turn(self, player_id: str) -> None:
        self.players[player_id].turn_ended = True


def choose_explore_target(state: ExploreState, player_id: str, target: str) -> None:
    """Choose an unexplored space adjacent to a controlled hex or unpinned ship."""

    edges = state.map.connection_edges(target)
    if not edges:
        raise ValueError(f"No unexplored space recorded at {target}")
    player = state.players[player_id]
    ok = False
    for _, (neighbor_id, _) in edges.items():
        if neighbor_id not in state.map.hexes:
            continue
        neighbor = state.map.hexes[neighbor_id]
        if neighbor.owner == player_id:
            ok = True
            break
        if neighbor.ships.get(player_id, 0) > 0 and not is_pinned(neighbor, player_id):
            ok = True
            break
    if not ok:
        raise ValueError("Explore target must touch a hex with your disc or unpinned ship")
    state.map.set_choice(player_id, target)


def draw_sector_tile(state: ExploreState, player_id: str, ring: int) -> HexTile:
    pos = state.map.explored_choice.get(player_id)
    if pos is None:
        raise ValueError("Player has not chosen an exploration target")
    deck = state.decks.get_sector(ring)
    return deck.draw()


def discard_sector_tile(state: ExploreState, player_id: str, tile: HexTile) -> None:
    deck = state.decks.get_sector(tile.ring)
    deck.discard(tile)
    state.map.clear_choice(player_id)
    state.end_turn(player_id)


def can_place(tile: HexTile, pos: str, orient: int, state: ExploreState, player_id: str) -> bool:
    assert pos == state.map.explored_choice[player_id]
    ok = has_full_connection_to_player(tile, orient, player_id, state)
    if not ok and state.players[player_id].has_wormhole_generator:
        ok = has_half_connection_to_player(tile, orient, player_id, state)
    return ok


def place_tile(state: ExploreState, player_id: str, tile: HexTile, orient: int) -> Hex:
    if not 0 <= orient < 6:
        raise ValueError("Orientation must be between 0 and 5")
    pos = state.map.explored_choice.get(player_id)
    if pos is None:
        raise ValueError("No exploration target recorded for player")
    if not can_place(tile, pos, orient, state, player_id):
        raise ValueError("Tile does not connect to a hex with your disc or ship")

    wormholes = rotated_wormholes(tile, orient)
    placed = Hex(
        id=pos,
        ring=tile.ring,
        wormholes=wormholes,
        symbols=tuple(tile.symbols),
        warp_portal=tile.warp_portal,
        gcds=tile.gcds,
    )
    pending = state.map.take_pending_edges(pos)
    for edge, (neighbor_id, neighbor_edge) in pending.items():
        placed.neighbors[edge] = neighbor_id
        if neighbor_id in state.map.hexes:
            neighbor = state.map.hexes[neighbor_id]
            neighbor.neighbors[neighbor_edge] = pos
    state.map.add_hex(placed)
    _spawn_discovery_and_ancients(state, placed)
    state.map.clear_choice(player_id)
    try:
        reach = compute_connectivity(state, player_id)
        state.connectivity_metrics[player_id] = {
            "reachable": sorted(reach),
            "count": len(reach),
        }
    except Exception:
        pass
    return placed


def _spawn_discovery_and_ancients(state: ExploreState, hex_obj: Hex) -> None:
    if "discovery" in hex_obj.symbols:
        tile = state.decks.discovery.draw()
        hex_obj.discovery_tile = tile
    ancients = sum(1 for symbol in hex_obj.symbols if symbol == "ancient")
    if ancients:
        hex_obj.ancients += ancients


def has_full_connection_to_player(tile: HexTile, orient: int, player_id: str, state: ExploreState) -> bool:
    pos = state.map.explored_choice[player_id]
    wormholes = set(tile.wormholes)
    edges = state.map.connection_edges(pos)
    for map_edge, (neighbor_id, neighbor_edge) in edges.items():
        tile_edge = (map_edge - orient) % 6
        if tile_edge not in wormholes:
            continue
        neighbor = state.map.hexes.get(neighbor_id)
        if not neighbor:
            continue
        if not neighbor.has_wormhole(neighbor_edge):
            continue
        if neighbor.has_presence(player_id):
            return True
    return False


def has_half_connection_to_player(tile: HexTile, orient: int, player_id: str, state: ExploreState) -> bool:
    pos = state.map.explored_choice[player_id]
    wormholes = set(tile.wormholes)
    edges = state.map.connection_edges(pos)
    for map_edge, (neighbor_id, neighbor_edge) in edges.items():
        neighbor = state.map.hexes.get(neighbor_id)
        if not neighbor:
            continue
        tile_edge = (map_edge - orient) % 6
        tile_has_wormhole = tile_edge in wormholes
        neighbor_has_wormhole = neighbor.has_wormhole(neighbor_edge)
        if not (tile_has_wormhole or neighbor_has_wormhole):
            continue
        if neighbor.has_presence(player_id):
            return True
    return False


def claim_discovery(state: ExploreState, player_id: str, hex_id: str, keep_vp: bool) -> Optional[DiscoveryTile]:
    hex_obj = state.map.hexes[hex_id]
    if hex_obj.owner != player_id:
        raise ValueError("You must control the hex to claim the discovery")
    if hex_obj.ancients > 0:
        raise ValueError("Ancients must be cleared before claiming the discovery")
    tile = hex_obj.discovery_tile
    if tile is None:
        raise ValueError("No discovery tile present")
    player = state.players[player_id]
    if keep_vp:
        player.discovery_vp += 2
        player.kept_discoveries.append(tile.id)
    else:
        tile.apply(player)
        state.decks.discovery.discard(tile)
    hex_obj.discovery_tile = None
    return tile

===== FILE: eclipse_ai/explore_eval.py =====

"""Heuristic exploration evaluation shared across recommendation layers."""
from __future__ import annotations

import copy
from typing import Any, Iterable, Optional, Sequence, Set, Tuple

from .game_models import GameState, Hex as GameHex, Planet
from .pathing import compute_connectivity


def explore_ev(state: GameState, pid: str, tile: Any, pos: str, orient: int = 0) -> float:
    """Return a heuristic EV for placing ``tile`` at ``pos`` for ``pid``.

    The evaluation combines connectivity gain, new frontier reach, tile
    resources, portal utility, hostile exposure, and Ancient penalties. It is
    deliberately coarse but consistent between the action recommender and the
    global action scorer.
    """

    if state is None or not getattr(state, "map", None):
        return 0.0
    if pid not in (getattr(state, "players", {}) or {}):
        return 0.0

    base_reach = compute_connectivity(state, pid)
    base_frontier = _count_frontier_targets(state, base_reach)
    base_threat = _estimate_enemy_pressure(state, pid, base_reach)

    working = copy.deepcopy(state)
    new_hex = _coerce_hex(tile, pos, orient, working)
    _inject_virtual_hex(working, new_hex)

    post_reach = compute_connectivity(working, pid)
    post_frontier = _count_frontier_targets(working, post_reach)
    post_threat = _estimate_enemy_pressure(working, pid, post_reach)

    connectivity_gain = len(post_reach) - len(base_reach)
    frontier_gain = post_frontier - base_frontier
    resource_ev = _resource_value(new_hex, pid)
    portal_bonus = 1.0 if getattr(new_hex, "has_warp_portal", False) else 0.0
    ancient_penalty = -0.75 * int(getattr(new_hex, "ancients", 0) or 0)
    threat_delta = post_threat - base_threat

    # Larger weight on connectivity, moderate on frontier/resources, penalise
    # exposing discs to hostile reach.
    return (
        1.6 * connectivity_gain
        + 0.6 * frontier_gain
        + resource_ev
        + portal_bonus
        - 0.8 * threat_delta
        + ancient_penalty
    )


def _coerce_hex(tile: Any, pos: str, orient: int, state: GameState) -> GameHex:
    if isinstance(tile, GameHex):
        out = copy.deepcopy(tile)
        out.id = pos
        out.explored = True
        if not out.neighbors:
            out.neighbors = {}
        return out

    wormholes: Sequence[int] = tuple(getattr(tile, "wormholes", ()) or ())
    rotated = tuple(sorted((edge + orient) % 6 for edge in wormholes))

    symbols: Sequence[str] = tuple(getattr(tile, "symbols", ()) or ())
    planets: Iterable[Planet] = getattr(tile, "planets", ()) or ()
    planets_list = []
    for planet in planets:
        if isinstance(planet, Planet):
            planets_list.append(copy.deepcopy(planet))
        elif isinstance(planet, dict):
            planets_list.append(Planet(type=str(planet.get("type", "wild")), colonized_by=None))

    ancients = sum(1 for sym in symbols if str(sym).lower() == "ancient")

    out = GameHex(
        id=pos,
        ring=int(getattr(tile, "ring", getattr(state.map.hexes.get(pos, GameHex(id=pos, ring=0)).ring, 0)) or 0),
        wormholes=list(rotated),
        neighbors=dict(getattr(tile, "neighbors", {}) or {}),
        planets=list(planets_list),
        pieces={},
        ancients=ancients,
        monolith=any(str(sym).lower() == "monolith" for sym in symbols),
        orbital=any(str(sym).lower() == "orbital" for sym in symbols),
        anomaly=any(str(sym).lower() == "anomaly" for sym in symbols),
        explored=True,
        has_warp_portal=bool(getattr(tile, "warp_portal", False)),
        has_deep_warp_portal=bool(getattr(tile, "has_deep_warp_portal", False)),
        is_warp_nexus=bool(getattr(tile, "is_warp_nexus", False)),
        has_gcds=bool(getattr(tile, "gcds", False)),
    )
    return out


def _inject_virtual_hex(state: GameState, hex_obj: GameHex) -> None:
    state.map.hexes[hex_obj.id] = hex_obj
    for edge, neighbor_id in (hex_obj.neighbors or {}).items():
        if neighbor_id not in state.map.hexes:
            continue
        neighbor = state.map.hexes[neighbor_id]
        neighbor.neighbors.setdefault(_opposite_edge(edge), hex_obj.id)


def _opposite_edge(edge: int) -> int:
    return (edge + 3) % 6


def _count_frontier_targets(state: GameState, reachable: Set[str]) -> int:
    map_state = state.map
    frontier: Set[Tuple[str, int]] = set()
    for hex_id in reachable:
        hx = map_state.hexes.get(hex_id)
        if hx is None:
            continue
        for edge, neighbor_id in (hx.neighbors or {}).items():
            if not neighbor_id or neighbor_id in map_state.hexes:
                continue
            frontier.add((hex_id, edge))
    return len(frontier)


def _resource_value(hex_obj: GameHex, pid: str) -> float:
    total = 0.0
    if not getattr(hex_obj, "planets", None):
        return total
    weights = {"yellow": 0.45, "blue": 0.5, "brown": 0.55, "wild": 0.65}
    for planet in hex_obj.planets:
        planet_type = getattr(planet, "type", "wild")
        total += weights.get(str(planet_type).lower(), 0.4)
    return total


def _estimate_enemy_pressure(state: GameState, pid: str, reachable: Set[str]) -> float:
    pressure = 0.0
    for hex_id in reachable:
        hx = state.map.hexes.get(hex_id)
        if hx is None:
            continue
        for neighbor_id in (hx.neighbors or {}).values():
            if neighbor_id not in state.map.hexes:
                continue
            neighbor = state.map.hexes[neighbor_id]
            friendly, enemy = _presence_counts(state, neighbor, pid)
            if enemy > 0 and friendly <= enemy:
                pressure += enemy
    return pressure


def _presence_counts(state: GameState, hex_obj: Optional[GameHex], pid: str) -> Tuple[int, int]:
    if not hex_obj:
        return (0, 0)
    try:
        from .alliances import ship_presence

        return ship_presence(state, hex_obj, pid)
    except Exception:
        friendly = 0
        enemy = int(getattr(hex_obj, "ancients", 0) or 0)
        pieces_map = getattr(hex_obj, "pieces", None)
        if isinstance(pieces_map, dict):
            for owner, pieces in pieces_map.items():
                ships = getattr(pieces, "ships", {}) or {}
                strength = sum(int(v or 0) for v in ships.values()) + int(getattr(pieces, "starbase", 0) or 0)
                if owner == pid:
                    friendly += strength
                else:
                    enemy += strength
        return (friendly, enemy)


__all__ = ["explore_ev"]

===== FILE: eclipse_ai/game_models.py =====

from __future__ import annotations
import sys
from dataclasses import dataclass, field, asdict, is_dataclass, fields
from typing import Dict, List, Optional, Tuple, Any, Set, Literal, get_args, get_origin, get_type_hints
from enum import Enum
import json
from .types import ShipDesign

def _build_dataclass(cls, data: Dict[str, Any]):
    """Recursively coerce nested dicts/lists into a dataclass instance."""
    if not is_dataclass(cls):
        return data
    type_hints = get_type_hints(cls, globalns=sys.modules[cls.__module__].__dict__)
    kwargs = {}
    for f in fields(cls):
        if f.name not in data:
            continue  # keep default
        v = data[f.name]
        ft = type_hints.get(f.name, f.type)
        origin = get_origin(ft)

        if v is None:
            # Treat nulls for dataclass/container fields as "use the default".
            # Many callers omit nested structures entirely and some serializers
            # explicitly emit `null`; in those cases we still want the default
            # dataclass/list/dict instance instead of propagating ``None`` and
            # breaking attribute access later on (e.g. PlayerState.resources
            # should remain a Resources dataclass). Only fall back to the
            # default when the target type is a dataclass or collection; simple
            # Optional scalars should still honour the explicit ``None``.
            union_args = get_args(ft) if origin is not None else ()
            if is_dataclass(ft) or origin in (list, dict) or any(
                is_dataclass(arg) for arg in union_args if arg is not type(None)
            ):
                continue

        if is_dataclass(ft) and isinstance(v, dict):
            kwargs[f.name] = _build_dataclass(ft, v)
        elif origin in (list, set, tuple) and isinstance(v, (list, set, tuple)):
            (inner,) = get_args(ft) or (Any,)
            if inner and is_dataclass(inner):
                items = [_build_dataclass(inner, x) if isinstance(x, dict) else x for x in v]
            else:
                items = list(v)
            if origin is set:
                kwargs[f.name] = set(items)
            elif origin is tuple:
                kwargs[f.name] = tuple(items)
            else:
                kwargs[f.name] = items
        elif origin is dict and isinstance(v, dict):
            kt, vt = get_args(ft) or (Any, Any)
            if vt and is_dataclass(vt):
                kwargs[f.name] = {k: _build_dataclass(vt, x) if isinstance(x, dict) else x for k, x in v.items()}
            else:
                kwargs[f.name] = v
        else:
            kwargs[f.name] = v
    return cls(**kwargs)

def _deep_override(obj: Any, updates: Any) -> Any:
    """Shallow replace for lists, recursive merge for dicts/dataclasses."""
    if updates is None:
        return obj
    if is_dataclass(obj):
        for k, v in updates.items():
            cur = getattr(obj, k, None)
            setattr(obj, k, _deep_override(cur, v))
        return obj
    if isinstance(obj, dict) and isinstance(updates, dict):
        for k, v in updates.items():
            obj[k] = _deep_override(obj.get(k), v)
        return obj
    # lists and scalars get replaced entirely
    return updates


class ActionType(str, Enum):
    EXPLORE = "Explore"
    MOVE = "Move"
    BUILD = "Build"
    UPGRADE = "Upgrade"
    INFLUENCE = "Influence"
    RESEARCH = "Research"
    DIPLOMACY = "Diplomacy"
    PASS = "Pass"
    REACTION = "Reaction"


@dataclass
class Disc:
    id: str
    extra: bool = False


def _default_population() -> Dict[str, int]:
    return {"yellow": 0, "blue": 0, "brown": 0}


def _default_action_spaces() -> Dict[str, List[Disc]]:
    return {
        "explore": [],
        "influence": [],
        "research": [],
        "upgrade": [],
        "build": [],
        "move": [],
        "reaction": [],
    }


@dataclass
class ColonyShips:
    face_up: Dict[str, int] = field(
        default_factory=lambda: {"yellow": 0, "blue": 0, "brown": 0, "wild": 0}
    )
    face_down: Dict[str, int] = field(
        default_factory=lambda: {"yellow": 0, "blue": 0, "brown": 0, "wild": 0}
    )

@dataclass
class Resources:
    money: int = 0
    science: int = 0
    materials: int = 0



@dataclass
class ShipDesign:
    computer: int = 0
    shield: int = 0
    initiative: int = 0
    hull: int = 1
    cannons: int = 0
    missiles: int = 0
    drive: int = 0  # legacy single-drive field kept for backward compatibility
    drives: int = 0
    has_jump_drive: bool = False
    interceptor_bays: int = 0
    def movement_value(self) -> int:
        """Return the total movement points provided by installed drives."""
        return max(0, int(self.drives if self.drives else self.drive))


@dataclass
class Pieces:
    ships: Dict[str, int] = field(default_factory=dict)  # class -> count
    starbase: int = 0
    discs: int = 0
    cubes: Dict[str, int] = field(default_factory=dict)  # y/b/p -> ints
    discovery: int = 0

@dataclass
class Planet:
    type: str  # "yellow" money, "blue" science, "brown" materials, "wild", etc.
    colonized_by: Optional[str] = None

@dataclass
class Hex:
    id: str
    ring: int
    wormholes: List[int] = field(default_factory=list)  # 0..5 edges present
    neighbors: Dict[int, str] = field(default_factory=dict)  # edge -> neighbor hex id
    planets: List[Planet] = field(default_factory=list)
    pieces: Dict[str, Pieces] = field(default_factory=dict)  # player_id -> Pieces
    ancients: int = 0
    monolith: bool = False
    orbital: bool = False
    anomaly: bool = False
    explored: bool = True
    has_warp_portal: bool = False
    has_deep_warp_portal: bool = False
    is_warp_nexus: bool = False
    has_gcds: bool = False

@dataclass
class TechDisplay:
    available: List[str] = field(default_factory=list)
    tier_counts: Dict[str, int] = field(default_factory=lambda: {"I":0,"II":0,"III":0})

Effect = Dict[str, Any]


@dataclass
class Tech:
    id: str
    name: str
    category: Literal["military", "grid", "nano", "quantum", "rare", "biotech", "economy"]
    base_cost: int
    is_rare: bool = False
    cost_range: Tuple[int, int] = (0, 0)
    grants_parts: List[str] = field(default_factory=list)
    grants_structures: List[str] = field(default_factory=list)
    immediate_effect: Optional[Effect] = None


@dataclass
class PlayerState:
    player_id: str
    color: str
    resources: Resources = field(default_factory=Resources)
    income: Resources = field(default_factory=Resources)
    ship_designs: Dict[str, ShipDesign] = field(default_factory=dict)  # interceptor, cruiser, dreadnought, starbase
    reputation: List[int] = field(default_factory=list)
    diplomacy: Dict[str, str] = field(default_factory=dict)
    ambassadors: Dict[str, bool] = field(default_factory=dict)
    has_traitor: bool = False
    alliance_id: Optional[str] = None
    alliance_tile: Optional[Literal["+2", "-3"]] = None
    known_techs: List[str] = field(default_factory=list)
    owned_tech_ids: Set[str] = field(default_factory=set)
    tech_count_by_category: Dict[str, int] = field(default_factory=dict)
    science: int = 0
    influence_discs: int = 0
    unlocked_parts: Set[str] = field(default_factory=set)
    unlocked_structures: Set[str] = field(default_factory=set)
    available_components: Dict[str, int] = field(default_factory=dict)
    species_id: Optional[str] = None
    species_flags: Dict[str, Any] = field(default_factory=dict)
    action_overrides: Dict[str, Any] = field(default_factory=dict)
    build_overrides: Dict[str, Any] = field(default_factory=dict)
    move_overrides: Dict[str, Any] = field(default_factory=dict)
    explore_overrides: Dict[str, Any] = field(default_factory=dict)
    cannot_build: Set[str] = field(default_factory=set)
    vp_bonuses: Dict[str, Any] = field(default_factory=dict)
    species_pools: Dict[str, Any] = field(default_factory=dict)
    special_resources: Dict[str, int] = field(default_factory=dict)
    influence_track: List[Disc] = field(default_factory=list)
    action_spaces: Dict[str, List[Disc]] = field(default_factory=_default_action_spaces)
    colonies: Dict[str, Dict[str, int]] = field(default_factory=dict)
    population: Dict[str, int] = field(default_factory=_default_population)
    colony_ships: ColonyShips = field(default_factory=ColonyShips)
    passed: bool = False
    collapsed: bool = False
    has_wormhole_generator: bool = False


@dataclass
class Alliance:
    id: str
    members: List[str] = field(default_factory=list)
    founded: bool = False
    betrayers: Set[str] = field(default_factory=set)


@dataclass
class MapState:
    hexes: Dict[str, Hex] = field(default_factory=dict)
    adjacency: Dict[str, List[str]] = field(default_factory=dict)


@dataclass
class GameState:
    round: int = 1
    active_player: str = "you"
    phase: str = "action"
    players: Dict[str, PlayerState] = field(default_factory=dict)
    map: MapState = field(default_factory=MapState)
    tech_display: TechDisplay = field(default_factory=TechDisplay)
    bags: Dict[str, Dict[str, int]] = field(default_factory=dict)  # bag per ring: tile_type -> count
    tech_bags: Dict[str, List[str]] = field(default_factory=dict)
    market: List[str] = field(default_factory=list)
    tech_definitions: Dict[str, Tech] = field(default_factory=dict)
    phase: str = "ACTION"
    starting_player: Optional[str] = None
    pending_starting_player: Optional[str] = None
    turn_order: List[str] = field(default_factory=list)
    turn_index: int = 0
    feature_flags: Dict[str, bool] = field(default_factory=dict)
    alliances: Dict[str, Alliance] = field(default_factory=dict)
    reactions_active: Dict[str, bool] = field(default_factory=dict)
    connectivity_metrics: Dict[str, Dict[str, Any]] = field(default_factory=dict)
    possible_actions: Set[ActionType] = field(default_factory=set)
    can_explore: bool = True
    can_move_ships: bool = False

    def to_json(self) -> str:
        def _normalize(value: Any) -> Any:
            if isinstance(value, set):
                return sorted(value)
            if isinstance(value, dict):
                return {k: _normalize(v) for k, v in value.items()}
            if isinstance(value, list):
                return [_normalize(v) for v in value]
            return value

        return json.dumps(_normalize(asdict(self)), indent=2)

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "GameState":
        return _build_dataclass(cls, data)
    def apply_overrides(self, overrides: Dict[str, Any]) -> "GameState":
        _deep_override(self, overrides)
        return self


@dataclass
class Action:
    type: ActionType
    payload: Dict[str, Any] = field(default_factory=dict)

@dataclass
class Score:
    expected_vp: float
    risk: float
    details: Dict[str, Any] = field(default_factory=dict)

===== FILE: eclipse_ai/image_ingestion.py =====

from __future__ import annotations
from dataclasses import dataclass, field
from typing import Dict, Any, Optional, List, Tuple
import os

# Optional deps
try:
    import cv2  # type: ignore
    import numpy as np  # type: ignore
except Exception:  # pragma: no cover
    cv2 = None  # type: ignore
    np = None   # type: ignore

try:
    from PIL import Image, ExifTags  # type: ignore
except Exception:  # pragma: no cover
    Image = None  # type: ignore
    ExifTags = None  # type: ignore

@dataclass
class CalibratedImage:
    path: str
    metadata: Dict[str, Any] = field(default_factory=dict)

@dataclass
class CalibrationConfig:
    save_rectified: bool = True
    save_suffix: str = ".rectified.png"
    rings_guess: int = 3  # for grid_hint estimation
    use_aruco: bool = True
    aruco_dict: str = "DICT_4X4_50"  # used if OpenCV contrib available
    # Lighting normalization
    normalize_lighting: bool = True
    # White balance: simple gray-world gain
    white_balance: bool = True

def load_and_calibrate(image_path: str, fiducials: Optional[List[Tuple[float, float]]]=None, config: Optional[CalibrationConfig]=None) -> CalibratedImage:
    """
    Load an image, correct EXIF orientation, optionally normalize lighting and color,
    and rectify perspective using provided fiducials or detected board corners.
    Returns a CalibratedImage with metadata including a 'grid_hint' for hex projection.

    Parameters
    ----------
    image_path: str
        Path to the board photo.
    fiducials: list of (x,y)
        Optional four corner points in pixels. Any order; will be sorted to TL, TR, BR, BL.
    config: CalibrationConfig
        Tuning switches. Defaults are conservative.

    Metadata Keys
    -------------
    - rectified: bool
    - rectification_method: "fiducials"|"aruco"|"contour"|"none"
    - homography: 3x3 list (if rectified)
    - size: (height,width)
    - lighting_normalized: bool
    - white_balance: bool
    - grid_hint: {"origin":(x,y),"q_vec":(dx,dy),"r_vec":(dx,dy),"rings":int}
    - warnings: [str]
    """
    cfg = config or CalibrationConfig()
    meta: Dict[str, Any] = {
        "rectified": False,
        "rectification_method": "none",
        "lighting_normalized": False,
        "white_balance": False,
        "homography": None,
        "size": None,
        "grid_hint": None,
        "warnings": [],
        "notes": "",
    }

    # Fast path: if OpenCV missing, return stub with size from PIL if available
    if cv2 is None or np is None:
        meta["notes"] = "OpenCV not available; returning unmodified image."
        if Image is not None:
            try:
                with Image.open(image_path) as im:
                    meta["size"] = (im.height, im.width)
            except Exception:
                pass
        meta["grid_hint"] = _guess_grid_hint(meta.get("size"), cfg.rings_guess)
        return CalibratedImage(path=image_path, metadata=meta)

    # Read with EXIF orientation fix if possible
    img = _read_image_exif_corrected(image_path)
    if img is None:
        meta["warnings"].append("Failed to read image; returning stub.")
        return CalibratedImage(path=image_path, metadata=meta)

    meta["size"] = (img.shape[0], img.shape[1])

    # White balance
    if cfg.white_balance:
        img, gains = _gray_world_white_balance(img)
        meta["white_balance"] = True
        meta["wb_gains"] = gains

    # Lighting normalization
    if cfg.normalize_lighting:
        img = _clahe_normalize(img)
        meta["lighting_normalized"] = True

    # Rectification
    rectified_img = None
    H = None
    if fiducials and len(fiducials) >= 4:
        corners = _order_corners(np.array(fiducials, dtype=np.float32))
        rectified_img, H = _warp_to_rect(img, corners)
        meta["rectified"] = True
        meta["rectification_method"] = "fiducials"
    elif cfg.use_aruco and _aruco_available():
        try:
            detected = _detect_aruco_board_corners(img, cfg.aruco_dict)
            if detected is not None:
                corners = _order_corners(detected)
                rectified_img, H = _warp_to_rect(img, corners)
                meta["rectified"] = True
                meta["rectification_method"] = "aruco"
        except Exception as e:  # pragma: no cover
            meta["warnings"].append(f"ArUco detection failed: {e}")
    if rectified_img is None:
        # Fallback: find largest quadrilateral contour
        quad = _largest_quad_contour(img)
        if quad is not None:
            corners = _order_corners(quad)
            rectified_img, H = _warp_to_rect(img, corners)
            meta["rectified"] = True
            meta["rectification_method"] = "contour"

    # Save rectified image if produced
    out_path = image_path
    if rectified_img is not None and cfg.save_rectified:
        base, ext = os.path.splitext(image_path)
        out_path = base + cfg.save_suffix
        cv2.imwrite(out_path, rectified_img)
        img = rectified_img  # downstream size uses rectified
        meta["size"] = (img.shape[0], img.shape[1])

    # Homography metadata
    if H is not None:
        meta["homography"] = H.tolist()

    # Grid hint estimation
    meta["grid_hint"] = _guess_grid_hint(meta["size"], cfg.rings_guess)

    return CalibratedImage(path=out_path, metadata=meta)

# ------------------------
# Helpers
# ------------------------

def _read_image_exif_corrected(path: str):
    """Read image and correct EXIF orientation if PIL available."""
    if Image is None:
        return cv2.imread(path, cv2.IMREAD_COLOR)
    try:
        with Image.open(path) as im:
            try:
                exif = im._getexif()
                if exif and ExifTags:
                    orientation_key = next((k for k, v in ExifTags.TAGS.items() if v == 'Orientation'), None)
                    if orientation_key and orientation_key in exif:
                        o = exif[orientation_key]
                        if o == 3:
                            im = im.rotate(180, expand=True)
                        elif o == 6:
                            im = im.rotate(270, expand=True)
                        elif o == 8:
                            im = im.rotate(90, expand=True)
            except Exception:
                pass
            # Convert to BGR for OpenCV
            im = im.convert('RGB')
            arr = np.array(im)[:, :, ::-1].copy()
            return arr
    except Exception:
        # Fallback to OpenCV read
        return cv2.imread(path, cv2.IMREAD_COLOR)

def _gray_world_white_balance(img):
    """Simple gray-world white balance. Returns corrected image and gains."""
    eps = 1e-6
    b, g, r = cv2.split(img)
    mb, mg, mr = float(b.mean()), float(g.mean()), float(r.mean())
    avg = (mb + mg + mr) / 3.0 + eps
    gb, gg, gr = avg / (mb + eps), avg / (mg + eps), avg / (mr + eps)
    b = cv2.multiply(b, gb)
    g = cv2.multiply(g, gg)
    r = cv2.multiply(r, gr)
    out = cv2.merge([np.clip(b,0,255).astype(np.uint8),
                     np.clip(g,0,255).astype(np.uint8),
                     np.clip(r,0,255).astype(np.uint8)])
    return out, (gb, gg, gr)

def _clahe_normalize(img):
    """Apply CLAHE to L channel in LAB space for local contrast normalization."""
    lab = cv2.cvtColor(img, cv2.COLOR_BGR2LAB)
    l, a, b = cv2.split(lab)
    clahe = cv2.createCLAHE(clipLimit=2.0, tileGridSize=(8,8))
    l2 = clahe.apply(l)
    lab2 = cv2.merge([l2, a, b])
    return cv2.cvtColor(lab2, cv2.COLOR_LAB2BGR)

def _order_corners(pts: 'np.ndarray') -> 'np.ndarray':
    """Return 4x2 array ordered TL, TR, BR, BL from arbitrary four-point set."""
    if pts.shape[0] > 4:
        # take convex hull then choose 4 extreme points
        hull = cv2.convexHull(pts.reshape(-1,1,2))
        pts = hull.reshape(-1,2)
    # If still >4, select by k-means or extreme sums; here: extreme sums
    if pts.shape[0] != 4:
        sums = pts.sum(axis=1)
        diffs = (pts[:,0] - pts[:,1])
        tl = pts[np.argmin(sums)]
        br = pts[np.argmax(sums)]
        tr = pts[np.argmin(diffs)]
        bl = pts[np.argmax(diffs)]
        return np.array([tl, tr, br, bl], dtype=np.float32)
    # classic ordering
    s = pts.sum(axis=1)
    diff = (pts[:,0] - pts[:,1])
    tl = pts[np.argmin(s)]
    br = pts[np.argmax(s)]
    tr = pts[np.argmin(diff)]
    bl = pts[np.argmax(diff)]
    return np.array([tl, tr, br, bl], dtype=np.float32)

def _warp_to_rect(img, corners: 'np.ndarray'):
    """Perspective warp so that the quad maps to a rectangle with aspect proportional to input quad."""
    # compute width and height from distances
    (tl, tr, br, bl) = corners
    def d(a,b): return np.linalg.norm(a-b)
    width = int(max(d(tr, tl), d(br, bl)))
    height = int(max(d(bl, tl), d(br, tr)))
    width = max(1, width)
    height = max(1, height)
    dst = np.array([[0,0],[width-1,0],[width-1,height-1],[0,height-1]], dtype=np.float32)
    H = cv2.getPerspectiveTransform(corners.astype(np.float32), dst)
    rectified = cv2.warpPerspective(img, H, (width, height), flags=cv2.INTER_LINEAR)
    return rectified, H

def _aruco_available() -> bool:
    return cv2 is not None and hasattr(cv2, "aruco")

def _detect_aruco_board_corners(img, dict_name: str = "DICT_4X4_50"):
    """Detect ArUco markers and infer outer quad from extreme marker corners if four corners exist."""
    if not _aruco_available():
        return None
    adict = getattr(cv2.aruco, dict_name, None)
    if adict is None:
        adict = cv2.aruco.getPredefinedDictionary(cv2.aruco.DICT_4X4_50)
    detector = cv2.aruco.ArucoDetector(adict, cv2.aruco.DetectorParameters())
    corners, ids, _rej = detector.detectMarkers(img)
    if ids is None or len(corners) < 1:
        return None
    # Collect all corners and take convex hull
    pts = np.concatenate([c.reshape(-1,2) for c in corners], axis=0).astype(np.float32)
    hull = cv2.convexHull(pts.reshape(-1,1,2)).reshape(-1,2)
    # Approximate hull to 4-point polygon
    peri = cv2.arcLength(hull.reshape(-1,1,2), True)
    approx = cv2.approxPolyDP(hull.reshape(-1,1,2), 0.02*peri, True).reshape(-1,2)
    if approx.shape[0] >= 4:
        return approx[:4].astype(np.float32)
    return hull[:4].astype(np.float32) if hull.shape[0] >= 4 else None

def _largest_quad_contour(img):
    """Find largest quadrilateral contour using Canny + contour approximation."""
    gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
    blur = cv2.GaussianBlur(gray, (5,5), 0)
    edges = cv2.Canny(blur, 50, 150)
    # Dilate to close gaps
    kernel = np.ones((3,3), np.uint8)
    edges = cv2.dilate(edges, kernel, iterations=1)
    cnts, _ = cv2.findContours(edges, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
    best = None
    best_area = 0
    for c in cnts:
        area = cv2.contourArea(c)
        if area < 10000:  # ignore tiny contours
            continue
        peri = cv2.arcLength(c, True)
        approx = cv2.approxPolyDP(c, 0.02*peri, True)
        if len(approx) == 4 and area > best_area:
            best = approx.reshape(-1,2)
            best_area = area
    return best

def _guess_grid_hint(size: Optional[Tuple[int,int]], rings: int) -> Dict[str, Any]:
    """Estimate a hex axial grid hint compatible with board_parser._grid_from_meta."""
    if not size:
        return {"origin": (0.0, 0.0), "q_vec": (80.0, 0.0), "r_vec": (40.0, 70.0), "rings": rings}
    h, w = size
    scale = max(40.0, min(w, h) / 10.0)
    origin = (w/2.0, h/2.0)
    q_vec = (scale, 0.0)
    r_vec = (scale*0.5, scale*0.866)  # 60 degrees
    return {"origin": origin, "q_vec": q_vec, "r_vec": r_vec, "rings": rings}

===== FILE: eclipse_ai/influence.py =====

from __future__ import annotations

from typing import Dict

from .explore import ExploreState
from .map.hex import MapGraph
from .pathing import valid_edge


def place_influence_disc(state: ExploreState, player_id: str, hex_id: str) -> None:
    hex_obj = state.map.hexes[hex_id]
    if hex_obj.ancients > 0:
        raise ValueError("Cannot take control while Ancients remain on the hex")
    if hex_obj.gcds:
        raise ValueError("Galactic Center Defense System must be destroyed before control")
    for owner, count in (hex_obj.ships or {}).items():
        if owner != player_id and int(count or 0) > 0:
            raise ValueError("Cannot Influence a hex containing enemy ships")
    hex_obj.owner = player_id


def _flags(state_or_flags) -> Dict[str, bool]:
    if isinstance(state_or_flags, ExploreState):
        return state_or_flags.feature_flags
    return dict(state_or_flags or {})


def connection_allows_influence(map_state: MapGraph, a: str, b: str, *, feature_flags=None, player_has_wg: bool = False) -> bool:
    flags = _flags(feature_flags)
    return valid_edge(
        map_state,
        a,
        b,
        feature_flags=flags,
        player_has_wormhole_generator=player_has_wg,
    )


def connection_allows_diplomacy(map_state: MapGraph, a: str, b: str, *, feature_flags=None) -> bool:
    flags = _flags(feature_flags)
    return valid_edge(map_state, a, b, feature_flags=flags)


def _both_have_portals(map_state: MapGraph, a: str, b: str) -> bool:
    hex_a = map_state.hexes.get(a)
    hex_b = map_state.hexes.get(b)
    if not hex_a or not hex_b:
        return False
    return bool(getattr(hex_a, "warp_portal", False) and getattr(hex_b, "warp_portal", False))

===== FILE: eclipse_ai/main.py =====

from __future__ import annotations
from typing import Optional, Dict, Any, List, Union
import json
from . import state_assembler, board_parser, tech_parser, image_ingestion, rules_engine, evaluator  # keep existing imports; note: image_injestion file name
from .image_ingestion import load_and_calibrate
from .board_parser import parse_board
from .tech_parser import parse_tech
from .state_assembler import assemble_state
from .search_policy import MCTSPlanner, Plan, PlanStep
from .game_models import GameState
from .uncertainty import BeliefState
from .overlay import plan_overlays

# -----------------------------
# Helpers
# -----------------------------

def _signals_from_tech(name: str) -> List[str]:
    s = name.lower()
    sigs: List[str] = []
    if "plasma" in s: sigs.append("plasma")
    if "positron" in s: sigs.append("positron")
    if "fusion" in s or "drive" in s: sigs.append("drive")
    if "gauss" in s: sigs.append("gauss")
    if "shield" in s: sigs.append("shields")
    if "missile" in s: sigs.append("missiles")
    return sigs

def _enemy_posteriors_all(belief: BeliefState, rho: float = 0.9) -> Dict[str, Dict[str, float]]:
    out: Dict[str, Dict[str, float]] = {}
    for pid in belief.hmm_by_player.keys() | belief.obs_history_by_player.keys():
        out[pid] = belief.enemy_posterior(pid, rho=rho)
    return out

# -----------------------------
# Public API
# -----------------------------

def recommend(
    board_image_path: Optional[str],
    tech_image_path: Optional[str],
    prior_state: Optional[Union[GameState, Dict[str, Any]]] = None,
    manual_inputs: Optional[Dict[str, Any]] = None,
    top_k: int = 5
) -> Dict[str, Any]:
    """Main orchestration. Returns top plans, overlays, and belief summaries."""
    # 1) Build/assemble state
    board_img = tech_img = None
    if prior_state is not None:
        state = prior_state if isinstance(prior_state, GameState) else state_assembler.from_dict(prior_state)
    else:
        board_img = load_and_calibrate(board_image_path) if board_image_path else None
        tech_img = load_and_calibrate(tech_image_path) if tech_image_path else None
        map_state = parse_board(board_img) if board_img is not None else None
        tech_disp = parse_tech(tech_img) if tech_img is not None else None
        state = assemble_state(map_state, tech_disp, None, None)

    # 2) Apply targeted overrides (resources, bags, belief hints, planner cfg passthrough, etc.)
    if manual_inputs:
        state = state_assembler.apply_overrides(state, dict(manual_inputs))  # copy to avoid caller mutation

    # 3) Belief state: restore or initialize
    belief_dict = (manual_inputs or {}).get("belief_state") or (manual_inputs or {}).get("belief")
    belief = BeliefState.from_dict(belief_dict) if isinstance(belief_dict, dict) else BeliefState()

    # Ensure particle filters for each bag
    for bag_id, bag in getattr(state, "bags", {}).items():
        belief.ensure_bag(bag_id, bag, particles=512)

    # Observe tech signals for enemies
    for pid, p in (getattr(state, "players", {}) or {}).items():
        if pid == "you":
            continue
        for tech in getattr(p, "known_techs", []):
            for sig in _signals_from_tech(tech):
                belief.observe_enemy_signal(pid, sig)

    if "blue" in (getattr(state, "players", {}) or {}):
        for tech in getattr(state.tech_display, "available", []):
            for sig in _signals_from_tech(tech):
                belief.observe_enemy_signal("blue", sig)

    # 4) Plan
    planner_args = (manual_inputs or {}).get("_planner", {})
    simulations = int(planner_args.get("simulations", 400))
    depth = int(planner_args.get("depth", 2))
    risk_aversion = float(planner_args.get("risk_aversion", 0.25))

    planner = MCTSPlanner(simulations=simulations, risk_aversion=risk_aversion)
    plans = planner.plan(state, state.active_player, depth=depth, top_k=top_k)

    # 5) Package results
    out_plans: List[Dict[str, Any]] = []
    for p in plans:
        steps = [{"action": s.action.type.value, "payload": s.action.payload, "score": float(s.score.expected_vp), "risk": float(s.score.risk)} for s in p.steps]
        out_plans.append({
            "score": float(p.total_score),
            "risk": float(p.risk),
            "steps": steps,
            "state_summary": dict(p.state_summary),
            "overlays": plan_overlays(p)
        })

    enemy_posts = _enemy_posteriors_all(belief, rho=float((manual_inputs or {}).get("belief_rho", 0.9)))

    return {
        "round": state.round,
        "active_player": state.active_player,
        "plans": out_plans,
        "belief": belief.to_dict(include_particles=False),
        "enemy_posteriors": enemy_posts,
        "expected_bags": {bid: belief.expected_bag(bid) for bid in getattr(state, "bags", {}).keys()},
        "board_meta": getattr(board_img, "metadata", None),
        "tech_meta": getattr(tech_img, "metadata", None),
    }
===== FILE: eclipse_ai/map/__init__.py =====

"""Map data structures for Eclipse hex tiles and adjacency logic."""

from .hex import Hex, MapGraph
from .decks import HexTile, SectorDeck, DiscoveryDeck, ExplorationDecks, DiscoveryTile

__all__ = [
    "Hex",
    "MapGraph",
    "HexTile",
    "SectorDeck",
    "DiscoveryDeck",
    "ExplorationDecks",
    "DiscoveryTile",
]

===== FILE: eclipse_ai/map/connectivity.py =====

"""Connectivity helpers for wormhole and adjacency checks."""
from __future__ import annotations

from typing import Optional

from ..game_models import MapState, Hex


def is_neighbor(map_state: Optional[MapState], a: str, b: str) -> bool:
    """Return ``True`` when two hexes share an edge on the map."""
    if not map_state or not map_state.hexes:
        return False
    hx_a = map_state.hexes.get(a)
    hx_b = map_state.hexes.get(b)
    if hx_a is None or hx_b is None:
        return False
    if b in hx_a.neighbors.values():
        return True
    if a in hx_b.neighbors.values():
        return True
    return False


def has_full_wormhole(map_state: Optional[MapState], src_id: str, dst_id: str) -> bool:
    """Return ``True`` when both edges of an adjacency contain wormholes."""
    if not map_state or not map_state.hexes:
        return False
    if src_id == dst_id:
        return True
    src_hex = map_state.hexes.get(src_id)
    dst_hex = map_state.hexes.get(dst_id)
    if src_hex is None or dst_hex is None:
        return False
    if not is_neighbor(map_state, src_id, dst_id):
        return False
    src_edges = _edges_to_neighbor(src_hex, dst_id)
    if not src_edges:
        return False
    dst_edges = _edges_to_neighbor(dst_hex, src_id)
    if not dst_edges:
        return False
    return any(edge in src_hex.wormholes for edge in src_edges) and any(
        edge in dst_hex.wormholes for edge in dst_edges
    )


def _edges_to_neighbor(hex_obj: Hex, neighbor_id: str) -> list[int]:
    return [edge for edge, nid in hex_obj.neighbors.items() if nid == neighbor_id]


def has_half_wormhole(map_state: Optional[MapState], src_id: str, dst_id: str) -> bool:
    """Return ``True`` when either side of an adjacency has a wormhole."""
    if not map_state or not map_state.hexes:
        return False
    if src_id == dst_id:
        return True
    src_hex = map_state.hexes.get(src_id)
    dst_hex = map_state.hexes.get(dst_id)
    if src_hex is None or dst_hex is None:
        return False
    if not is_neighbor(map_state, src_id, dst_id):
        return False
    src_edges = _edges_to_neighbor(src_hex, dst_id)
    dst_edges = _edges_to_neighbor(dst_hex, src_id)
    has_src = any(edge in src_hex.wormholes for edge in src_edges)
    has_dst = any(edge in dst_hex.wormholes for edge in dst_edges)
    return has_src or has_dst


__all__ = ["is_neighbor", "has_full_wormhole", "has_half_wormhole"]

===== FILE: eclipse_ai/map/decks.py =====

from __future__ import annotations

import random
from dataclasses import dataclass, field
from typing import Dict, List, Optional, Sequence


@dataclass
class HexTile:
    """Prototype for an unexplored hex tile."""

    id: str
    ring: int
    wormholes: Sequence[int]
    symbols: Sequence[str] = field(default_factory=tuple)
    warp_portal: bool = False
    gcds: bool = False


@dataclass
class DiscoveryTile:
    """Representation of a discovery tile."""

    id: str
    effect: str
    amount: int = 0

    def apply(self, player: "PlayerProtocol") -> None:
        """Execute the immediate effect of the tile on ``player``."""

        if self.effect == "money":
            player.resources.money += self.amount
        elif self.effect == "science":
            player.resources.science += self.amount
        elif self.effect == "materials":
            player.resources.materials += self.amount
        elif self.effect == "ancient_tech":
            player.ancient_tech += 1
        elif self.effect == "ancient_cruiser":
            player.ancient_cruisers += 1
        elif self.effect == "ancient_part":
            player.ancient_parts += 1
        else:
            raise ValueError(f"Unknown discovery effect: {self.effect}")


class PlayerProtocol:
    resources: "ResourcePool"
    ancient_tech: int
    ancient_cruisers: int
    ancient_parts: int


@dataclass
class ResourcePool:
    money: int = 0
    science: int = 0
    materials: int = 0


@dataclass
class _DeckBase:
    draw_pile: List
    discard_pile: List = field(default_factory=list)
    rng: random.Random = field(default_factory=random.Random)

    def draw(self):
        if not self.draw_pile:
            self._reshuffle_from_discards()
        if not self.draw_pile:
            raise RuntimeError("Deck is empty and no discards are available")
        return self.draw_pile.pop()

    def discard(self, item) -> None:
        self.discard_pile.append(item)

    def _reshuffle_from_discards(self) -> None:
        if not self.discard_pile:
            return
        self.draw_pile = list(self.discard_pile)
        self.discard_pile.clear()
        self.rng.shuffle(self.draw_pile)


@dataclass
class SectorDeck(_DeckBase):
    """Sector stack for a given ring."""

    ring: int = 1

    def __init__(self, *, ring: int, tiles: Optional[Sequence[HexTile]] = None, rng: Optional[random.Random] = None):
        tiles = list(tiles or [])
        rng = rng or random.Random()
        super().__init__(draw_pile=list(tiles), discard_pile=[], rng=rng)
        self.ring = ring


@dataclass
class DiscoveryDeck(_DeckBase):
    """Stack for discovery tiles."""

    def __init__(self, *, tiles: Optional[Sequence[DiscoveryTile]] = None, rng: Optional[random.Random] = None):
        tiles = list(tiles or [])
        rng = rng or random.Random()
        super().__init__(draw_pile=list(tiles), discard_pile=[], rng=rng)


@dataclass
class ExplorationDecks:
    sectors: Dict[int, SectorDeck]
    discovery: DiscoveryDeck

    def get_sector(self, ring: int) -> SectorDeck:
        try:
            return self.sectors[ring]
        except KeyError as exc:
            raise KeyError(f"No sector deck for ring {ring}") from exc

===== FILE: eclipse_ai/map/hex.py =====

from __future__ import annotations

from dataclasses import dataclass, field
from typing import Dict, Iterable, List, Optional, Sequence, Tuple

from .decks import HexTile, DiscoveryTile


def rotate_edge(edge: int, orient: int) -> int:
    return (edge + orient) % 6


def opposite_edge(edge: int) -> int:
    return (edge + 3) % 6


def rotated_wormholes(tile: HexTile, orient: int) -> Tuple[int, ...]:
    return tuple(sorted(rotate_edge(edge, orient) for edge in tile.wormholes))


@dataclass
class Hex:
    id: str
    ring: int
    wormholes: Tuple[int, ...]
    symbols: Tuple[str, ...] = tuple()
    warp_portal: bool = False
    gcds: bool = False
    neighbors: Dict[int, str] = field(default_factory=dict)
    owner: Optional[str] = None
    ships: Dict[str, int] = field(default_factory=dict)
    ancients: int = 0
    discovery_tile: Optional[DiscoveryTile] = None

    def has_wormhole(self, edge: int) -> bool:
        return edge in self.wormholes

    def has_presence(self, player_id: str) -> bool:
        return self.owner == player_id or self.ships.get(player_id, 0) > 0


@dataclass
class MapGraph:
    hexes: Dict[str, Hex] = field(default_factory=dict)
    explored_choice: Dict[str, str] = field(default_factory=dict)
    pending_edges: Dict[str, Dict[int, Tuple[str, int]]] = field(default_factory=dict)

    def add_hex(self, hex_obj: Hex) -> None:
        self.hexes[hex_obj.id] = hex_obj

    def register_exploration_target(self, *, origin: str, edge: int, target: str) -> None:
        origin_hex = self.hexes[origin]
        origin_hex.neighbors[edge] = target
        new_edge = opposite_edge(edge)
        self.pending_edges.setdefault(target, {})[new_edge] = (origin, edge)

    def set_choice(self, player_id: str, target: str) -> None:
        if target not in self.pending_edges:
            raise ValueError(f"No unexplored space recorded at {target}")
        self.explored_choice[player_id] = target

    def clear_choice(self, player_id: str) -> None:
        self.explored_choice.pop(player_id, None)

    def take_pending_edges(self, pos: str) -> Dict[int, Tuple[str, int]]:
        return self.pending_edges.pop(pos, {})

    def connection_edges(self, pos: str) -> Dict[int, Tuple[str, int]]:
        return dict(self.pending_edges.get(pos, {}))

    def neighbors(self, hex_id: str) -> Iterable[str]:
        hx = self.hexes[hex_id]
        for nb in hx.neighbors.values():
            if nb is None:
                continue
            if nb in self.hexes:
                yield nb

    def connection_type(self, a: str, b: str) -> str:
        if a == b:
            return "full"
        hex_a = self.hexes[a]
        hex_b = self.hexes[b]
        for edge, nb in hex_a.neighbors.items():
            if nb != b:
                continue
            opp = opposite_edge(edge)
            a_has = hex_a.has_wormhole(edge)
            b_has = hex_b.has_wormhole(opp)
            if a_has and b_has:
                return "full"
            if a_has or b_has:
                return "half"
        return "none"

    def ensure_neighbor_link(self, a: str, edge: int, b: str) -> None:
        self.hexes[a].neighbors[edge] = b
        self.hexes[b].neighbors[opposite_edge(edge)] = a


__all__ = [
    "Hex",
    "MapGraph",
    "rotate_edge",
    "opposite_edge",
    "rotated_wormholes",
]

===== FILE: eclipse_ai/models/player_state.py =====

"""Lightweight player state models used by the scoring helpers."""
from __future__ import annotations

from dataclasses import dataclass, field
from typing import Dict, List, Literal, Optional


@dataclass(slots=True)
class ReputationTile:
    """Representation of a kept reputation tile with its printed value."""

    value: int
    is_special: bool = False


@dataclass(slots=True)
class EvolutionTile:
    """Subset of Evolution tile data required for endgame scoring."""

    endgame_key: Optional[str] = None
    value: int = 0


AllianceSide = Literal["faceup", "+2", "betrayer", "-3", None]


@dataclass(slots=True)
class PlayerState:
    """Player view consumed by :mod:`eclipse_ai.scoring` utilities."""

    player_id: str
    reputation_kept: List[ReputationTile] = field(default_factory=list)
    ambassadors: int = 0
    controlled_hex_ids: List[str] = field(default_factory=list)
    discoveries_kept: int = 0
    monolith_count: int = 0
    tech_track_counts: Dict[str, int] = field(default_factory=dict)
    has_traitor: bool = False
    alliance_tile: AllianceSide = None
    ancient_kill_tokens: Dict[str, int] = field(
        default_factory=lambda: {"cruiser": 0, "dreadnought": 0}
    )
    evolution_tiles: List[EvolutionTile] = field(default_factory=list)
    artifacts_controlled: int = 0
    controls_galactic_center: bool = False

===== FILE: eclipse_ai/movement.py =====

"""Movement utility helpers."""
from __future__ import annotations

from typing import Iterable, Optional, Sequence

from .game_models import GameState, Hex, PlayerState, ShipDesign

_DEFAULT_MOVE_ACTIVATIONS = 3

# Movement connection categories recognised by the tactical layer.
LEGAL_CONNECTION_TYPES = {"wormhole", "warp", "wg", "jump"}


def max_ship_activations_per_action(player: Optional[PlayerState], is_reaction: bool = False) -> int:
    """Return the legal number of ship activations for a MOVE action.

    Shadows of the Rift factions from Ship Pack One may replace the default
    three activations with a stricter limit. Reactions remain capped at a single
    activation regardless of species modifiers.
    """
    if is_reaction:
        return 1
    if not player:
        return _DEFAULT_MOVE_ACTIVATIONS
    override = None
    try:
        override = player.move_overrides.get("move_ship_activations_per_action") if player.move_overrides else None
    except AttributeError:
        override = None
    if override is None:
        return _DEFAULT_MOVE_ACTIVATIONS
    try:
        return max(1, int(override))
    except (TypeError, ValueError):
        return _DEFAULT_MOVE_ACTIVATIONS


def classify_connection(
    state: GameState,
    player: Optional[PlayerState],
    src_id: str,
    dst_id: str,
    *,
    ship_design: Optional[ShipDesign] = None,
    ship_class: Optional[str] = None,
) -> Optional[str]:
    """Classify the link between two hexes for movement validation.

    Returns one of ``"wormhole"``, ``"warp"``, ``"wg"`` (wormhole generator
    half-link), ``"jump"`` (adjacent without a wormhole) or ``None`` when no
    legal connection exists.
    """

    if not state or not getattr(state, "map", None):
        return None
    if not src_id or not dst_id:
        return None
    if src_id == dst_id:
        return "wormhole"

    map_state = state.map
    src_hex = map_state.hexes.get(src_id)
    dst_hex = map_state.hexes.get(dst_id)
    if src_hex is None or dst_hex is None:
        return None

    if _is_warp_connection(src_hex, dst_hex) and _warp_network_enabled(state, player):
        return "warp"

    if _has_full_wormhole(map_state, src_id, dst_id):
        return "wormhole"

    player_has_wg = _player_has_wormhole_generator(player)
    if player_has_wg and _has_half_wormhole_for_wg(map_state, src_id, dst_id):
        return "wg"

    if _is_neighbor(map_state, src_id, dst_id):
        if _ship_has_jump_drive(player, ship_design, ship_class):
            return "jump"
        return None

    return None


def _is_neighbor(map_state: object, a: str, b: str) -> bool:
    try:
        hx_a = map_state.hexes.get(a)
        hx_b = map_state.hexes.get(b)
    except AttributeError:
        return False
    if hx_a is None or hx_b is None:
        return False
    neighbors_a = getattr(hx_a, "neighbors", {}) or {}
    neighbors_b = getattr(hx_b, "neighbors", {}) or {}
    return b in neighbors_a.values() or a in neighbors_b.values()


def _is_warp_connection(a: Hex, b: Hex) -> bool:
    return bool(getattr(a, "has_warp_portal", False) and getattr(b, "has_warp_portal", False))


def _has_full_wormhole(map_state: object, src_id: str, dst_id: str) -> bool:
    src = getattr(map_state, "hexes", {}).get(src_id)
    dst = getattr(map_state, "hexes", {}).get(dst_id)
    if src is None or dst is None:
        return False
    if not _is_neighbor(map_state, src_id, dst_id):
        return False
    src_edges = _edges_to_neighbor(src, dst_id)
    dst_edges = _edges_to_neighbor(dst, src_id)
    if not src_edges or not dst_edges:
        return False
    src_has = any(_has_wormhole(src, edge) for edge in src_edges)
    dst_has = any(_has_wormhole(dst, edge) for edge in dst_edges)
    return src_has and dst_has


def _has_half_wormhole_for_wg(map_state: object, src_id: str, dst_id: str) -> bool:
    src = getattr(map_state, "hexes", {}).get(src_id)
    dst = getattr(map_state, "hexes", {}).get(dst_id)
    if src is None or dst is None:
        return False
    if not _is_neighbor(map_state, src_id, dst_id):
        return False
    src_edges = _edges_to_neighbor(src, dst_id)
    dst_edges = _edges_to_neighbor(dst, src_id)
    src_has = any(_has_wormhole(src, edge) for edge in src_edges)
    dst_has = any(_has_wormhole(dst, edge) for edge in dst_edges)
    return src_has or dst_has


def _edges_to_neighbor(hex_obj: Hex, neighbor_id: str) -> Sequence[int]:
    neighbors = getattr(hex_obj, "neighbors", {}) or {}
    return [edge for edge, nid in neighbors.items() if nid == neighbor_id]


def _has_wormhole(hex_obj: Hex, edge: int) -> bool:
    wormholes: Iterable[int]
    if hasattr(hex_obj, "has_wormhole"):
        try:
            return bool(hex_obj.has_wormhole(edge))  # type: ignore[attr-defined]
        except Exception:
            pass
    wormholes = getattr(hex_obj, "wormholes", ()) or ()
    return edge in set(int(e) for e in wormholes)


def _player_has_wormhole_generator(player: Optional[PlayerState]) -> bool:
    if not player:
        return False
    if bool(getattr(player, "has_wormhole_generator", False)):
        return True
    known = set(str(t).lower() for t in getattr(player, "known_techs", []) or [])
    owned = set(str(t).lower() for t in getattr(player, "owned_tech_ids", []) or [])
    if "wormhole generator" in known or "wormhole_generator" in owned:
        return True
    return False


def _ship_has_jump_drive(
    player: Optional[PlayerState],
    design: Optional[ShipDesign],
    ship_class: Optional[str],
) -> bool:
    if design and getattr(design, "has_jump_drive", False):
        return True
    if not player:
        return False
    designs = getattr(player, "ship_designs", {}) or {}
    if ship_class:
        candidate = designs.get(ship_class)
        if candidate and getattr(candidate, "has_jump_drive", False):
            return True
    return any(getattr(d, "has_jump_drive", False) for d in designs.values())


def _warp_network_enabled(state: Optional[GameState], player: Optional[PlayerState]) -> bool:
    if state is None:
        return False
    flags = getattr(state, "feature_flags", {}) or {}
    if flags:
        for key in ("warp_portals", "rotA", "warp_network", "warp", "warp_portal_network"):
            if bool(flags.get(key)):
                return True
        # Explicit feature map provided without warp support -> disabled
        return False
    # Default to allowing warp if the player explicitly knows a warp tech
    if player:
        known = set(str(t).lower() for t in getattr(player, "known_techs", []) or [])
        if any("warp" in tech for tech in known):
            return True
    # No explicit feature flags: assume the standard warp network is active when portals exist
    return True


__all__ = [
    "LEGAL_CONNECTION_TYPES",
    "classify_connection",
    "max_ship_activations_per_action",
]

===== FILE: eclipse_ai/overlay.py =====

from __future__ import annotations
from typing import List, Dict, Any, Optional, Union

# Public API

def plan_overlays(plan: Any, plan_index: int = 1) -> List[Dict[str, Any]]:
    """Return vector overlays for a single plan. Supports dataclass or dict plans."""
    steps = _get_steps(plan)
    overlays: List[Dict[str, Any]] = []
    for i, step in enumerate(steps, start=1):
        aname = _action_name(step)
        payload = _payload(step)
        ev = _ev(step)
        risk = _risk(step)
        color = _risk_color(risk)
        if aname == "Move":
            frm = payload.get("from")
            to = payload.get("to") or frm
            ships = payload.get("ships", {})
            width = 1 + min(4, int(sum(ships.values()) // 2))
            overlays.append({
                "type": "arrow",
                "from": frm,
                "to": to,
                "style": {"color": color, "width": width},
                "meta": {"plan": plan_index, "step": i, "ev": ev, "risk": risk, "ships": ships},
            })
            overlays.append(_label_overlay(text=_fmt_ev(ev, risk), anchor_hex=to, plan_index=plan_index, step=i, color=color))
        elif aname == "Explore":
            ring = payload.get("ring")
            where = payload.get("direction", f"ring {ring}")
            overlays.append({
                "type": "circle",
                "hex": where,
                "style": {"color": color, "dash": True},
                "meta": {"plan": plan_index, "step": i, "ev": ev, "risk": risk, "ring": ring},
            })
            # parse exploration notes if present
            notes = _detail(step, "explore_notes")
            label = f"Explore R{ring}  " + _fmt_ev(ev, risk)
            if notes:
                tops = _top_picks_from_notes(notes)
                if tops:
                    label += f"  Top:{tops}"
            overlays.append(_label_overlay(text=label, anchor_hex=where, plan_index=plan_index, step=i, color=color))
        elif aname == "Build":
            hex_id = payload.get("hex")
            ships = payload.get("ships", {})
            starbase = payload.get("starbase", 0)
            icon = "build"
            overlays.append({
                "type": "icon",
                "hex": hex_id,
                "icon": icon,
                "style": {"color": color},
                "meta": {"plan": plan_index, "step": i, "ev": ev, "risk": risk, "ships": ships, "starbase": starbase},
            })
            desc = ", ".join(f"{k[:3]}{v}" for k,v in ships.items()) if ships else ("starbase1" if starbase else "build")
            overlays.append(_label_overlay(text=f"Build {desc}  " + _fmt_ev(ev, risk), anchor_hex=hex_id, plan_index=plan_index, step=i, color=color))
        elif aname == "Research":
            tech = payload.get("tech", "tech")
            overlays.append(_label_overlay(text=f"Research {tech}  " + _fmt_ev(ev, risk), anchor_hex=None, plan_index=plan_index, step=i, color=color))
        elif aname == "Influence":
            hex_id = payload.get("hex")
            overlays.append({
                "type": "icon",
                "hex": hex_id,
                "icon": "influence",
                "style": {"color": color},
                "meta": {"plan": plan_index, "step": i, "ev": ev, "risk": risk},
            })
            overlays.append(_label_overlay(text="Influence  " + _fmt_ev(ev, risk), anchor_hex=hex_id, plan_index=plan_index, step=i, color=color))
        elif aname == "Upgrade":
            overlays.append(_label_overlay(text="Upgrade  " + _fmt_ev(ev, risk), anchor_hex=None, plan_index=plan_index, step=i, color=color))
        elif aname == "Diplomacy":
            ally = payload.get("with", "?")
            overlays.append(_label_overlay(text=f"Diplomacy with {ally}  " + _fmt_ev(ev, risk), anchor_hex=None, plan_index=plan_index, step=i, color=color))
        elif aname == "Pass":
            overlays.append(_label_overlay(text="Pass", anchor_hex=None, plan_index=plan_index, step=i, color=color))
        else:
            overlays.append(_label_overlay(text=f"{aname}  " + _fmt_ev(ev, risk), anchor_hex=None, plan_index=plan_index, step=i, color=color))
    return overlays

def overlays_for_plans(plans: List[Any]) -> List[Dict[str, Any]]:
    """Flatten overlays for a list of plans with per-plan indexing and a legend."""
    out: List[Dict[str, Any]] = []
    for idx, plan in enumerate(plans, start=1):
        out.extend(plan_overlays(plan, plan_index=idx))
    out.append(_legend_overlay())
    return out

# Helpers

def _get_steps(plan: Any):
    # plan may be dataclass with .steps or a dict with "steps"
    if hasattr(plan, "steps"):
        return list(plan.steps)
    if isinstance(plan, dict):
        return list(plan.get("steps", []))
    return []

def _action_name(step: Any) -> str:
    # step may be dataclass with .action.type.value or dict with "action"
    try:
        return step.action.type.value  # type: ignore[attr-defined]
    except Exception:
        a = getattr(step, "action", None)
        if a and hasattr(a, "type"):
            return str(a.type)
        if isinstance(step, dict):
            return str(step.get("action", "Unknown"))
        return "Unknown"

def _payload(step: Any) -> Dict[str, Any]:
    try:
        return dict(step.action.payload)  # type: ignore[attr-defined]
    except Exception:
        if isinstance(step, dict):
            return dict(step.get("payload", {}))
        return {}

def _ev(step: Any) -> float:
    try:
        return float(step.score.expected_vp)  # type: ignore[attr-defined]
    except Exception:
        if isinstance(step, dict):
            return float(step.get("score", 0.0))
        return 0.0

def _risk(step: Any) -> float:
    # risk might be stored on score or in details; fall back
    try:
        return float(step.score.risk)  # type: ignore[attr-defined]
    except Exception:
        # try to find numeric 'risk' in step
        if isinstance(step, dict):
            d = step.get("details", {})
            if isinstance(d, dict) and "risk" in d:
                try:
                    return float(d["risk"])
                except Exception:
                    pass
        return 0.35

def _detail(step: Any, key: str) -> Optional[str]:
    try:
        return step.score.details.get(key)  # type: ignore[attr-defined]
    except Exception:
        if isinstance(step, dict):
            d = step.get("details", {})
            if isinstance(d, dict):
                return d.get(key)
        return None

def _risk_color(risk: float) -> str:
    if risk <= 0.15: return "green"
    if risk <= 0.35: return "yellow"
    if risk <= 0.60: return "orange"
    return "red"

def _fmt_ev(ev: float, risk: float) -> str:
    return f"VP {ev:+.2f} | risk {risk:.2f}"

def _label_overlay(text: str, anchor_hex: Optional[str], plan_index: int, step: int, color: str) -> Dict[str, Any]:
    return {
        "type": "label",
        "text": text,
        "anchor": {"type": "hex", "id": anchor_hex} if anchor_hex else {"type": "screen", "pos": "auto"},
        "style": {"color": color},
        "meta": {"plan": plan_index, "step": step},
    }

def _top_picks_from_notes(notes_json: str) -> str:
    try:
        import json
        data = json.loads(notes_json)
        top = data.get("top_picks", [])
        names = [str(t.get("category","")) for t in top[:2] if t]
        return "/".join(names)
    except Exception:
        return ""

def _legend_overlay() -> Dict[str, Any]:
    text = "Legend: green0.15 risk < yellow0.35 < orange0.60 < red"
    return {"type": "legend", "text": text}

===== FILE: eclipse_ai/pathing.py =====

"""Adjacency and pinning helpers shared across rules modules."""
from __future__ import annotations

from collections import deque
from typing import Dict, Iterable, Optional, Sequence, Set, Tuple

from .alliances import are_allied
from .game_models import Hex, MapState
from .movement import LEGAL_CONNECTION_TYPES, classify_connection


def valid_edge(
    map_state: Optional[MapState],
    src_id: str,
    dst_id: str,
    *,
    feature_flags: Optional[Dict[str, bool]] = None,
    player_has_wormhole_generator: bool = False,
) -> bool:
    """Return ``True`` when movement between the hexes is permitted."""

    if not map_state or not map_state.hexes:
        return False
    if not src_id or not dst_id:
        return False
    if src_id == dst_id:
        return True

    flags = dict(feature_flags or {})
    src_hex = map_state.hexes.get(src_id)
    dst_hex = map_state.hexes.get(dst_id)
    if src_hex is None or dst_hex is None:
        return False

    if _is_portal_link(src_hex, dst_hex, flags):
        return True
    if _is_deep_warp_link(src_hex, dst_hex, flags):
        return True

    src_edges = _edges_to_neighbor(src_hex, dst_id)
    if not src_edges:
        return False
    dst_edges = _edges_to_neighbor(dst_hex, src_id)
    if not dst_edges:
        return False

    src_has = any(_has_wormhole(src_hex, edge) for edge in src_edges)
    dst_has = any(_has_wormhole(dst_hex, edge) for edge in dst_edges)

    if src_has and dst_has:
        return True
    if player_has_wormhole_generator and (src_has or dst_has):
        return True
    return False


def compute_connectivity(state: object, pid: str, *, include_jump: bool = True) -> Set[str]:
    """Return the set of hex ids reachable for ``pid`` using MOVE legality."""

    if not state or not pid:
        return set()
    map_state = getattr(state, "map", None)
    if map_state is None or not getattr(map_state, "hexes", None):
        return set()

    player = None
    players = getattr(state, "players", {}) or {}
    try:
        player = players.get(pid)
    except AttributeError:
        player = None

    allow_jump = False
    if include_jump and player is not None:
        try:
            designs = getattr(player, "ship_designs", {}) or {}
            allow_jump = any(getattr(design, "has_jump_drive", False) for design in designs.values())
        except AttributeError:
            allow_jump = False

    reachable: Set[str] = set()
    visited: Set[Tuple[str, bool]] = set()
    queue: deque[Tuple[str, bool]] = deque()

    for hex_id, hx in map_state.hexes.items():
        friendly, enemy = _presence_counts(state, hx, pid)
        has_disc = bool(getattr(hx, "owner", None) == pid)
        pieces_map = getattr(hx, "pieces", {}) or {}
        player_pieces = pieces_map.get(pid) if isinstance(pieces_map, dict) else None
        discs = int(getattr(player_pieces, "discs", 0) or 0)
        if discs > 0:
            has_disc = True
        ships_available = friendly > 0
        anchored = has_disc or ships_available
        if not anchored:
            continue
        reachable.add(hex_id)
        pinned = enemy > 0 and friendly <= enemy
        if pinned:
            continue
        state_key = (hex_id, False)
        if state_key not in visited:
            visited.add(state_key)
            queue.append(state_key)

    while queue:
        current_id, jump_used = queue.popleft()
        current_hex = map_state.hexes.get(current_id)
        if current_hex is None:
            continue
        if getattr(current_hex, "has_gcds", False):
            # You may end in the Galactic Center but cannot continue through it when GCDS active.
            continue
        for neighbor_id in (getattr(current_hex, "neighbors", {}) or {}).values():
            if not neighbor_id:
                continue
            neighbor_hex = map_state.hexes.get(neighbor_id)
            if neighbor_hex is None:
                continue
            if not getattr(neighbor_hex, "explored", True):
                continue
            connection = classify_connection(state, player, current_id, neighbor_id)
            if connection not in LEGAL_CONNECTION_TYPES:
                continue
            next_jump_used = jump_used
            if connection == "jump":
                if not allow_jump or jump_used:
                    continue
                next_jump_used = True

            reachable.add(neighbor_id)

            # Entering a contested hex ends movement for that activation.
            friendly_dst, enemy_dst = _presence_counts(state, neighbor_hex, pid)
            if enemy_dst > 0 and friendly_dst <= enemy_dst:
                continue

            state_key = (neighbor_id, next_jump_used)
            if state_key in visited:
                continue
            visited.add(state_key)
            queue.append(state_key)

    return reachable


def is_pinned(
    hex_obj: Optional[Hex],
    owner_id: str,
    *,
    state: Optional[object] = None,
    allies: Optional[Iterable[str]] = None,
) -> bool:
    """Return ``True`` if the ships owned by ``owner_id`` cannot move out."""

    if hex_obj is None or not owner_id:
        return False

    friendly_ids: Set[str] = {owner_id}
    if allies:
        friendly_ids.update(str(a) for a in allies)

    friendly_strength = 0
    enemy_strength = int(getattr(hex_obj, "ancients", 0) or 0)

    pieces_map = getattr(hex_obj, "pieces", None)
    if isinstance(pieces_map, dict) and pieces_map:
        for pid, pieces in pieces_map.items():
            strength = _pieces_ship_strength(pieces)
            if strength <= 0:
                continue
            if pid in friendly_ids or _are_allied(state, pid, owner_id):
                friendly_strength += strength
            else:
                enemy_strength += strength
    else:
        ships_map = getattr(hex_obj, "ships", None)
        if isinstance(ships_map, dict):
            for pid, count in ships_map.items():
                strength = int(count or 0)
                if strength <= 0:
                    continue
                if pid in friendly_ids or _are_allied(state, pid, owner_id):
                    friendly_strength += strength
                else:
                    enemy_strength += strength
        starbase_count = int(getattr(hex_obj, "starbase", 0) or 0)
        if starbase_count > 0:
            if owner_id in friendly_ids:
                friendly_strength += starbase_count
            else:
                enemy_strength += starbase_count

    if friendly_strength <= 0:
        return False
    if enemy_strength <= 0:
        return False
    return enemy_strength >= friendly_strength


def _presence_counts(state: object, hex_obj: Optional[Hex], pid: str) -> Tuple[int, int]:
    if not hex_obj:
        return (0, 0)
    try:
        from .alliances import ship_presence

        return ship_presence(state, hex_obj, pid)
    except Exception:
        friendly = 0
        enemy = int(getattr(hex_obj, "ancients", 0) or 0)
        pieces_map = getattr(hex_obj, "pieces", None)
        if isinstance(pieces_map, dict):
            for owner, pieces in pieces_map.items():
                strength = _pieces_ship_strength(pieces)
                if owner == pid:
                    friendly += strength
                else:
                    enemy += strength
        else:
            ships_map = getattr(hex_obj, "ships", None)
            if isinstance(ships_map, dict):
                for owner, count in ships_map.items():
                    strength = int(count or 0)
                    if owner == pid:
                        friendly += strength
                    else:
                        enemy += strength
        return (friendly, enemy)


def is_warp_portal(hex_obj: Optional[Hex]) -> bool:
    if not hex_obj:
        return False
    if getattr(hex_obj, "has_warp_portal", False):
        return True
    return bool(getattr(hex_obj, "warp_portal", False))


def is_deep_warp_portal(hex_obj: Optional[Hex]) -> bool:
    if not hex_obj:
        return False
    if getattr(hex_obj, "has_deep_warp_portal", False):
        return True
    symbols: Sequence[str] = getattr(hex_obj, "symbols", ()) or ()
    return any(str(sym).lower() in {"deep_warp", "deep"} for sym in symbols)


def is_warp_nexus(hex_obj: Optional[Hex]) -> bool:
    if not hex_obj:
        return False
    if getattr(hex_obj, "is_warp_nexus", False):
        return True
    return bool(getattr(hex_obj, "warp_nexus", False))


def _edges_to_neighbor(hex_obj: Hex, neighbor_id: str) -> Sequence[int]:
    neighbors = getattr(hex_obj, "neighbors", {}) or {}
    return [edge for edge, nid in neighbors.items() if nid == neighbor_id]


def _has_wormhole(hex_obj: Hex, edge: int) -> bool:
    if hasattr(hex_obj, "has_wormhole"):
        try:
            return bool(hex_obj.has_wormhole(edge))  # type: ignore[attr-defined]
        except TypeError:
            pass
    wormholes = getattr(hex_obj, "wormholes", ()) or ()
    return edge in set(int(e) for e in wormholes)


def _is_portal_link(a: Hex, b: Hex, flags: Dict[str, bool]) -> bool:
    if not flags.get("warp_portals") and not flags.get("rotA"):
        return False
    return is_warp_portal(a) and is_warp_portal(b)


def _is_deep_warp_link(a: Hex, b: Hex, flags: Dict[str, bool]) -> bool:
    if not flags.get("sotR") and not flags.get("deep_warp"):
        return False
    if is_warp_nexus(a) and is_deep_warp_portal(b):
        return True
    if is_warp_nexus(b) and is_deep_warp_portal(a):
        return True
    return False


def _pieces_ship_strength(pieces: object) -> int:
    strength = 0
    ships = getattr(pieces, "ships", None)
    if isinstance(ships, dict):
        strength += sum(int(v or 0) for v in ships.values())
    strength += int(getattr(pieces, "starbase", 0) or 0)
    return strength


def _are_allied(state: Optional[object], a_id: str, b_id: str) -> bool:
    try:
        if state is None:
            return False
        return are_allied(state, a_id, b_id)
    except Exception:
        return False


__all__ = [
    "compute_connectivity",
    "is_deep_warp_portal",
    "is_pinned",
    "is_warp_nexus",
    "is_warp_portal",
    "valid_edge",
]


===== FILE: eclipse_ai/research.py =====

"""Special research rules for expansion factions."""
from __future__ import annotations

from typing import Any, Dict, List, Optional

from .game_models import GameState, PlayerState, Action, ActionType, Tech


def discounted_cost(player: PlayerState, tech: Tech, band_cost: Optional[int] = None) -> int:
    """Compute a player's discounted price for a technology."""

    base = band_cost if band_cost is not None else tech.base_cost
    min_cost = tech.cost_range[0] if getattr(tech, "cost_range", None) else tech.base_cost
    base = max(base, min_cost)
    if tech.is_rare:
        return max(min_cost, base)
    discount = player.tech_count_by_category.get(tech.category, 0)
    return max(min_cost, base - discount)


def can_afford(player: PlayerState, tech: Tech, band_cost: Optional[int] = None) -> bool:
    """Return True if the player has enough Science to purchase the tech."""

    return player.science >= discounted_cost(player, tech, band_cost)

_EVOLUTION_TILE_DEFAULT_COST = 4


def enumerate_research_actions(state: GameState, player: PlayerState) -> List[Action]:
    """Return additional Research actions unlocked by species abilities."""
    if not player:
        return []

    actions: List[Action] = []
    if _evolution_enabled(player):
        cost = int(player.species_flags.get("evolution_tile_cost", _EVOLUTION_TILE_DEFAULT_COST))
        pool = ensure_evolution_pool(player)
        if pool.get("size", 0) > 0 and player.resources.science >= cost:
            actions.append(
                Action(
                    ActionType.RESEARCH,
                    {
                        "evolution_tile": 1,
                        "approx_cost": cost,
                        "notes": "Draw an Evolution tile",
                    },
                )
            )

    actions.extend(_mutagen_trade_actions(player))
    return actions


def ensure_evolution_pool(player: PlayerState) -> Dict[str, Any]:
    """Initialise the player's Evolution pool data structure if required."""
    pool = player.species_pools.setdefault("evolution", {})
    size = int(player.species_flags.get("evolution_pool_size", 0) or 0)
    if pool.get("size") != size:
        pool["size"] = size
    tiles = pool.get("tiles")
    if tiles is None or len(tiles) < size:
        pool["tiles"] = list((tiles or []))
        while len(pool["tiles"]) < size:
            pool["tiles"].append(None)
    return pool


def produce_mutagen(player: PlayerState) -> int:
    """Apply passive Mutagen production for Octantis factions."""
    income = int(player.special_resources.get("mutagen_income", 0)) if player.special_resources else 0
    if income <= 0:
        return 0
    current = player.special_resources.get("mutagen", 0)
    player.special_resources["mutagen"] = int(current) + income
    return income


def _mutagen_trade_actions(player: PlayerState) -> List[Action]:
    rate = int(player.special_resources.get("mutagen_trade_rate", 0)) if player.special_resources else 0
    if rate <= 0:
        return []
    actions: List[Action] = []
    for resource in ("money", "science", "materials"):
        amount = getattr(player.resources, resource, 0)
        if amount >= rate:
            actions.append(
                Action(
                    ActionType.RESEARCH,
                    {
                        "mutagen_trade": {
                            "resource": resource,
                            "spend": rate,
                            "gain_mutagen": 1,
                        },
                        "notes": "Convert resources to Mutagen",
                    },
                )
            )
    return actions


def _evolution_enabled(player: PlayerState) -> bool:
    try:
        return bool(player.species_flags.get("evolution_enabled"))
    except AttributeError:
        return False

===== FILE: eclipse_ai/round_flow.py =====

from __future__ import annotations

from typing import Dict, List, Optional, Sequence, Tuple, Union

from .game_models import (
    ActionType,
    Disc,
    GameState,
    Hex,
    MapState,
    Pieces,
    PlayerState,
)


ACTION_SPACE_KEYS: Tuple[str, ...] = (
    "explore",
    "influence",
    "research",
    "upgrade",
    "build",
    "move",
    "reaction",
)

REACTION_TYPES: Tuple[str, ...] = ("upgrade", "build", "move")


class PhaseError(RuntimeError):
    """Raised when a caller attempts to act outside of the current phase."""


class InfluenceError(RuntimeError):
    """Raised for invalid influence manipulations."""


# ---------------------------------------------------------------------------
# Round structure helpers
# ---------------------------------------------------------------------------

def begin_round(state: GameState) -> GameState:
    """Reset per-round flags and establish the active player."""

    _ensure_turn_order(state)
    state.phase = "ACTION"
    if state.pending_starting_player:
        state.starting_player = state.pending_starting_player
    state.pending_starting_player = None
    for player in state.players.values():
        player.passed = False
    if not state.turn_order:
        state.active_player = ""
        state.turn_index = 0
        return state
    start = state.starting_player or state.turn_order[0]
    if start not in state.turn_order:
        start = state.turn_order[0]
    state.turn_index = state.turn_order.index(start)
    state.active_player = state.turn_order[state.turn_index]
    return state


def take_action(
    state: GameState,
    player_id: str,
    action: Union[str, ActionType],
    payload: Optional[Dict[str, object]] = None,
) -> None:
    if state.phase != "ACTION":
        raise PhaseError("Actions can only be taken during the Action phase")
    player = _require_player_turn(state, player_id)
    if player.passed:
        raise PhaseError("Passed players may only perform reactions")
    disc = _pop_influence_disc(player)
    action_key = _normalise_action_key(action)
    if action_key not in ACTION_SPACE_KEYS[:-1]:  # exclude reaction slot
        raise ValueError(f"Unknown action space '{action}'")
    _ensure_action_board(player)[action_key].append(disc)
    payload = payload or {}
    if action_key == "influence":
        _apply_influence_payload(state, player, payload)
    _advance_turn(state)


def pass_action(state: GameState, player_id: str) -> None:
    if state.phase != "ACTION":
        raise PhaseError("Passing is only available during the Action phase")
    player = _require_player_turn(state, player_id)
    if not player.passed:
        player.passed = True
        if state.pending_starting_player is None:
            state.pending_starting_player = player_id
    _advance_turn(state)


def can_take_reaction(state: GameState, player_id: str) -> bool:
    if state.phase != "ACTION":
        return False
    player = state.players.get(player_id)
    return bool(player and player.passed and not player.collapsed)


def take_reaction(
    state: GameState,
    player_id: str,
    reaction_type: str,
    payload: Optional[Dict[str, object]] = None,
) -> None:
    if state.phase != "ACTION":
        raise PhaseError("Reactions may only be taken during the Action phase")
    player = _require_player_turn(state, player_id)
    if not player.passed:
        raise PhaseError("Only passed players may take reactions")
    reaction_key = reaction_type.lower()
    if reaction_key not in REACTION_TYPES:
        raise ValueError(
            "Reactions limited to Upgrade, Build, or Move"  # Nanorobots ignored
        )
    disc = _pop_influence_disc(player)
    _ensure_action_board(player)["reaction"].append(disc)
    payload = payload or {}
    if reaction_key == "build":
        _validate_single_build(payload)
    elif reaction_key == "move":
        _validate_single_move(payload)
    _advance_turn(state)


def end_action_phase_if_all_passed(state: GameState) -> bool:
    if state.phase != "ACTION":
        return False
    if not state.players:
        return False
    if all(p.passed or p.collapsed for p in state.players.values()):
        state.phase = "COMBAT"
        state.active_player = ""
        return True
    return False


# ---------------------------------------------------------------------------
# Upkeep and cleanup
# ---------------------------------------------------------------------------

def run_upkeep(state: GameState) -> None:
    if state.phase != "UPKEEP":
        raise PhaseError("Upkeep can only be resolved during the Upkeep phase")
    for player in state.players.values():
        if player.collapsed:
            continue
        income_money = int(getattr(player.income, "money", 0))
        money_available = int(getattr(player.resources, "money", 0)) + income_money
        cost = _influence_cost(state, player)
        while money_available < cost:
            if not _remove_disc_for_shortfall(state, player):
                player.collapsed = True
                money_available = 0
                break
            cost = _influence_cost(state, player)
        if player.collapsed:
            player.resources.money = 0
            player.resources.science += int(getattr(player.income, "science", 0))
            player.resources.materials += int(getattr(player.income, "materials", 0))
            continue
        player.resources.money = money_available - cost
        player.resources.science += int(getattr(player.income, "science", 0))
        player.resources.materials += int(getattr(player.income, "materials", 0))
    state.phase = "CLEANUP"


def run_cleanup(state: GameState) -> None:
    if state.phase != "CLEANUP":
        raise PhaseError("Cleanup may only be run during the Cleanup phase")
    for player in state.players.values():
        board = _ensure_action_board(player)
        for key in ACTION_SPACE_KEYS:
            while board[key]:
                player.influence_track.append(board[key].pop())
        for key in ACTION_SPACE_KEYS:
            board[key].clear()
        _flip_colony_ships_up(player)
        player.passed = False
    state.round += 1
    begin_round(state)


# ---------------------------------------------------------------------------
# Colony ships
# ---------------------------------------------------------------------------

def activate_colony_ship(
    state: GameState,
    player_id: str,
    color: str,
    count: int = 1,
    *,
    allow_upkeep: bool = False,
) -> None:
    if state.phase != "ACTION" and not (allow_upkeep and state.phase == "UPKEEP"):
        raise PhaseError("Colony ships may only be activated during your action")
    player = state.players[player_id]
    available = player.colony_ships.face_up.get(color, 0)
    if count < 0 or available < count:
        raise ValueError("Not enough colony ships available")
    player.colony_ships.face_up[color] = available - count
    player.colony_ships.face_down[color] = (
        player.colony_ships.face_down.get(color, 0) + count
    )


# ---------------------------------------------------------------------------
# Influence helpers
# ---------------------------------------------------------------------------

def _apply_influence_payload(
    state: GameState, player: PlayerState, payload: Dict[str, object]
) -> None:
    moves = payload.get("moves") if payload else None
    if moves is None:
        return
    if not isinstance(moves, Sequence):
        raise InfluenceError("Influence moves must be a sequence")
    if len(moves) > 2:
        raise InfluenceError("Influence allows at most two disc moves")
    has_generator = "Wormhole Generator" in (player.known_techs or [])
    for move in moves:
        if not isinstance(move, dict):
            raise InfluenceError("Influence moves must be dictionaries")
        src = move.get("from")
        dst = move.get("to")
        _resolve_influence_move(state, player, src, dst, has_generator)


def _resolve_influence_move(
    state: GameState,
    player: PlayerState,
    src: Optional[str],
    dst: Optional[str],
    has_generator: bool,
) -> None:
    src_key = _normalise_location(src)
    dst_key = _normalise_location(dst)
    if src_key == dst_key:
        raise InfluenceError("Influence move must change location")
    if dst_key == "track":
        disc = _remove_disc_from_hex(state, player, src_key, reason="influence")
        player.influence_track.append(disc)
        return
    if src_key == "track":
        disc = _pop_influence_disc(player)
        _place_disc_on_hex(state, player, dst_key, disc, has_generator)
        return
    disc = _remove_disc_from_hex(state, player, src_key, reason="influence")
    _place_disc_on_hex(state, player, dst_key, disc, has_generator)


def _place_disc_on_hex(
    state: GameState,
    player: PlayerState,
    hex_id: str,
    disc: Disc,
    has_generator: bool,
) -> None:
    hex_state = _require_hex(state.map, hex_id)
    _validate_influence_destination(state, player, hex_state, has_generator)
    pieces = hex_state.pieces.get(player.player_id)
    if pieces is None:
        pieces = hex_state.pieces[player.player_id] = Pieces(ships={}, starbase=0, discs=0, cubes={})
    if pieces.discs >= 1:
        raise InfluenceError("A hex may not hold more than one influence disc per player")
    pieces.discs += 1


def _remove_disc_from_hex(
    state: GameState,
    player: PlayerState,
    hex_id: str,
    *,
    reason: str,
) -> Disc:
    if reason == "influence":
        if state.phase != "ACTION":
            raise InfluenceError("Influence discs may be moved during the Action phase only")
    elif reason == "shortfall":
        if state.phase != "UPKEEP":
            raise InfluenceError("Upkeep disc removal only happens during Upkeep")
    else:
        raise InfluenceError("Unknown removal reason")
    hex_state = _require_hex(state.map, hex_id)
    pieces = hex_state.pieces.get(player.player_id)
    if not pieces or pieces.discs <= 0:
        raise InfluenceError("No influence disc to remove from hex")
    pieces.discs -= 1
    if pieces.cubes:
        for color, qty in list(pieces.cubes.items()):
            player.population[color] = player.population.get(color, 0) + qty
        pieces.cubes.clear()
    for planet in hex_state.planets:
        if planet.colonized_by == player.player_id:
            planet.colonized_by = None
    player.colonies.pop(hex_id, None)
    if pieces.discs == 0 and not pieces.ships and pieces.starbase == 0:
        hex_state.pieces.pop(player.player_id, None)
    return _new_disc(player)


def _validate_influence_destination(
    state: GameState,
    player: PlayerState,
    hex_state: Hex,
    has_generator: bool,
) -> None:
    if _has_influence(state, player.player_id, hex_state.id):
        return
    connected = False
    for neighbor_id in state.map.adjacency.get(hex_state.id, []):
        if _has_influence(state, player.player_id, neighbor_id):
            connected = True
            break
    if not connected and has_generator:
        for neighbor_id, targets in state.map.adjacency.items():
            if hex_state.id in targets and _has_influence(state, player.player_id, neighbor_id):
                connected = True
                break
    if not connected:
        raise InfluenceError("Destination hex is not connected by influence")


def _has_influence(state: GameState, player_id: str, hex_id: str) -> bool:
    pieces = state.map.hexes.get(hex_id, Hex(id=hex_id, ring=0)).pieces.get(player_id)
    return bool(pieces and pieces.discs > 0)


def _remove_disc_for_shortfall(state: GameState, player: PlayerState) -> bool:
    candidates: List[Tuple[int, str]] = []
    for hex_id, hx in state.map.hexes.items():
        pieces = hx.pieces.get(player.player_id)
        if pieces and pieces.discs > 0:
            candidates.append((hx.ring, hex_id))
    if not candidates:
        return False
    candidates.sort(reverse=True)
    _, hex_id = candidates[0]
    disc = _remove_disc_from_hex(state, player, hex_id, reason="shortfall")
    player.influence_track.append(disc)
    return True


def _influence_cost(state: GameState, player: PlayerState) -> int:
    cost = 0
    for hex_state in state.map.hexes.values():
        pieces = hex_state.pieces.get(player.player_id)
        if pieces:
            cost += int(pieces.discs)
    board = _ensure_action_board(player)
    for key in ACTION_SPACE_KEYS:
        cost += len(board[key])
    return cost


# ---------------------------------------------------------------------------
# Utility helpers
# ---------------------------------------------------------------------------

def _ensure_turn_order(state: GameState) -> None:
    if not state.turn_order:
        state.turn_order = list(state.players.keys())
    state.turn_order = [pid for pid in state.turn_order if pid in state.players]
    for pid in state.players:
        if pid not in state.turn_order:
            state.turn_order.append(pid)


def _advance_turn(state: GameState) -> None:
    if not state.turn_order:
        state.active_player = ""
        return
    for _ in range(len(state.turn_order)):
        state.turn_index = (state.turn_index + 1) % len(state.turn_order)
        next_pid = state.turn_order[state.turn_index]
        player = state.players.get(next_pid)
        if player and not player.collapsed:
            state.active_player = next_pid
            return
    state.active_player = ""


def _ensure_action_board(player: PlayerState) -> Dict[str, List[Disc]]:
    board = player.action_spaces
    for key in ACTION_SPACE_KEYS:
        board.setdefault(key, [])
    return board


def _pop_influence_disc(player: PlayerState) -> Disc:
    if not player.influence_track:
        raise InfluenceError("No influence discs available on the track")
    return player.influence_track.pop()


def _new_disc(player: PlayerState, *, extra: bool = False) -> Disc:
    ident = f"{player.player_id}-disc-{len(player.influence_track) + 1}"
    return Disc(id=ident, extra=extra)


def _normalise_action_key(action: Union[str, ActionType]) -> str:
    if isinstance(action, ActionType):
        action = action.value
    return str(action).strip().lower()


def _normalise_location(loc: Optional[str]) -> str:
    if loc is None:
        return "track"
    loc = str(loc).strip()
    return "track" if loc.lower() == "track" else loc


def _require_player_turn(state: GameState, player_id: str) -> PlayerState:
    if state.active_player != player_id:
        raise PhaseError("It is not this player's turn")
    try:
        return state.players[player_id]
    except KeyError as exc:
        raise ValueError("Unknown player") from exc


def _require_hex(map_state: MapState, hex_id: str) -> Hex:
    try:
        return map_state.hexes[hex_id]
    except KeyError as exc:
        raise InfluenceError("Unknown hex") from exc


def _validate_single_build(payload: Dict[str, object]) -> None:
    ships = payload.get("ships") if payload else None
    if not isinstance(ships, dict) or not ships:
        raise ValueError("Reaction build must specify exactly one ship")
    total = sum(int(v) for v in ships.values())
    if total != 1:
        raise ValueError("Reactions build exactly one ship; Nanorobots ignored")


def _validate_single_move(payload: Dict[str, object]) -> None:
    ships = payload.get("ships") if payload else None
    if not isinstance(ships, dict) or not ships:
        raise ValueError("Reaction move must activate exactly one ship")
    total = sum(int(v) for v in ships.values())
    if total != 1:
        raise ValueError("Reaction move may activate only one ship")


def _remove_disc_from_hex_for_testing(
    state: GameState, player: PlayerState, hex_id: str
) -> Disc:
    """Testing hook to enforce removal restrictions."""

    return _remove_disc_from_hex(state, player, hex_id, reason="influence")


def _flip_colony_ships_up(player: PlayerState) -> None:
    for color, qty in list(player.colony_ships.face_down.items()):
        if not qty:
            continue
        player.colony_ships.face_up[color] = (
            player.colony_ships.face_up.get(color, 0) + qty
        )
        player.colony_ships.face_down[color] = 0


===== FILE: eclipse_ai/rules_engine.py =====

from __future__ import annotations
from collections import Counter
from dataclasses import dataclass, field, asdict, is_dataclass
from typing import List, Dict, Any, Optional, Tuple, Set
from .game_models import GameState, Action, ActionType, PlayerState, Hex, Planet, Pieces, Resources, ShipDesign
from .technology import discounted_cost, can_research, load_tech_definitions
from .game_models import GameState, Action, ActionType, PlayerState, Hex, Planet, Pieces, Resources
from .ship_parts import SHIP_PARTS, SHIP_BLUEPRINT_SLOTS, MOBILE_SHIPS
from .types import ShipDesign
from .research import enumerate_research_actions
from .alliances import allies_for_player
from .pathing import is_pinned

# =============================
# Config
# =============================

@dataclass
class RulesConfig:
    expansions: Dict[str, bool] = field(default_factory=lambda: {"RoA": True, "SoTR": False})
    enable_influence: bool = True
    enable_diplomacy: bool = True
    max_actions: int = 40  # hard cap to avoid explosion

# Build costs and fleet caps share a single source of truth for the UI/tests.
BUILD_COST: Dict[str, int] = {
    "interceptor": 3,
    "cruiser": 5,
    "dreadnought": 8,
    "starbase": 3,
    "orbital": 5,
    "monolith": 10,
}

FLEET_CAP: Dict[str, int] = {
    "interceptor": 8,
    "cruiser": 4,
    "dreadnought": 2,
    "starbase": 4,
}

STRUCTURE_TECH_REQUIREMENTS: Dict[str, str] = {
    "starbase": "Starbase",
    "orbital": "Orbital",
    "monolith": "Monolith",
}


class RulesViolation(ValueError):
    """Raised when an attempted action violates the core rulebook."""


# =============================
# Public API
# =============================

def legal_actions(state: GameState, player_id: str, config: Optional[RulesConfig]=None) -> List[Action]:
    """
    Produces a practical set of candidate actions for the active player.
    Resource-aware. No pathfinding. Conservative about rules we cannot infer.
    """
    cfg = config or RulesConfig()
    acts: List[Action] = []
    possible_actions: Set[ActionType] = set()
    you = state.players.get(player_id) if state.players else None
    if you is None:
        state.possible_actions = {ActionType.PASS}
        state.can_explore = False
        state.can_move_ships = False
        return [Action(ActionType.PASS, {})]

    # Explore
    explore_actions = _enum_explore(state, you)
    if explore_actions:
        possible_actions.add(ActionType.EXPLORE)
    acts.extend(explore_actions)

    # Research
    research_actions = _enum_research(state, you)
    if research_actions:
        possible_actions.add(ActionType.RESEARCH)
    acts.extend(research_actions)

    # Build
    build_actions = _enum_build(state, you)
    if build_actions:
        possible_actions.add(ActionType.BUILD)
    acts.extend(build_actions)

    # Move (includes "assault in place" if enemies are already in hex)
    move_actions = _enum_moves(state, you)
    if move_actions:
        possible_actions.add(ActionType.MOVE)
    acts.extend(move_actions)

    # Upgrade (suggest small design improvements)
    upgrade_actions = _enum_upgrades(state, you)
    if upgrade_actions:
        possible_actions.add(ActionType.UPGRADE)
    acts.extend(upgrade_actions)

    # Influence
    if cfg.enable_influence:
        influence_actions = _enum_influence(state, you)
        if influence_actions:
            possible_actions.add(ActionType.INFLUENCE)
        acts.extend(influence_actions)

    # Diplomacy
    if cfg.enable_diplomacy:
        diplomacy_actions = _enum_diplomacy(state, you)
        if diplomacy_actions:
            possible_actions.add(ActionType.DIPLOMACY)
        acts.extend(diplomacy_actions)

    # Pass is always an option
    acts.append(Action(ActionType.PASS, {}))
    possible_actions.add(ActionType.PASS)

    # Deduplicate and cap
    uniq = _dedup_actions(acts)
    state.possible_actions = possible_actions
    state.can_explore = ActionType.EXPLORE in possible_actions
    state.can_move_ships = ActionType.MOVE in possible_actions
    return uniq[:cfg.max_actions]

# =============================
# Enumerators
# =============================

def _enum_explore(state: GameState, you: PlayerState) -> List[Action]:
    out: List[Action] = []
    # Heuristic: explore outward from any hex you occupy. If bags exist for R2/R3, use them.
    rings_to_consider = set()
    for hx in state.map.hexes.values():
        if you.player_id in hx.pieces:
            rings_to_consider.add(max(1, hx.ring))           # same ring
            rings_to_consider.add(max(1, hx.ring + 1))       # outward
    for r in sorted(rings_to_consider):
        bag = state.bags.get(f"R{r}", {})
        if bag:
            out.append(Action(ActionType.EXPLORE, {"ring": r, "draws": 1, "direction": f"adjacent from ring {r-1 if r>1 else r}"}))
    return out

def _enum_research(state: GameState, you: PlayerState) -> List[Action]:
    out: List[Action] = []
    if not state.tech_definitions:
        state.tech_definitions = load_tech_definitions()
    avail = list(state.market)
    known = set(you.owned_tech_ids or set())
    science = you.science
    # Sort by a simple preference: combat techs, mobility, economy
    priority = sorted(avail, key=_tech_priority_key, reverse=True)
    for tech in priority:
        if tech in known:
            continue
        tech_obj = state.tech_definitions.get(tech)
        if tech_obj is None:
            continue
        cost = discounted_cost(you, tech_obj)
        if science >= cost and can_research(state, you, tech):
            out.append(Action(ActionType.RESEARCH, {"tech": tech, "approx_cost": cost}))
        elif len(out) < 1 and science + 1 >= cost and can_research(state, you, tech):
            out.append(Action(ActionType.RESEARCH, {"tech": tech, "approx_cost": cost, "note": "stretch"}))
        if len(out) >= 5:
            break
    out.extend(enumerate_research_actions(state, you))
    return out

def _enum_build(state: GameState, you: PlayerState) -> List[Action]:
    out: List[Action] = []
    mats = you.resources.materials if you.resources else 0
    your_hexes = _player_hexes(state, you.player_id)
    contested = [hx for hx in your_hexes if _enemy_presence_in_hex(state, you.player_id, hx) > 0]

    # Build starbase in contested hex if affordable
    banned = set(you.cannot_build or set())
    if "starbase" not in banned:
        for hx in contested:
            if mats >= BUILD_COST["starbase"]:
                out.append(Action(ActionType.BUILD, {"hex": hx.id, "starbase": 1}))

    # Build ships in any controlled hex
    for hx in your_hexes:
        # Try a few affordable bundles
        if mats >= BUILD_COST["dreadnought"]:
            out.append(Action(ActionType.BUILD, {"hex": hx.id, "ships": {"dreadnought": 1}}))
        if mats >= BUILD_COST["cruiser"]:
            out.append(Action(ActionType.BUILD, {"hex": hx.id, "ships": {"cruiser": 1}}))
        if mats >= 2 * BUILD_COST["interceptor"]:
            out.append(Action(ActionType.BUILD, {"hex": hx.id, "ships": {"interceptor": 2}}))
        if mats >= BUILD_COST["interceptor"]:
            out.append(Action(ActionType.BUILD, {"hex": hx.id, "ships": {"interceptor": 1}}))

    return out

def _enum_moves(state: GameState, you: PlayerState) -> List[Action]:
    out: List[Action] = []
    your_hexes = _player_hexes(state, you.player_id)
    allies = set(allies_for_player(state, you.player_id))
    phase = (getattr(state, "phase", "") or "").upper()
    reaction_map = getattr(state, "reactions_active", {}) or {}
    is_reaction = bool(you.passed)
    if not is_reaction and phase == "ACTION":
        is_reaction = bool(reaction_map.get(you.player_id))
    elif phase == "REACTION":
        is_reaction = True

    # 1) Assault in place if enemies present
    for hx in your_hexes:
        pieces = hx.pieces.get(you.player_id)
        if not pieces:
            continue
        if is_pinned(hx, you.player_id, state=state, allies=allies):
            continue
        if _enemy_presence_in_hex(state, you.player_id, hx) > 0:
            ships = _movable_ships(pieces, single_ship=is_reaction)
            if ships:
                out.append(Action(ActionType.MOVE, {"from": hx.id, "to": hx.id, "ships": ships}))
    # 2) Move toward valuable or enemy-held hexes (range-agnostic placeholder)
    enemy_hexes = [
        hx
        for hx in state.map.hexes.values()
        if _is_explored_hex(hx) and _enemy_presence_in_hex(state, you.player_id, hx) > 0
    ]
    valuable_empty = sorted(
        [
            hx
            for hx in state.map.hexes.values()
            if _is_explored_hex(hx)
            and _enemy_presence_in_hex(state, you.player_id, hx) == 0
        ],
        key=_hex_value_key,
        reverse=True
    )[:3]
    for src in your_hexes:
        pieces = src.pieces.get(you.player_id)
        if not pieces:
            continue
        if is_pinned(src, you.player_id, state=state, allies=allies):
            continue
        ships = _movable_ships(pieces, single_ship=is_reaction)
        if not ships:
            continue
        # aim at top 2 enemy hexes
        for dst in enemy_hexes[:2]:
            if dst.id == src.id:
                continue
            out.append(Action(ActionType.MOVE, {"from": src.id, "to": dst.id, "ships": ships}))
        # aim at one valuable empty hex
        for dst in valuable_empty[:1]:
            if dst.id == src.id:
                continue
            out.append(Action(ActionType.MOVE, {"from": src.id, "to": dst.id, "ships": ships}))
    return out

def _enum_upgrades(state: GameState, you: PlayerState) -> List[Action]:
    out: List[Action] = []
    # Suggest small design improvements if you have ships of that class on the board
    counts: Dict[str,int] = {}
    for hx in state.map.hexes.values():
        p = hx.pieces.get(you.player_id)
        if not p:
            continue
        for cls, n in p.ships.items():
            counts[cls] = counts.get(cls, 0) + int(n)
    if counts.get("interceptor", 0) > 0:
        out.append(Action(ActionType.UPGRADE, {"apply": {"interceptor": {"cannons": +1, "computer": +1}}}))
    if counts.get("cruiser", 0) > 0:
        out.append(Action(ActionType.UPGRADE, {"apply": {"cruiser": {"shield": +1}}}))
    if counts.get("dreadnought", 0) > 0:
        out.append(Action(ActionType.UPGRADE, {"apply": {"dreadnought": {"hull": +1}}}))
    return out

# =============================
# Validators
# =============================

def validate_design(player: PlayerState, ship_type: str, blueprint: Any) -> None:
    """Validate and normalise a ship blueprint according to the rulebook."""

    design = _coerce_ship_design(blueprint)
    ship_key = _normalize_ship_class(ship_type)
    if ship_key not in SHIP_BLUEPRINT_SLOTS:
        raise RulesViolation(f"Unknown ship type '{ship_type}' for design validation")

    part_maps = _design_part_maps(design)
    has_explicit_parts = any(part_maps[attr] for attr in part_maps)

    if not has_explicit_parts:
        _validate_legacy_design(player, ship_key, design)
        return

    slot_limit = SHIP_BLUEPRINT_SLOTS[ship_key]
    totals = Counter()
    known_techs = set(player.known_techs or [])

    for attr, category in (
        ("computer_parts", "computer"),
        ("shield_parts", "shield"),
        ("cannon_parts", "cannon"),
        ("missile_parts", "missile"),
        ("drive_parts", "drive"),
        ("energy_sources", "energy"),
        ("hull_parts", "hull"),
    ):
        clean = _sanitize_part_dict(getattr(design, attr, {}), category)
        setattr(design, attr, clean)
        for part_name, count in clean.items():
            part = SHIP_PARTS.get(part_name)
            if not part:
                raise RulesViolation(f"Unknown ship part '{part_name}' on {ship_type}")
            if part.category != category and not (category == "energy" and part.category == "energy"):
                raise RulesViolation(
                    f"Part '{part_name}' cannot be placed in {category} slots"
                )
            if part.requires_tech and part.requires_tech not in known_techs:
                raise RulesViolation(
                    f"{player.player_id} must research {part.requires_tech} before using {part.name}"
                )
            totals["slots"] += part.slots * count
            totals["initiative"] += part.initiative * count
            totals["energy_consumption"] += part.energy_consumption * count
            totals["energy_production"] += part.energy_production * count
            if part.category == "computer":
                totals["computer"] += part.computer * count
            if part.category == "shield":
                totals["shield"] += part.shield * count
            if part.category == "hull":
                totals["hull"] += part.hull * count
            if part.category == "cannon":
                totals["cannon_power"] += part.weapon_strength * count
            if part.category == "missile":
                totals["missiles"] += part.missiles * count
                totals["initiative"] += part.initiative * count
            if part.category == "drive":
                totals["movement"] += part.movement * count
                totals["drive_count"] += count

    if totals["slots"] > slot_limit:
        raise RulesViolation(
            f"{ship_type.title()} blueprint exceeds its {slot_limit}-slot limit"
        )

    if ship_key == "starbase" and totals["drive_count"] > 0:
        raise RulesViolation("Starbases may not equip Drives")

    design.initiative = totals["initiative"]
    design.movement_value = totals["movement"]
    design.energy_consumption = totals["energy_consumption"]
    design.energy_production = totals["energy_production"]
    design.computer = totals["computer"]
    design.shield = totals["shield"]
    design.hull = max(1, totals["hull"])
    design.cannons = totals["cannon_power"]
    design.missiles = totals["missiles"]
    design.drive = totals["drive_count"]

    if design.energy_production - design.energy_consumption < 0:
        raise RulesViolation(
            f"{ship_type.title()} design consumes more energy than it produces"
        )

    if ship_key in MOBILE_SHIPS and design.drive <= 0:
        raise RulesViolation(f"{ship_type.title()} must include at least one Drive")


def _validate_legacy_design(player: PlayerState, ship_key: str, design: ShipDesign) -> None:
    """Fallback validation for older aggregated blueprints with no part data."""

    if ship_key in MOBILE_SHIPS and design.drive <= 0:
        raise RulesViolation(f"{ship_key.title()} must include at least one Drive")
    if ship_key == "starbase" and design.drive > 0:
        raise RulesViolation("Starbases may not equip Drives")
    energy_delta = design.energy_production - design.energy_consumption
    if energy_delta < 0:
        raise RulesViolation(
            f"{player.player_id}'s {ship_key} blueprint is energy negative"
        )
    if ship_key in MOBILE_SHIPS and design.movement_value < design.drive:
        design.movement_value = design.drive


def _coerce_ship_design(blueprint: Any) -> ShipDesign:
    if isinstance(blueprint, ShipDesign):
        return blueprint
    if is_dataclass(blueprint):
        data = asdict(blueprint)
        mv = getattr(blueprint, "movement_value", None)
        if callable(mv):
            try:
                data.setdefault("movement_value", mv())
            except TypeError:
                pass
        elif mv is not None:
            data.setdefault("movement_value", mv)
        return _coerce_ship_design(data)
    if hasattr(blueprint, "__dict__") and not isinstance(blueprint, dict):
        data = dict(vars(blueprint))
        mv = data.get("movement_value")
        if mv is None:
            method = getattr(blueprint, "movement_value", None)
            if callable(method):
                try:
                    data["movement_value"] = method()
                except TypeError:
                    pass
        return _coerce_ship_design(data)
    if isinstance(blueprint, dict):
        design = ShipDesign()
        for attr, aliases in (
            ("computer_parts", ["computer_parts", "computers"]),
            ("shield_parts", ["shield_parts", "shields"]),
            ("cannon_parts", ["cannon_parts", "cannons"]),
            ("missile_parts", ["missile_parts", "missiles"]),
            ("drive_parts", ["drive_parts", "drives"]),
            ("energy_sources", ["energy_sources", "sources", "energy"]),
            ("hull_parts", ["hull_parts", "hulls"]),
        ):
            for key in aliases:
                if key in blueprint and isinstance(blueprint[key], dict):
                    setattr(design, attr, dict(blueprint[key]))
                    break
        for key in (
            "computer",
            "shield",
            "initiative",
            "hull",
            "cannons",
            "missiles",
            "drive",
            "movement_value",
            "energy_consumption",
            "energy_production",
        ):
            if key in blueprint:
                setattr(design, key, int(blueprint[key]))
        return design
    raise RulesViolation("Blueprint payload must be a ShipDesign or dict")


def _sanitize_part_dict(parts: Optional[Dict[str, Any]], category: str) -> Dict[str, int]:
    clean: Dict[str, int] = {}
    if not parts:
        return clean
    for name, value in parts.items():
        if value is None:
            continue
        count = int(value)
        if count < 0:
            raise RulesViolation(f"Cannot place a negative number of {category} parts")
        if count == 0:
            continue
        clean[str(name)] = count
    return clean


def _design_part_maps(design: ShipDesign) -> Dict[str, Dict[str, int]]:
    return {
        "computer_parts": design.computer_parts,
        "shield_parts": design.shield_parts,
        "cannon_parts": design.cannon_parts,
        "missile_parts": design.missile_parts,
        "drive_parts": design.drive_parts,
        "energy_sources": design.energy_sources,
        "hull_parts": design.hull_parts,
    }


def _normalize_ship_class(ship_type: str) -> str:
    return str(ship_type or "").strip().lower()


def validate_build(player: PlayerState, thing: Any, hex_id: str) -> None:
    """Validate a build action before applying it."""

    if not isinstance(thing, dict):
        raise RulesViolation("Build payload must be a dict")

    state: Optional[GameState] = thing.get("state") or thing.get("game_state")
    if not isinstance(state, GameState):
        raise RulesViolation("Build validation requires the current GameState under 'state'")

    ships = _sanitize_count_dict(thing.get("ships", {}))
    structures = _sanitize_count_dict(thing.get("structures", {}))

    # Support legacy payloads like {"starbase":1}
    for cls in ("interceptor", "cruiser", "dreadnought", "starbase"):
        if cls in thing:
            ships[cls] = ships.get(cls, 0) + int(thing[cls])
    for struct in ("orbital", "monolith"):
        if struct in thing:
            structures[struct] = structures.get(struct, 0) + int(thing[struct])

    banned = set(player.cannot_build or set())
    for cls in list(ships.keys()):
        if _normalize_ship_class(cls) in banned:
            raise RulesViolation(f"{player.player_id} cannot build {cls}")
    for struct in list(structures.keys()):
        if _normalize_ship_class(struct) in banned:
            raise RulesViolation(f"{player.player_id} cannot build {struct}")

    total_builds = sum(ships.values()) + sum(structures.values())
    if total_builds == 0:
        raise RulesViolation("Build action must create at least one ship or structure")
    if total_builds > 2:
        raise RulesViolation("Build action is limited to two ships/structures per action")

    known_techs = set(player.known_techs or [])

    cost = 0
    for cls, count in ships.items():
        key = _normalize_ship_class(cls)
        if key not in BUILD_COST:
            raise RulesViolation(f"Unsupported ship class '{cls}' for building")
        cost += BUILD_COST[key] * count
        if key == "starbase":
            tech = STRUCTURE_TECH_REQUIREMENTS.get("starbase")
            if tech and tech not in known_techs:
                raise RulesViolation("Research Starbase before building one")
    for struct, count in structures.items():
        key = _normalize_ship_class(struct)
        if key not in BUILD_COST:
            raise RulesViolation(f"Unsupported structure '{struct}' for building")
        cost += BUILD_COST[key] * count

    if player.resources.materials < cost:
        raise RulesViolation(
            f"Building these units costs {cost} Materials but only {player.resources.materials} are available"
        )

    hx = state.map.hexes.get(hex_id) if state.map else None
    if not hx:
        raise RulesViolation(f"Hex '{hex_id}' does not exist")
    pieces = hx.pieces.get(player.player_id)
    if not pieces or pieces.discs <= 0:
        raise RulesViolation("You must have an Influence Disc in the chosen hex to build there")

    _enforce_structure_rules(player, hx, structures)

    existing = _count_player_ships_on_board(state, player.player_id)
    for cls, count in ships.items():
        key = _normalize_ship_class(cls)
        cap = FLEET_CAP.get(key)
        if cap is not None and existing.get(key, 0) + count > cap:
            raise RulesViolation(
                f"Building {count} {key}s would exceed the fleet cap of {cap}"
            )
        supply = player.available_components.get(key)
        if supply is not None and count > supply:
            raise RulesViolation(
                f"{player.player_id} has only {supply} {key} miniature(s) remaining"
            )

    for struct, count in structures.items():
        supply = player.available_components.get(_normalize_ship_class(struct))
        if supply is not None and count > supply:
            raise RulesViolation(
                f"{player.player_id} has only {supply} {struct} component(s) remaining"
            )


def _sanitize_count_dict(raw: Any) -> Dict[str, int]:
    clean: Dict[str, int] = {}
    if not isinstance(raw, dict):
        return clean
    for name, value in raw.items():
        if value is None:
            continue
        count = int(value)
        if count < 0:
            raise RulesViolation("Cannot build a negative number of units")
        if count == 0:
            continue
        clean[str(name)] = count
    return clean


def _enforce_structure_rules(player: PlayerState, hx: Hex, structures: Dict[str, int]) -> None:
    for struct, count in structures.items():
        key = _normalize_ship_class(struct)
        if key not in ("orbital", "monolith"):
            continue
        tech = STRUCTURE_TECH_REQUIREMENTS.get(key)
        if tech and tech not in set(player.known_techs or []):
            raise RulesViolation(f"Research {tech} before building {struct}")
        if count > 1:
            raise RulesViolation(f"Only one {struct.title()} may be built in a hex")
        if key == "orbital" and hx.orbital:
            raise RulesViolation("Each hex may only contain one Orbital")
        if key == "monolith" and hx.monolith:
            raise RulesViolation("Each hex may only contain one Monolith")


def _count_player_ships_on_board(state: GameState, player_id: str) -> Dict[str, int]:
    totals: Counter[str] = Counter()
    for hx in state.map.hexes.values():
        pieces = hx.pieces.get(player_id)
        if not pieces:
            continue
        for cls, count in pieces.ships.items():
            totals[_normalize_ship_class(cls)] += int(count)
        if pieces.starbase:
            totals["starbase"] += int(pieces.starbase)
    return dict(totals)

def _enum_influence(state: GameState, you: PlayerState) -> List[Action]:
    out: List[Action] = []
    # Simple heuristic: if a nearby hex has uncolonized planets, consider placing a disc (income +1)
    # We do not track disc supply; caller should filter later if needed.
    target = None
    best_score = 0.0
    for hx in state.map.hexes.values():
        if you.player_id in hx.pieces:
            continue
        score = _hex_value_key(hx)
        if score > best_score:
            best_score, target = score, hx
    if target:
        # approximate one income increase of the dominant color
        color, inc = _dominant_planet_color(target)
        if color:
            income_delta = {"yellow":0, "blue":0, "brown":0}
            income_delta[color] = 1
            out.append(Action(ActionType.INFLUENCE, {"hex": target.id, "income_delta": income_delta}))
    return out

def _enum_diplomacy(state: GameState, you: PlayerState) -> List[Action]:
    out: List[Action] = []
    for pid in (state.players or {}):
        if pid == you.player_id:
            continue
        out.append(Action(ActionType.DIPLOMACY, {"with": pid}))
        if len(out) >= 2:
            break
    return out

# =============================
# Helpers
# =============================

def _player_hexes(state: GameState, pid: str) -> List[Hex]:
    return [hx for hx in state.map.hexes.values() if pid in hx.pieces]


def _is_explored_hex(hx: Optional[Hex]) -> bool:
    if not hx:
        return False
    explored = getattr(hx, "explored", None)
    if explored is None:
        # Treat missing data as explored only if the tile appears to be numbered.
        # Most ingestion pipelines mark unknown frontier placeholders with a
        # string id (e.g. "outer_frontier"). If the id looks numeric, assume
        # the hex has been flipped; otherwise require an explicit flag.
        hex_id = getattr(hx, "id", "") or ""
        return bool(str(hex_id).strip().isdigit())
    return bool(explored)

def _enemy_presence_in_hex(state: GameState, pid: str, hx: Optional[Hex]) -> int:
    if not hx:
        return 0
    count = 0
    for owner, p in hx.pieces.items():
        if owner == pid:
            continue
        count += int(p.starbase)
        for n in p.ships.values():
            count += int(n)
    return count

def _hex_value_key(hx: Hex) -> float:
    # Value proxy: number of uncolonized planets + monolith bonus
    planets = 0
    for pl in hx.planets:
        if pl.colonized_by is None:
            planets += 1
    return planets + (1.5 if hx.monolith else 0.0)

def _dominant_planet_color(hx: Hex) -> Tuple[Optional[str], int]:
    counts = {"yellow":0, "blue":0, "brown":0}
    for pl in hx.planets:
        if pl.colonized_by is None:
            t = pl.type.lower()
            if t.startswith("y"): counts["yellow"] += 1
            elif t.startswith("b"): counts["blue"] += 1
            elif t.startswith("p") or t.startswith("m"): counts["brown"] += 1
    color = max(counts, key=lambda k: counts[k]) if any(counts.values()) else None
    return (color, counts[color]) if color else (None, 0)


def _movable_ships(pieces: Pieces, *, single_ship: bool = False) -> Dict[str, int]:
    ships: Dict[str, int] = {}
    for cls, count in (pieces.ships or {}).items():
        if cls == "starbase":
            continue
        n = int(count or 0)
        if n <= 0:
            continue
        ships[cls] = n
    if not ships:
        return {}
    if not single_ship:
        return ships
    chosen = sorted(ships.keys())[0]
    return {chosen: 1}

def _tech_priority_key(name: str) -> float:
    s = name.lower()
    score = 0.0
    if any(k in s for k in ("plasma","positron","gauss","antimatter","ion")): score += 2.0
    if "drive" in s: score += 1.5
    if "shield" in s or "hull" in s: score += 1.2
    if "wormhole" in s: score += 1.5
    if "advanced" in s or "labs" in s or "mining" in s or "nanorobot" in s: score += 1.0
    return score

def _approx_tech_cost(name: str, known_count: int) -> int:
    s = name.lower()
    base = 3
    if "iii" in s: base = 7
    elif "ii" in s or "advanced" in s: base = 5
    elif "i" in s: base = 3
    # very rough scaling by known techs simulating track cost increases
    return max(2, base + min(2, known_count//4))

def _dedup_actions(actions: List[Action]) -> List[Action]:
    seen = set()
    out = []
    for a in actions:
        key = (a.type.value, _freeze(a.payload))
        if key in seen:
            continue
        seen.add(key)
        out.append(a)
    return out

def _freeze(obj: Any) -> Any:
    if isinstance(obj, dict):
        return tuple(sorted((k, _freeze(v)) for k,v in obj.items()))
    if isinstance(obj, list):
        return tuple(_freeze(v) for v in obj)
    return obj
===== FILE: eclipse_ai/scoring/__init__.py =====


"""Species-specific scoring helpers."""
from __future__ import annotations

from typing import Optional

from ..game_models import GameState, PlayerState
from .endgame import compute_endgame_vp, score_game
from .species import deathmoon_reputation_draws, unity_deathmoon_bonus

def unity_deathmoon_bonus(state: GameState, player: PlayerState) -> int:
    """Return the endgame VP bonus Unity receives for deployed Deathmoons."""
    if not player or not player.vp_bonuses:
        return 0
    per_deathmoon = player.vp_bonuses.get("endgame_per_deathmoon")
    if not per_deathmoon:
        return 0
    if not player.species_flags.get("starbase_minis_are_deathmoons"):
        return 0
    return int(per_deathmoon) * _count_deathmoons(state, player.player_id)


def deathmoon_reputation_draws(player: Optional[PlayerState]) -> int:
    """Number of reputation tiles opponents draw when destroying a Deathmoon."""
    if not player or not player.species_flags:
        return 0
    return int(player.species_flags.get("destroy_deathmoon_opponent_rep_draw", 0))


def _count_deathmoons(state: GameState, player_id: str) -> int:
    if not state.map or not state.map.hexes:
        return 0
    total = 0
    for hx in state.map.hexes.values():
        pieces = hx.pieces.get(player_id) if hx.pieces else None
        if not pieces:
            continue
        total += int(pieces.starbase or 0)
    return total


__all__ = [
    "compute_endgame_vp",
    "score_game",
    "unity_deathmoon_bonus",
    "deathmoon_reputation_draws",
]


===== FILE: eclipse_ai/scoring/endgame.py =====


"""Endgame scoring helpers for diplomacy and alliances."""
from __future__ import annotations

from typing import Any, Dict, Iterable, Mapping, Optional
from typing import Dict
from ..models.player_state import EvolutionTile, ReputationTile
from ..game_models import GameState, PlayerState
from ..data.constants import (
    ALLIANCE_TILE_BETRAYER_VP,
    ALLIANCE_TILE_FACEUP_VP,
    ANCIENT_KILL_VP,
    DISCOVERY_TILE_VP,
    MONOLITH_VP,
    TECH_TRACK_VP,
    TRAITOR_PENALTY,
)

def diplomacy_vp(player: PlayerState) -> int:
    if not player:
        return 0
    return sum(1 for active in player.ambassadors.values() if active)


def traitor_penalty(player: PlayerState) -> int:
    if not player:
        return 0
    return -2 if player.has_traitor else 0


def alliance_tile_vp(player: PlayerState) -> int:
    if not player:
        return 0
    if player.alliance_tile == "+2":
        return 2
    if player.alliance_tile == "-3":
        return -3
    return 0


def calculate_endgame_vp(state: GameState, player_id: str, base_vp: int = 0) -> int:
    player = state.players.get(player_id) if state else None
    if player is None:
        return base_vp
    total = base_vp
    total += diplomacy_vp(player)
    total += traitor_penalty(player)
    total += alliance_tile_vp(player)
    return total


def alliance_average_vp(state: GameState, totals: Dict[str, int]) -> Dict[str, float]:
    """Return the per-alliance average VP used for ranking comparisons."""
    if not state:
        return {}
    averages: Dict[str, float] = {}
    for alliance_id, alliance in state.alliances.items():
        if not alliance.members:
            continue
        member_scores = [totals.get(pid, 0) for pid in alliance.members]
        if not member_scores:
            continue
        averages[alliance_id] = sum(member_scores) / float(len(member_scores))
    return averages


def compute_endgame_vp(state: Any, player_id: str, modules: Optional[Mapping[str, Any]] = None) -> Dict[str, int]:
    """Compute the endgame VP breakdown for ``player_id``."""

    modules = modules or {}
    player = _get_player(state, player_id)
    if player is None:
        raise KeyError(f"Unknown player '{player_id}' in state")

    alliances_enabled = _module_enabled(modules, "alliances", "rotA_alliances")
    new_ancients_enabled = _module_enabled(modules, "new_ancients", "rotA_new_ancients")
    sor_enabled = _module_enabled(modules, "sor", "shadows_of_the_rift")

    vp_reputation = _reputation_vp(player)
    vp_ambassadors = int(getattr(player, "ambassadors", 0) or 0)
    vp_hexes = _hex_vp(state, player)
    vp_discoveries = int(getattr(player, "discoveries_kept", 0) or 0) * DISCOVERY_TILE_VP
    vp_monoliths = int(getattr(player, "monolith_count", 0) or 0) * MONOLITH_VP
    vp_tech_tracks = _tech_track_vp(player)
    vp_traitor = TRAITOR_PENALTY if bool(getattr(player, "has_traitor", False)) else 0
    vp_alliance = _alliance_tile_vp(player) if alliances_enabled else 0
    vp_ancients = _ancient_kill_vp(player) if new_ancients_enabled else 0
    vp_evolution = _evolution_vp(state, player) if sor_enabled else 0

    total = (
        vp_reputation
        + vp_ambassadors
        + vp_hexes
        + vp_discoveries
        + vp_monoliths
        + vp_tech_tracks
        + vp_traitor
        + vp_alliance
        + vp_ancients
        + vp_evolution
    )

    return {
        "vp_reputation": vp_reputation,
        "vp_ambassadors": vp_ambassadors,
        "vp_hexes": vp_hexes,
        "vp_discoveries": vp_discoveries,
        "vp_monoliths": vp_monoliths,
        "vp_tech_tracks": vp_tech_tracks,
        "vp_traitor": vp_traitor,
        "vp_rise_alliance_tile": vp_alliance,
        "vp_rise_ancient_kills": vp_ancients,
        "vp_sor_evolution": vp_evolution,
        "total": total,
    }


def score_game(state: Any, modules: Optional[Mapping[str, Any]] = None) -> Dict[str, Any]:
    """Return per-player endgame VP breakdowns and alliance summaries."""

    modules = modules or {}
    players: Mapping[str, Any] = getattr(state, "players", {})
    if not isinstance(players, Mapping):
        raise TypeError("state.players must be a mapping of player_id -> PlayerState")

    player_breakdowns: Dict[str, Dict[str, int]] = {}
    for player_id in players:
        player_breakdowns[player_id] = compute_endgame_vp(state, player_id, modules)

    result: Dict[str, Any] = {"players": player_breakdowns}

    if _module_enabled(modules, "alliances", "rotA_alliances"):
        teams = _extract_alliance_teams(state, players)
        if teams:
            totals = {pid: data["total"] for pid, data in player_breakdowns.items()}
            team_totals: Dict[str, int] = {}
            team_average: Dict[str, int] = {}
            for team_id, members in teams.items():
                team_total = sum(totals.get(pid, 0) for pid in members)
                if not members:
                    continue
                team_totals[team_id] = team_total
                team_average[team_id] = team_total // len(members)
            result["alliances"] = {"team_totals": team_totals, "team_average": team_average}

    return result


def _module_enabled(modules: Mapping[str, Any], *keys: str) -> bool:
    return any(bool(modules.get(key)) for key in keys)


def _get_player(state: Any, player_id: str) -> Optional[Any]:
    players = getattr(state, "players", None)
    if isinstance(players, Mapping):
        return players.get(player_id)
    return None


def _reputation_vp(player: Any) -> int:
    tiles: Iterable[Any] = getattr(player, "reputation_kept", []) or []
    total = 0
    for tile in tiles:
        if tile is None:
            continue
        if isinstance(tile, ReputationTile):
            if tile.is_special:
                continue
            total += int(tile.value)
            continue
        if isinstance(tile, Mapping):
            if tile.get("is_special"):
                continue
            value = tile.get("value", 0)
            total += int(value)
            continue
        value = getattr(tile, "value", tile)
        flag = getattr(tile, "is_special", False)
        if flag:
            continue
        total += int(value)
    return total


def _hex_vp(state: Any, player: Any) -> int:
    hexes = _get_hex_collection(state)
    if not hexes:
        return 0

    player_id = getattr(player, "player_id", None)
    total = 0
    for hex_id in getattr(player, "controlled_hex_ids", []) or []:
        hex_obj = hexes.get(hex_id)
        if hex_obj is None:
            continue
        controller = getattr(hex_obj, "controller", getattr(hex_obj, "controlled_by", None))
        if controller is not None and player_id is not None and controller != player_id:
            continue
        total += int(getattr(hex_obj, "vp_value", 0) or 0)
    return total


def _get_hex_collection(state: Any) -> Mapping[str, Any]:
    map_state = getattr(state, "map", None)
    if map_state is not None:
        hexes = getattr(map_state, "hexes", None)
        if isinstance(hexes, Mapping):
            return hexes
    hexes = getattr(state, "hexes", None)
    if isinstance(hexes, Mapping):
        return hexes
    return {}


def _tech_track_vp(player: Any) -> int:
    counts: Mapping[str, Any] = getattr(player, "tech_track_counts", {}) or {}

    def _vp_from_track(count: Any) -> int:
        try:
            value = int(count)
        except (TypeError, ValueError):
            return 0
        value = min(value, 7)
        return int(TECH_TRACK_VP.get(value, 0))

    return sum(_vp_from_track(count) for count in counts.values())


def _alliance_tile_vp(player: Any) -> int:
    tile = getattr(player, "alliance_tile", None)
    if tile is None:
        return 0
    normalized = str(tile).lower()
    if normalized in {"faceup", "face-up", "face_up", "+2"}:
        return ALLIANCE_TILE_FACEUP_VP
    if normalized in {"betrayer", "-3"}:
        return ALLIANCE_TILE_BETRAYER_VP
    return 0


def _ancient_kill_vp(player: Any) -> int:
    tokens: Mapping[str, Any] = getattr(player, "ancient_kill_tokens", {}) or {}
    total = 0
    for key in ("cruiser", "dreadnought"):
        try:
            total += int(tokens.get(key, 0))
        except (TypeError, ValueError):
            continue
    return total * ANCIENT_KILL_VP


def _evolution_vp(state: Any, player: Any) -> int:
    tiles: Iterable[Any] = getattr(player, "evolution_tiles", []) or []
    if not tiles:
        return 0

    total = 0
    for tile in tiles:
        key, value = _evolution_tile_fields(tile)
        handler = _EVOLUTION_HANDLERS.get(key)
        if handler is None:
            total += int(value)
        else:
            total += handler(state, player, int(value))
    return total


def _evolution_tile_fields(tile: Any) -> tuple[Optional[str], int]:
    if isinstance(tile, EvolutionTile):
        return tile.endgame_key, int(tile.value)
    if isinstance(tile, Mapping):
        key = tile.get("endgame_key") or tile.get("key")
        value = tile.get("value", tile.get("endgame_value", 0))
        return key, int(value)
    key = getattr(tile, "endgame_key", None)
    value = getattr(tile, "value", 0)
    try:
        value = int(value)
    except (TypeError, ValueError):
        value = 0
    return key, value


def _controlled_hex_count(player: Any) -> int:
    return len(getattr(player, "controlled_hex_ids", []) or [])


def _artifact_count(player: Any) -> int:
    try:
        return int(getattr(player, "artifacts_controlled", 0) or 0)
    except (TypeError, ValueError):
        return 0


def _has_galactic_center(state: Any, player: Any) -> bool:
    flag = getattr(player, "controls_galactic_center", None)
    if flag is not None:
        return bool(flag)
    # Fall back to checking whether a tracked hex is explicitly named.
    for hex_id in getattr(player, "controlled_hex_ids", []) or []:
        if str(hex_id).lower() in {"galactic_center", "galactic-centre", "gc"}:
            return True
    return False


def _per_monolith(_: Any, player: Any, value: int) -> int:
    try:
        return value * int(getattr(player, "monolith_count", 0) or 0)
    except (TypeError, ValueError):
        return 0


def _per_two_hex(_: Any, player: Any, value: int) -> int:
    return value * (_controlled_hex_count(player) // 2)


def _per_artifact(_: Any, player: Any, value: int) -> int:
    return value * _artifact_count(player)


def _galactic_center(state: Any, player: Any, value: int) -> int:
    return value if _has_galactic_center(state, player) else 0


_EVOLUTION_HANDLERS: Dict[Optional[str], Any] = {
    "per_monolith": _per_monolith,
    "per_two_hex": _per_two_hex,
    "per_artifact": _per_artifact,
    "galactic_center": _galactic_center,
}


def _extract_alliance_teams(state: Any, players: Mapping[str, Any]) -> Dict[str, list[str]]:
    candidate_attrs = ("alliance_teams", "alliances", "teams")
    for attr in candidate_attrs:
        data = getattr(state, attr, None)
        if isinstance(data, Mapping):
            teams: Dict[str, list[str]] = {}
            for team_id, members in data.items():
                if isinstance(members, Iterable) and not isinstance(members, (str, bytes)):
                    teams[str(team_id)] = [str(pid) for pid in members]
            if teams:
                return teams
    teams: Dict[str, list[str]] = {}
    for pid, player in players.items():
        team_id = (
            getattr(player, "alliance_team", None)
            or getattr(player, "team", None)
            or getattr(player, "team_id", None)
        )
        if team_id is None:
            continue
        teams.setdefault(str(team_id), []).append(str(pid))
    return teams
  
  
  __all__ = [
    "diplomacy_vp",
    "traitor_penalty",
    "alliance_tile_vp",
    "calculate_endgame_vp",
    "alliance_average_vp",
]

===== FILE: eclipse_ai/scoring/species.py =====

"""Species-specific scoring helpers."""
from __future__ import annotations

from typing import Optional

from ..game_models import GameState, PlayerState


def unity_deathmoon_bonus(state: GameState, player: PlayerState) -> int:
    """Return the endgame VP bonus Unity receives for deployed Deathmoons."""
    if not player or not player.vp_bonuses:
        return 0
    per_deathmoon = player.vp_bonuses.get("endgame_per_deathmoon")
    if not per_deathmoon:
        return 0
    if not player.species_flags.get("starbase_minis_are_deathmoons"):
        return 0
    return int(per_deathmoon) * _count_deathmoons(state, player.player_id)


def deathmoon_reputation_draws(player: Optional[PlayerState]) -> int:
    """Number of reputation tiles opponents draw when destroying a Deathmoon."""
    if not player or not player.species_flags:
        return 0
    return int(player.species_flags.get("destroy_deathmoon_opponent_rep_draw", 0))


def _count_deathmoons(state: GameState, player_id: str) -> int:
    if not state.map or not state.map.hexes:
        return 0
    total = 0
    for hx in state.map.hexes.values():
        pieces = hx.pieces.get(player_id) if hx.pieces else None
        if not pieces:
            continue
        total += int(pieces.starbase or 0)
    return total

===== FILE: eclipse_ai/search_policy.py =====

from __future__ import annotations
from dataclasses import dataclass, field
from typing import Dict, Any, List, Optional, Tuple, Sequence
import math, random, copy

from .game_models import GameState, Action, Score, ActionType, PlayerState, Hex, Pieces, Planet, ShipDesign
from .alliances import ship_presence
from .rules_engine import legal_actions
from .evaluator import evaluate_action
from .movement import LEGAL_CONNECTION_TYPES, classify_connection, max_ship_activations_per_action
from .technology import do_research, ResearchError, load_tech_definitions
from .pathing import compute_connectivity

# =============================
# Public data structures
# =============================

@dataclass
class PlanStep:
    action: Action
    score: Score

@dataclass
class Plan:
    steps: List[PlanStep] = field(default_factory=list)
    total_score: float = 0.0
    risk: float = 0.0
    state_summary: Dict[str, Any] = field(default_factory=dict)
    result_state: Optional[GameState] = None

# =============================
# MCTS with P-UCT priors
# =============================

class MCTSPlanner:
    def __init__(
        self,
        simulations: int = 400,
        c_puct: float = 1.4,
        discount: float = 0.95,
        rollout_depth: int = 2,
        risk_aversion: float = 0.25,
        dirichlet_alpha: float = 0.3,
        dirichlet_epsilon: float = 0.25,
        seed: Optional[int] = None,
    ):
        self.simulations = simulations
        self.c = c_puct
        self.discount = discount
        self.rollout_depth = rollout_depth
        self.risk_aversion = risk_aversion
        self.dirichlet_alpha = dirichlet_alpha
        self.dirichlet_epsilon = dirichlet_epsilon
        self.rng = random.Random(seed)

    # ---- public API ----

    def plan(self, state: GameState, player_id: str, depth: int = 2, top_k: int = 5) -> List[Plan]:
        """
        Run MCTS from the given state for a single player's turn horizon.
        Opponents are not simulated; this is a myopic planner for quick advice.
        """
        # Refresh metadata on the live state so downstream consumers can inspect
        # the new game-state hints (possible actions, mobility flags, reachability).
        base_actions = legal_actions(state, player_id)
        self._gather_metadata(state, player_id, allowed_actions=base_actions)
        root = _Node(state=copy.deepcopy(state), player_id=player_id)

        # Expand root once to create priors
        self._expand(root)

        # Add Dirichlet noise at root for exploration
        if root.children:
            noise = _dirichlet(self.rng, len(root.children), self.dirichlet_alpha)
            for i, child in enumerate(root.children):
                child.P = (1 - self.dirichlet_epsilon) * child.P + self.dirichlet_epsilon * noise[i]

        for _ in range(self.simulations):
            node = root
            path: List[_Node] = [node]

            # Selection
            while node.expanded and node.children:
                node = self._select_child(node)
                path.append(node)

            # Expansion
            if not node.expanded:
                self._expand(node)

            # Rollout / Value
            value = self._evaluate_leaf(node)

            # Backpropagate
            self._backprop(path, value)

        # Extract top-k plans from root children by visit count, then by Q
        children = sorted(root.children, key=lambda n: (n.N, n.Q), reverse=True)
        validated: List[Plan] = []
        for child in children:
            actions = self._collect_action_sequence(child, max_depth=depth)
            if not actions:
                continue
            plan = self._simulate_plan(state, player_id, actions, enforce_legality=True)
            if plan is None:
                continue
            validated.append(plan)
            if len(validated) >= top_k:
                break

        if not validated:
            # Fallback: single-ply ranking using the already-computed legal actions.
            validated = self._fallback_plans(state, player_id, base_actions, top_k)

        return validated[:top_k]

    # ---- core steps ----

    def _expand(self, node: '_Node'):
        if node.expanded:
            return
        node.expanded = True
        state = node.state
        acts = legal_actions(state, node.player_id)
        if not acts:
            return

        # Evaluate actions for priors
        scores: List[Score] = [evaluate_action(state, a) for a in acts]
        # Convert to positive priors via softmax on risk-adjusted value estimates
        vals = [self._value_from_score(sc) for sc in scores]
        priors = _softmax(vals)

        for a, sc, p in zip(acts, scores, priors):
            next_state = _forward_model(state, node.player_id, a)
            child = _Node(
                state=next_state,
                player_id=node.player_id,  # same player; single-turn planner
                parent=node,
                action=a,
                prior_score=sc,
                P=p
            )
            node.children.append(child)

    def _select_child(self, node: '_Node') -> '_Node':
        # P-UCT
        total_N = max(1, node.N)
        best, best_score = None, -1e30
        for child in node.children:
            u = self.c * child.P * math.sqrt(total_N) / (1 + child.n())
            q = child.Q
            score = q + u
            if score > best_score:
                best, best_score = child, score
        return best if best is not None else node.children[0]

    def _evaluate_leaf(self, node: '_Node') -> float:
        # If leaf has no actions, value 0
        if not node.children:
            # Use immediate evaluation if available
            if node.prior_score is not None:
                return self._value_from_score(node.prior_score)
            return 0.0

        # Rollout a short random-improve policy
        value = 0.0
        discount = 1.0
        curr = node
        for d in range(self.rollout_depth):
            if not curr.children:
                break
            # epsilon-greedy on Q + prior to avoid getting stuck
            if self.rng.random() < 0.2:
                curr = self.rng.choice(curr.children)
            else:
                curr = max(curr.children, key=lambda c: c.Q + 0.5*c.P)
            if curr.prior_score is None:
                sc = evaluate_action(curr.state, curr.action)
                curr.prior_score = sc
            value += discount * self._value_from_score(curr.prior_score)
            discount *= self.discount
            # ensure expanded for next step
            if not curr.expanded:
                self._expand(curr)

        return value

    def _backprop(self, path: List['_Node'], value: float):
        for node in path:
            node.W += value
            node.N += 1
            node.Q = node.W / node.N

    # ---- plan extraction ----

    def _collect_action_sequence(self, node: '_Node', max_depth: int = 2) -> List[Action]:
        actions: List[Action] = []
        curr = node
        for _ in range(max_depth):
            if curr.action is None:
                break
            actions.append(curr.action)
            if not curr.children:
                break
            curr = max(curr.children, key=lambda c: c.Q)
        return actions

    def _simulate_plan(
        self,
        base_state: GameState,
        player_id: str,
        actions: Sequence[Action],
        *,
        enforce_legality: bool = False,
    ) -> Optional[Plan]:
        working = copy.deepcopy(base_state)
        steps: List[PlanStep] = []
        total = 0.0
        disc = 1.0
        risks: List[float] = []

        allowed = legal_actions(working, player_id)
        meta_before = self._gather_metadata(working, player_id, allowed_actions=allowed)

        if not actions:
            summary = self._extract_state_summary(working, player_id)
            return Plan(steps=[], total_score=0.0, risk=0.0, state_summary=summary, result_state=working)

        for action in actions:
            if enforce_legality and action not in allowed:
                return None

            score = evaluate_action(working, action)
            steps.append(PlanStep(action, score))
            total += disc * float(score.expected_vp)
            risks.append(float(score.risk))

            working = _forward_model(working, player_id, action)
            allowed = legal_actions(working, player_id)
            meta_after = self._gather_metadata(working, player_id, allowed_actions=allowed)

            total += disc * self._mobility_bonus(meta_after)
            total += disc * self._connectivity_bonus(meta_before, meta_after)

            meta_before = meta_after
            disc *= self.discount

        summary = self._extract_state_summary(working, player_id)
        avg_risk = sum(risks) / len(risks) if risks else 0.0
        return Plan(steps=steps, total_score=total, risk=avg_risk, state_summary=summary, result_state=working)

    def _fallback_plans(
        self,
        state: GameState,
        player_id: str,
        base_actions: Sequence[Action],
        top_k: int,
    ) -> List[Plan]:
        out: List[Plan] = []
        for action in base_actions:
            plan = self._simulate_plan(state, player_id, [action], enforce_legality=True)
            if plan is None:
                continue
            out.append(plan)
            if len(out) >= top_k:
                break
        if not out:
            # ensure at least a pass plan exists
            plan = self._simulate_plan(state, player_id, [], enforce_legality=True)
            if plan is not None:
                out.append(plan)
        return out

    def _gather_metadata(
        self,
        state: GameState,
        player_id: str,
        *,
        allowed_actions: Optional[Sequence[Action]] = None,
    ) -> Dict[str, Any]:
        if allowed_actions is None:
            allowed_actions = legal_actions(state, player_id)
        try:
            reach = compute_connectivity(state, player_id)
            state.connectivity_metrics[player_id] = {
                "reachable": sorted(reach),
                "count": len(reach),
            }
            reach_count = len(reach)
        except Exception:
            reach_count = 0

        possible_actions = set(getattr(state, "possible_actions", set()) or set())
        return {
            "possible_actions": possible_actions,
            "can_move_ships": bool(getattr(state, "can_move_ships", False)),
            "can_explore": bool(getattr(state, "can_explore", False)),
            "connectivity_count": reach_count,
        }

    def _mobility_bonus(self, meta: Dict[str, Any]) -> float:
        bonus = 0.0
        if meta.get("can_move_ships"):
            bonus += 0.05
        if meta.get("can_explore"):
            bonus += 0.04
        possible_actions = meta.get("possible_actions") or set()
        bonus += 0.01 * min(6, len(possible_actions))
        reach = int(meta.get("connectivity_count", 0) or 0)
        bonus += 0.02 * min(5, reach) / 5.0
        return bonus

    def _connectivity_bonus(self, before: Dict[str, Any], after: Dict[str, Any]) -> float:
        b = int(before.get("connectivity_count", 0) or 0)
        a = int(after.get("connectivity_count", 0) or 0)
        delta = a - b
        if delta == 0:
            return 0.0
        return max(-0.5, min(0.5, 0.05 * delta))

    def _extract_state_summary(self, state: GameState, player_id: str) -> Dict[str, Any]:
        possible_actions = getattr(state, "possible_actions", set()) or set()
        actions_list = []
        for act in possible_actions:
            try:
                actions_list.append(act.value)  # type: ignore[attr-defined]
            except Exception:
                actions_list.append(str(act))
        metrics = getattr(state, "connectivity_metrics", {}).get(player_id, {}) if getattr(state, "connectivity_metrics", None) else {}
        summary: Dict[str, Any] = {
            "possible_actions": sorted(actions_list),
            "can_explore": bool(getattr(state, "can_explore", False)),
            "can_move_ships": bool(getattr(state, "can_move_ships", False)),
        }
        if metrics:
            summary["connectivity"] = {
                "count": int(metrics.get("count", 0) or 0),
                "reachable": list(metrics.get("reachable", [])),
            }
        return summary

    # ---- helpers ----

    def _value_from_score(self, sc: Score) -> float:
        # Risk-adjusted value
        return float(sc.expected_vp) - self.risk_aversion * float(sc.risk)

# =============================
# Node
# =============================

@dataclass
class _Node:
    state: GameState
    player_id: str
    parent: Optional['_Node'] = None
    action: Optional[Action] = None
    prior_score: Optional[Score] = None  # evaluation of action leading to this node
    P: float = 0.0                        # prior
    W: float = 0.0                        # total value
    N: int = 0                            # visit count
    Q: float = 0.0                        # mean value
    children: List['_Node'] = field(default_factory=list)
    expanded: bool = False

    def n(self) -> int:
        return self.N

# =============================
# Forward model (lightweight)
# =============================

# Local cost table to keep forward model self-contained
_SHIP_COSTS = {"interceptor":2, "cruiser":3, "dreadnought":5}
_STARBASE_COST = 4
_SCIENCE_COST_BASE = 3  # rough


def _refresh_connectivity(state: GameState, pid: str) -> None:
    try:
        reach = compute_connectivity(state, pid)
        state.connectivity_metrics[pid] = {
            "reachable": sorted(reach),
            "count": len(reach),
        }
    except Exception:
        pass

def _forward_model(state: GameState, pid: str, action: Action) -> GameState:
    """Very small deterministic forward model sufficient for short planning.
    Applies optimistic but resource-aware state changes. Non-destructive via deepcopy.
    """
    s = copy.deepcopy(state)

    # Safety checks
    if pid not in s.players:
        return s
    you = s.players[pid]

    t = action.type
    p = action.payload or {}

    if t == ActionType.PASS:
        # Terminal in our single-player horizon; no change
        _refresh_connectivity(s, pid)
        return s

    if t == ActionType.RESEARCH:
        tech = str(p.get("tech", ""))
        if tech:
            if not s.tech_definitions:
                s.tech_definitions = load_tech_definitions()
            try:
                do_research(s, you, tech)
            except ResearchError:
                pass
        _refresh_connectivity(s, pid)
        return s

    if t == ActionType.BUILD:
        hex_id = p.get("hex")
        ships: Dict[str,int] = dict(p.get("ships", {}))
        starbase = int(p.get("starbase", 0))
        hx = s.map.hexes.get(hex_id)
        if hx is None:
            # create a placeholder hex if needed
            hx = Hex(id=str(hex_id), ring=2, wormholes=[], planets=[], pieces={})
            s.map.hexes[hx.id] = hx
        if pid not in hx.pieces:
            hx.pieces[pid] = Pieces(ships={}, starbase=0, discs=hx.pieces.get(pid, Pieces()).discs if pid in hx.pieces else 0, cubes={})

        # Apply ship builds constrained by materials
        mats = you.resources.materials
        for cls, n in ships.items():
            for _ in range(int(n)):
                c = _SHIP_COSTS.get(cls, 3)
                if mats >= c:
                    mats -= c
                    hx.pieces[pid].ships[cls] = hx.pieces[pid].ships.get(cls, 0) + 1
        if starbase > 0 and mats >= _STARBASE_COST:
            mats -= _STARBASE_COST
            hx.pieces[pid].starbase += 1
        you.resources.materials = mats
        _refresh_connectivity(s, pid)
        return s

    if t == ActionType.MOVE:
        try:
            _apply_move_action(s, pid, p)
        except ValueError:
            _refresh_connectivity(state, pid)
            return state  # illegal move payloads are ignored in the forward model
        _refresh_connectivity(s, pid)
        return s

    if t == ActionType.EXPLORE:
        # Optimistic: reduce bag mass slightly to reflect drawing; do not place new hex
        ring = int(p.get("ring", 2))
        bag_key = f"R{ring}"
        if bag_key in s.bags:
            # Reduce the heaviest category by 1 as a placeholder draw
            bag = s.bags[bag_key]
            if bag:
                key = max(bag, key=lambda k: bag[k])
                if bag[key] > 0:
                    bag[key] -= 1
        _refresh_connectivity(s, pid)
        return s

    if t == ActionType.INFLUENCE:
        # Adjust income proxy via cubes; not modeling discs inventory
        hex_id = p.get("hex")
        inc = p.get("income_delta", {})
        # store a marker by adding cubes to the hex
        hx = s.map.hexes.get(hex_id)
        if hx:
            if pid not in hx.pieces:
                hx.pieces[pid] = Pieces(ships={}, starbase=0, discs=1, cubes={})
            for color, dv in inc.items():
                key = {"yellow":"y","blue":"b","brown":"p"}.get(color, "y")
                hx.pieces[pid].cubes[key] = hx.pieces[pid].cubes.get(key, 0) + max(0, int(dv))
        _refresh_connectivity(s, pid)
        return s

    if t == ActionType.DIPLOMACY:
        # Store alliance in player state
        target = p.get("with")
        if target:
            you.diplomacy[target] = "ally"
        _refresh_connectivity(s, pid)
        return s

    if t == ActionType.UPGRADE:
        # Apply incremental design changes
        apply = p.get("apply", {})
        for cls, mods in apply.items():
            sd = you.ship_designs.get(cls, ShipDesign())
            for k, dv in mods.items():
                if hasattr(sd, k):
                    setattr(sd, k, max(0, getattr(sd, k) + int(dv)))
            you.ship_designs[cls] = sd
        _refresh_connectivity(s, pid)
        return s

    # Unknown action -> no-op
    _refresh_connectivity(s, pid)
    return s

# =============================
# Utilities
# =============================

def _softmax(xs: List[float], temp: float = 1.0) -> List[float]:
    if not xs:
        return []
    m = max(xs)
    exps = [math.exp((x - m)/max(1e-6, temp)) for x in xs]
    s = sum(exps)
    if s <= 0:
        return [1.0/len(xs)] * len(xs)
    return [e/s for e in exps]

def _dirichlet(rng: random.Random, k: int, alpha: float) -> List[float]:
    # Sample Dirichlet(k, alpha)
    # Use gamma sampling
    samples = []
    for _ in range(k):
        # Gamma(alpha, 1) via sum of exponentials for small alpha fallback
        # Use Python's gammavariate
        samples.append(rng.gammavariate(alpha, 1.0))
    s = sum(samples) or 1.0
    return [x/s for x in samples]


# =============================
# Movement helpers and executor
# =============================

def _apply_move_action(state: GameState, pid: str, payload: Dict[str, Any]) -> None:
    """Validate and apply a MOVE action with full Eclipse legality checks."""
    working = copy.deepcopy(state)

    activations = list(payload.get("activations", []))
    if not activations:
        raise ValueError("MOVE requires activations payload")

    player = working.players.get(pid)
    if player is None:
        raise ValueError("Unknown player for MOVE")

    is_reaction = bool(payload.get("is_reaction") or payload.get("reaction"))
    max_activations = max_ship_activations_per_action(player, is_reaction=is_reaction)
    if len(activations) > max_activations:
        raise ValueError("Too many ship activations for this action")

    for activation in activations:
        _execute_activation(working, player, activation, is_reaction=is_reaction)

    # Commit the simulated changes back to the real state only after validation succeeds.
    state.players = working.players
    state.map = working.map


def _execute_activation(
    state: GameState,
    player: PlayerState,
    activation: Dict[str, Any],
    *,
    is_reaction: bool = False,
) -> None:
    ship_class = str(activation.get("ship_class", ""))
    if not ship_class:
        raise ValueError("Activation missing ship class")
    start_hex_id = str(activation.get("from", ""))
    if not start_hex_id:
        raise ValueError("Activation missing starting hex")

    path = list(activation.get("path", []))
    if not path:
        raise ValueError("Activation requires explicit path including start")
    if path[0] != start_hex_id:
        raise ValueError("Path must begin at starting hex")

    count = int(activation.get("count", 1))
    if count <= 0:
        raise ValueError("Activation must move at least one ship")
    if is_reaction and count != 1:
        raise ValueError("Reaction MOVE may activate exactly one ship")

    for _ in range(count):
        _activate_single_ship(state, player, ship_class, path, activation)


def _activate_single_ship(state: GameState, player: PlayerState, ship_class: str, path: List[str], activation: Dict[str, Any]) -> None:
    you = player.player_id
    current_hex = _require_hex(state, path[0])
    pieces = current_hex.pieces.get(you)
    if pieces is None or pieces.ships.get(ship_class, 0) <= 0:
        raise ValueError("No ship of requested class in starting hex")

    friendly_start, enemy_start = ship_presence(state, current_hex, you)
    pinned_at_start = enemy_start > 0

    design = player.ship_designs.get(ship_class, ShipDesign())
    if ship_class == "starbase":
        if len(path) > 1:
            raise ValueError("Starbases cannot move")
        return

    movement_points = design.movement_value()
    has_jump = bool(design.has_jump_drive)
    if len(path) > 1 and movement_points <= 0 and not has_jump:
        if ship_class in {"interceptor", "cruiser", "dreadnought"}:
            raise ValueError("Ship lacks drives and cannot move")

    bay_payload = activation.get("bay") if design.interceptor_bays > 0 else None
    carried_interceptors = 0
    if bay_payload:
        carried_interceptors = int(bay_payload.get("interceptors", 0))
        if carried_interceptors < 0:
            raise ValueError("Cannot load negative interceptors")
        capacity = min(2, design.interceptor_bays)
        if carried_interceptors > capacity:
            raise ValueError("Interceptor Bay capacity exceeded")
        available = pieces.ships.get("interceptor", 0)
        if carried_interceptors > available:
            raise ValueError("Not enough interceptors to load into bay")

    # Enforce pinning when leaving the starting hex, including any interceptors we plan to carry.
    if pinned_at_start:
        activation.setdefault("pinned", True)
    _enforce_exit_pinning(state, current_hex, you, 1 + carried_interceptors)

    if carried_interceptors:
        _remove_ships_from_hex(current_hex, you, "interceptor", carried_interceptors)

    jump_used = False
    steps_remaining = movement_points
    current_hex_id = path[0]

    for idx, next_hex_id in enumerate(path[1:], start=1):
        next_hex = _require_hex(state, next_hex_id)
        if not next_hex.explored:
            raise ValueError("Cannot move into unexplored hex")

        src_hex = _require_hex(state, current_hex_id)
        if src_hex.has_gcds:
            raise ValueError("GCDS blocks movement through the Galactic Center")

        connection_type = classify_connection(
            state,
            player,
            current_hex_id,
            next_hex_id,
            ship_design=design,
            ship_class=ship_class,
        )
        if connection_type not in LEGAL_CONNECTION_TYPES:
            raise ValueError("No legal connection between hexes")

        if connection_type == "jump":
            if not has_jump or jump_used:
                raise ValueError("Jump Drive already used this activation")
            jump_used = True
        else:
            if steps_remaining <= 0:
                raise ValueError("Movement exceeds drive allowance")
            steps_remaining -= 1

        # Leaving current hex after validating movement points.
        _enforce_exit_pinning(state, src_hex, you, 1)
        _move_ship_between_hexes(state, you, ship_class, current_hex_id, next_hex_id)

        dst_hex = _require_hex(state, next_hex_id)
        enemy_in_dst = _count_enemy_ships(state, dst_hex, you)
        if idx < len(path) - 1:
            if dst_hex.has_gcds:
                raise ValueError("Cannot move through the Galactic Center while GCDS is active")
            if enemy_in_dst > 0:
                friendly_total = _count_friendly_ships(state, dst_hex, you)
                if friendly_total <= enemy_in_dst:
                    raise ValueError("Pinned upon entering contested hex")

        current_hex_id = next_hex_id

    # Re-add any interceptors transported in the bay to the final destination.
    if carried_interceptors:
        dest_hex = _require_hex(state, current_hex_id)
        dest_pieces = dest_hex.pieces.setdefault(you, Pieces())
        dest_pieces.ships["interceptor"] = dest_pieces.ships.get("interceptor", 0) + carried_interceptors


def _require_hex(state: GameState, hex_id: str) -> Hex:
    hx = state.map.hexes.get(hex_id)
    if hx is None:
        raise ValueError(f"Hex {hex_id} is not on the map")
    return hx


def _move_ship_between_hexes(state: GameState, pid: str, ship_class: str, src_id: str, dst_id: str) -> None:
    src_hex = _require_hex(state, src_id)
    dst_hex = _require_hex(state, dst_id)
    _remove_ships_from_hex(src_hex, pid, ship_class, 1)
    dst_pieces = dst_hex.pieces.setdefault(pid, Pieces())
    dst_pieces.ships[ship_class] = dst_pieces.ships.get(ship_class, 0) + 1


def _remove_ships_from_hex(hex_obj: Hex, pid: str, ship_class: str, count: int) -> None:
    if count <= 0:
        return
    pieces = hex_obj.pieces.get(pid)
    if pieces is None:
        raise ValueError("Player has no ships to remove")
    have = pieces.ships.get(ship_class, 0)
    if have < count:
        raise ValueError("Attempting to move more ships than present")
    pieces.ships[ship_class] = have - count
    if pieces.ships[ship_class] <= 0:
        del pieces.ships[ship_class]


def _count_enemy_ships(state: GameState, hex_obj: Hex, pid: str) -> int:
    if not hex_obj:
        return 0
    _, enemy = ship_presence(state, hex_obj, pid)
    return enemy


def _count_friendly_ships(state: GameState, hex_obj: Hex, pid: str) -> int:
    if not hex_obj:
        return 0
    friendly, _ = ship_presence(state, hex_obj, pid)
    return friendly


def _enforce_exit_pinning(state: GameState, hex_obj: Hex, pid: str, leaving: int) -> None:
    enemy = _count_enemy_ships(state, hex_obj, pid)
    if enemy <= 0:
        return
    friendly = _count_friendly_ships(state, hex_obj, pid)
    if friendly - leaving < enemy:
        raise ValueError("Cannot leave contested hex without leaving pinned ships")

===== FILE: eclipse_ai/setup.py =====

"""Game setup helpers for applying species configuration to players."""
from __future__ import annotations

from typing import Mapping, Iterable, Optional, Dict, Any

from .game_models import GameState, PlayerState, Pieces
from .species_data import SpeciesConfig, get_species
from .state_assembler import _initialise_player_state


def apply_species_setup(state: GameState, species_by_player: Mapping[str, str]) -> None:
    """Apply species configuration data to the given players in ``state``.

    The helper normalises player technology lists, applies starting discs and
    resources, and installs species-specific override flags so downstream rules
    modules can reason about faction abilities.
    """
    if not state or not species_by_player:
        return
    for player_id, species_id in species_by_player.items():
        player = state.players.get(player_id) if state.players else None
        if not player:
            continue
        config = get_species(species_id)
        _apply_species_to_player(state, player, config)


def _apply_species_to_player(state: GameState, player: PlayerState, config: SpeciesConfig) -> None:
    raw = dict(config.raw)
    player.species_id = config.species_id

    _apply_starting_resources(player, raw.get("starting_resources", {}))
    _apply_starting_discs(player, raw.get("starting_discs_delta"))
    _apply_starting_techs(state, player, raw.get("starting_techs", []), raw.get("rare_techs_starting", []))
    _apply_starting_ships(state, player, raw.get("starting_ships", {}))
    _apply_starting_structures(state, player, raw.get("starting_structures", {}))

    player.action_overrides = dict(raw.get("action_overrides", {}))
    player.build_overrides = dict(raw.get("build_overrides", {}))
    player.explore_overrides = dict(raw.get("explore_overrides", {}))
    player.move_overrides = dict(raw.get("move_overrides", {}))
    player.cannot_build = set(raw.get("cannot_build", []))
    player.vp_bonuses = dict(raw.get("vp_bonuses", {}))

    special_rules = dict(raw.get("special_rules", {}))
    player.species_flags = special_rules
    _apply_special_resources(player, special_rules)

    _initialise_player_state(player, state.tech_definitions)


def _apply_starting_resources(player: PlayerState, resources: Dict[str, Any]) -> None:
    if not resources:
        return
    for key in ("money", "science", "materials"):
        value = resources.get(key)
        if value is None:
            continue
        setattr(player.resources, key, int(value))


def _apply_starting_discs(player: PlayerState, delta: Optional[Any]) -> None:
    if delta is None:
        return
    try:
        player.influence_discs = int(player.influence_discs or 0) + int(delta)
    except (TypeError, ValueError):
        pass


def _apply_starting_techs(state: GameState, player: PlayerState, techs: Iterable[str], rare_techs: Iterable[str]) -> None:
    current = set(player.known_techs or [])
    for tech in techs:
        if tech and tech not in current:
            player.known_techs.append(tech)
            current.add(tech)
    for rare in rare_techs:
        if rare and rare not in current:
            player.known_techs.append(rare)
            current.add(rare)
        _remove_tech_from_supply(state, rare)


def _apply_starting_ships(state: GameState, player: PlayerState, layout: Dict[str, Dict[str, Any]]) -> None:
    if not layout:
        return
    home = _find_home_hex(state, player.player_id)
    if home is None:
        return
    pieces = home.pieces.setdefault(player.player_id, Pieces())
    ships = layout.get("home", {})
    for ship_class, count in ships.items():
        if count is None:
            continue
        if ship_class == "starbase":
            pieces.starbase = max(int(pieces.starbase or 0), int(count))
        else:
            pieces.ships[ship_class] = max(int(pieces.ships.get(ship_class, 0)), int(count))


def _apply_starting_structures(state: GameState, player: PlayerState, layout: Dict[str, Dict[str, Any]]) -> None:
    if not layout:
        return
    home = _find_home_hex(state, player.player_id)
    if home is None:
        return
    structures = layout.get("home", {})
    for struct, count in structures.items():
        if count is None:
            continue
        value = int(count)
        if struct == "orbital":
            home.orbital = bool(value)
        elif struct == "monolith":
            home.monolith = bool(value)
        elif struct == "deathmoon":
            pieces = home.pieces.setdefault(player.player_id, Pieces())
            pieces.starbase = max(int(pieces.starbase or 0), value)


def _apply_special_resources(player: PlayerState, special_rules: Dict[str, Any]) -> None:
    if not special_rules:
        return
    mutagen_income = special_rules.get("mutagen_production_per_round")
    if mutagen_income:
        player.special_resources.setdefault("mutagen", 0)
        player.special_resources["mutagen_income"] = int(mutagen_income)
        player.special_resources.setdefault("mutagen_trade_rate", 3)
    if special_rules.get("single_resource_transmatter"):
        player.special_resources.setdefault("transmatter_single_resource", True)


def _remove_tech_from_supply(state: GameState, tech_name: str) -> None:
    if not tech_name:
        return
    if state.market and tech_name in state.market:
        state.market.remove(tech_name)
    if state.tech_display and tech_name in state.tech_display.available:
        state.tech_display.available.remove(tech_name)
    for bag in (state.tech_bags or {}).values():
        while tech_name in bag:
            bag.remove(tech_name)


def _find_home_hex(state: GameState, player_id: str):
    if not state.map or not state.map.hexes:
        return None
    best = None
    for hx in state.map.hexes.values():
        pieces = hx.pieces.get(player_id) if hx.pieces else None
        if not pieces:
            continue
        if best is None or hx.ring < best.ring:
            best = hx
    return best

===== FILE: eclipse_ai/ship_parts.py =====

"""Canonical definitions for ship parts and blueprint metadata.

This module centralises the per-part data so that both the rules engine and
tests share a single source of truth. Only a subset of the Eclipse catalog is
encoded; it is sufficient for legality checks and can be extended as needed.
"""

from __future__ import annotations

from dataclasses import dataclass
from typing import Dict, Optional


@dataclass(frozen=True)
class ShipPart:
    """Static data describing a ship part tile."""

    name: str
    category: str  # computer, shield, cannon, missile, drive, energy, hull
    weapon_type: Optional[str] = None  # ion, plasma, gauss, antimatter
    weapon_strength: int = 0
    missiles: int = 0
    computer: int = 0
    shield: int = 0
    hull: int = 0
    initiative: int = 0
    movement: int = 0
    energy_consumption: int = 0
    energy_production: int = 0
    requires_tech: Optional[str] = None
    slots: int = 1


# Primary ship parts referenced by the tests and legality checks. Values are
# derived from Eclipse 2E, with initiative bonuses simplified for drives.
SHIP_PARTS: Dict[str, ShipPart] = {
    "Ion Cannon": ShipPart(
        name="Ion Cannon",
        category="cannon",
        weapon_type="ion",
        weapon_strength=1,
    ),
    "Plasma Cannon": ShipPart(
        name="Plasma Cannon",
        category="cannon",
        weapon_type="plasma",
        weapon_strength=2,
        energy_consumption=2,
        requires_tech="Plasma Cannon",
    ),
    "Electron Computer": ShipPart(
        name="Electron Computer",
        category="computer",
        computer=1,
        energy_consumption=1,
    ),
    "Positron Computer": ShipPart(
        name="Positron Computer",
        category="computer",
        computer=2,
        energy_consumption=2,
        requires_tech="Positron Computer",
    ),
    "Gauss Shield": ShipPart(
        name="Gauss Shield",
        category="shield",
        shield=2,
        energy_consumption=1,
        requires_tech="Gauss Shield",
    ),
    "Hull": ShipPart(
        name="Hull",
        category="hull",
        hull=1,
    ),
    "Improved Hull": ShipPart(
        name="Improved Hull",
        category="hull",
        hull=2,
        requires_tech="Improved Hull",
    ),
    "Nuclear Drive": ShipPart(
        name="Nuclear Drive",
        category="drive",
        movement=1,
        initiative=1,
        energy_consumption=1,
    ),
    "Fusion Drive": ShipPart(
        name="Fusion Drive",
        category="drive",
        movement=2,
        initiative=2,
        energy_consumption=2,
        requires_tech="Fusion Drive",
    ),
    "Antimatter Drive": ShipPart(
        name="Antimatter Drive",
        category="drive",
        movement=3,
        initiative=3,
        energy_consumption=3,
        requires_tech="Antimatter Drive",
    ),
    "Nuclear Source": ShipPart(
        name="Nuclear Source",
        category="energy",
        energy_production=3,
    ),
    "Fusion Source": ShipPart(
        name="Fusion Source",
        category="energy",
        energy_production=6,
        requires_tech="Fusion Source",
    ),
    "Plasma Missile": ShipPart(
        name="Plasma Missile",
        category="missile",
        missiles=2,
        initiative=2,
        energy_consumption=1,
        requires_tech="Plasma Missile",
    ),
}


# Blueprint slot limits by ship class (Eclipse 2E reference board).
SHIP_BLUEPRINT_SLOTS: Dict[str, int] = {
    "interceptor": 6,
    "cruiser": 8,
    "dreadnought": 10,
    "starbase": 6,
}


MOBILE_SHIPS = {"interceptor", "cruiser", "dreadnought"}


===== FILE: eclipse_ai/simulators/combat.py =====

"""Combat resolution for Eclipse.

This module implements deterministic single-combat resolution that respects the
published timing structure: missiles by initiative, then engagement rounds with
initiative ordered cannon volleys.  The driver is :func:`resolve_combat`, while
:func:`score_combat` keeps the legacy Monte-Carlo EV wrapper used by other
modules.
"""
from __future__ import annotations

from dataclasses import dataclass, field
from typing import Any, Dict, Iterable, List, Optional, Tuple
import random

# =============================
# Basic data structures
# =============================


@dataclass
class WeaponProfile:
    """Static information about a weapon line."""

    base_to_hit: int
    damage: int = 1
    is_rift: bool = False


@dataclass
class Ship:
    """Runtime representation of a single ship in combat."""

    cls: str
    initiative: int
    hull: int
    max_hull: int
    computer: int
    shield: int
    weapons: Dict[str, int] = field(default_factory=dict)
    missiles: int = 0
    missile_damage: int = 1

    def alive(self) -> bool:
        return self.hull > 0

    def copy(self) -> "Ship":
        return Ship(
            cls=self.cls,
            initiative=self.initiative,
            hull=self.hull,
            max_hull=self.max_hull,
            computer=self.computer,
            shield=self.shield,
            weapons=dict(self.weapons),
            missiles=self.missiles,
            missile_damage=self.missile_damage,
        )


@dataclass
class Combatant:
    """State for one side of the battle."""

    owner: str
    ships: List[Ship] = field(default_factory=list)
    has_point_defense: bool = False
    point_defense_dice: int = 0
    point_defense_base: int = 6
    point_defense_computer: int = 0
    retreat_requested: bool = False
    pinned: bool = False

    def alive(self) -> bool:
        return any(s.alive() for s in self.ships)

    def total_ships(self) -> int:
        return sum(1 for s in self.ships if s.alive())

    def copy(self) -> "Combatant":
        return Combatant(
            owner=self.owner,
            ships=[s.copy() for s in self.ships],
            has_point_defense=self.has_point_defense,
            point_defense_dice=self.point_defense_dice,
            point_defense_base=self.point_defense_base,
            point_defense_computer=self.point_defense_computer,
            retreat_requested=self.retreat_requested,
            pinned=self.pinned,
        )


@dataclass
class CombatConfig:
    attacker: Combatant
    defender: Combatant
    weapon_profiles: Dict[str, WeaponProfile]
    simul_same_initiative: bool = True
    enable_point_defense: bool = False
    enable_rift_cannons: bool = False
    antimatter_splitter_enabled: bool = False
    targeting: str = "focus_fire"
    round_cap: int = 20
    seed: Optional[int] = None


@dataclass
class CombatResolution:
    winner: Optional[str]
    attacker: Combatant
    defender: Combatant
    retreating_side: Optional[str] = None
    rounds_completed: int = 0
    trace: Optional[Dict[str, List[Dict[str, Any]]]] = None


# =============================
# Dice helpers
# =============================


def missile_hit(die: int) -> bool:
    """Missiles hit only on a natural six."""

    return die == 6


def cannon_threshold(att_computers: int, def_shields: int, base: int) -> int:
    """Compute the to-hit threshold for cannons, bounded to 2..6."""

    thr = base - att_computers + def_shields
    if thr < 2:
        return 2
    if thr > 6:
        return 6
    return thr


# =============================
# Core combat driver
# =============================


class CombatResolver:
    def __init__(self, config: CombatConfig, debug: bool = False):
        self.cfg = config
        self.debug = debug
        self.rng = random.Random(config.seed)
        self.attacker = config.attacker.copy()
        self.defender = config.defender.copy()
        self.weapon_profiles = dict(config.weapon_profiles)
        self.trace: Optional[Dict[str, List[Dict[str, Any]]]] = (
            {"missile_steps": [], "pd_steps": [], "cannon_volleys": []}
            if debug
            else None
        )
        self.retreating_side: Optional[str] = None
        self.rounds_completed = 0

    # ----- Public API -----

    def resolve(self) -> CombatResolution:
        self._resolve_missiles()
        if self.attacker.alive() and self.defender.alive():
            self._engagement_loop()
        winner = self._determine_winner()
        return CombatResolution(
            winner=winner,
            attacker=self.attacker,
            defender=self.defender,
            retreating_side=self.retreating_side,
            rounds_completed=self.rounds_completed,
            trace=self.trace,
        )

    # ----- Missile phase -----

    def _resolve_missiles(self) -> None:
        max_ini = self._max_initiative()
        for ini in range(max_ini, -1, -1):
            if self.attacker.alive():
                self._fire_missiles_for_initiative(self.attacker, self.defender, ini)
            if self.defender.alive():
                self._fire_missiles_for_initiative(self.defender, self.attacker, ini)
            if not (self.attacker.alive() and self.defender.alive()):
                break

    def _fire_missiles_for_initiative(
        self, side: Combatant, opponent: Combatant, ini: int
    ) -> None:
        ships = [s for s in side.ships if s.alive() and s.initiative == ini and s.missiles > 0]
        if not ships or not opponent.alive():
            return
        ships_by_cls: Dict[str, List[Ship]] = {}
        for ship in ships:
            ships_by_cls.setdefault(ship.cls, []).append(ship)
        for cls, cls_ships in ships_by_cls.items():
            assignments: List[Dict[str, Any]] = []
            for ship in cls_ships:
                for _ in range(ship.missiles):
                    target_index = self._select_target_index(opponent, self.cfg.targeting)
                    die = self._roll_die()
                    assignments.append(
                        {
                            "target_index": target_index,
                            "die": die,
                            "hit": missile_hit(die),
                            "damage": ship.missile_damage,
                            "ship_class": cls,
                            "side": side.owner,
                            "initiative": ini,
                        }
                    )
                ship.missiles = 0
            hits_before_pd = sum(1 for a in assignments if a["hit"])
            if (
                hits_before_pd
                and self.cfg.enable_point_defense
                and opponent.has_point_defense
                and opponent.point_defense_dice > 0
            ):
                pd_hits = self._resolve_point_defense(
                    defender=opponent,
                    incoming_hits=hits_before_pd,
                    context={"side": side.owner, "ship_class": cls, "initiative": ini},
                )
                for assignment in assignments:
                    if pd_hits <= 0:
                        break
                    if assignment["hit"]:
                        assignment["hit"] = False
                        pd_hits -= 1
            self._apply_missile_assignments(assignments, opponent)
            if self.trace is not None:
                self.trace["missile_steps"].append(
                    {
                        "side": side.owner,
                        "initiative": ini,
                        "ship_class": cls,
                        "assignments": assignments,
                    }
                )

    def _resolve_point_defense(
        self,
        defender: Combatant,
        incoming_hits: int,
        context: Dict[str, Any],
    ) -> int:
        threshold = cannon_threshold(
            att_computers=defender.point_defense_computer,
            def_shields=0,
            base=defender.point_defense_base,
        )
        prevented = 0
        rolls: List[int] = []
        for _ in range(defender.point_defense_dice):
            die = self._roll_die()
            rolls.append(die)
            if die == 6 or die >= threshold:
                prevented += 1
        prevented = min(prevented, incoming_hits)
        if self.trace is not None:
            data = dict(context)
            data.update(
                {
                    "defender": defender.owner,
                    "prevented": prevented,
                    "rolls": rolls,
                }
            )
            self.trace["pd_steps"].append(data)
        return prevented

    def _apply_missile_assignments(
        self, assignments: Iterable[Dict[str, Any]], opponent: Combatant
    ) -> None:
        for assignment in assignments:
            if not assignment.get("hit"):
                continue
            target_index = assignment["target_index"]
            damage = assignment["damage"]
            self._apply_damage_to_index(opponent, target_index, damage)

    # ----- Engagement rounds -----

    def _engagement_loop(self) -> None:
        for round_index in range(1, self.cfg.round_cap + 1):
            if not (self.attacker.alive() and self.defender.alive()):
                break
            self._engagement_round(round_index)
            self.rounds_completed = round_index
            if self.retreating_side:
                break
            if not (self.attacker.alive() and self.defender.alive()):
                break
            self._handle_retreats()
            if self.retreating_side:
                break

    def _engagement_round(self, round_index: int) -> None:
        max_ini = self._max_initiative()
        for ini in range(max_ini, -1, -1):
            if not (self.attacker.alive() and self.defender.alive()):
                break
            att_hits = self._prepare_cannon_volley(self.attacker, self.defender, ini)
            def_hits = self._prepare_cannon_volley(self.defender, self.attacker, ini)
            if self.trace is not None and (att_hits or def_hits):
                self.trace["cannon_volleys"].append(
                    {
                        "round": round_index,
                        "initiative": ini,
                        "attacker_hits": att_hits,
                        "defender_hits": def_hits,
                    }
                )
            if self.cfg.simul_same_initiative:
                self._apply_hits(self.defender, att_hits)
                self._apply_hits(self.attacker, def_hits)
            else:
                self._apply_hits(self.defender, att_hits)
                if self.defender.alive():
                    self._apply_hits(self.attacker, def_hits)

    def _prepare_cannon_volley(
        self, side: Combatant, opponent: Combatant, ini: int
    ) -> List[Dict[str, Any]]:
        hits: List[Dict[str, Any]] = []
        if not opponent.alive():
            return hits
        for ship_index, ship in enumerate(side.ships):
            if not ship.alive() or ship.initiative != ini:
                continue
            for weapon_name, dice in ship.weapons.items():
                profile = self.weapon_profiles.get(weapon_name)
                if profile is None:
                    continue
                if profile.is_rift and not self.cfg.enable_rift_cannons:
                    continue
                for _ in range(dice):
                    if profile.is_rift:
                        self._resolve_rift_die(
                            hits,
                            side,
                            opponent,
                            ship_index,
                            weapon_name,
                            profile,
                        )
                    else:
                        self._resolve_cannon_die(
                            hits,
                            side,
                            opponent,
                            ship_index,
                            weapon_name,
                            profile,
                        )
        return hits

    def _resolve_cannon_die(
        self,
        hits: List[Dict[str, Any]],
        side: Combatant,
        opponent: Combatant,
        ship_index: int,
        weapon_name: str,
        profile: WeaponProfile,
    ) -> None:
        if not opponent.alive():
            return
        target_index = self._select_target_index(opponent, self.cfg.targeting)
        die = self._roll_die()
        threshold = cannon_threshold(
            att_computers=side.ships[ship_index].computer,
            def_shields=opponent.ships[target_index].shield,
            base=profile.base_to_hit,
        )
        hit = die == 6 or die >= threshold
        if hit:
            if self.cfg.antimatter_splitter_enabled and profile.damage > 1:
                ordered_targets = self._ordered_target_indices(
                    opponent, self.cfg.targeting
                )
                if not ordered_targets:
                    return
                assigned = 0
                for idx in ordered_targets:
                    hits.append(
                        {
                            "target_index": idx,
                            "damage": 1,
                            "weapon": weapon_name,
                            "side": side.owner,
                            "die": die,
                            "split": True,
                        }
                    )
                    assigned += 1
                    if assigned >= profile.damage:
                        break
                while assigned < profile.damage and ordered_targets:
                    hits.append(
                        {
                            "target_index": ordered_targets[0],
                            "damage": 1,
                            "weapon": weapon_name,
                            "side": side.owner,
                            "die": die,
                            "split": True,
                        }
                    )
                    assigned += 1
            else:
                hits.append(
                    {
                        "target_index": target_index,
                        "damage": profile.damage,
                        "weapon": weapon_name,
                        "side": side.owner,
                        "die": die,
                        "split": False,
                    }
                )

    def _resolve_rift_die(
        self,
        hits: List[Dict[str, Any]],
        side: Combatant,
        opponent: Combatant,
        ship_index: int,
        weapon_name: str,
        profile: WeaponProfile,
    ) -> None:
        die = self._roll_die()
        outcome: Dict[str, Any]
        if die <= 2:
            outcome = {
                "target_index": ship_index,
                "damage": 0,
                "weapon": weapon_name,
                "side": side.owner,
                "die": die,
                "self_hit": True,
                "self_damage": profile.damage,
            }
            self._apply_damage_to_index(side, ship_index, profile.damage)
        elif die in (3, 4):
            outcome = {
                "target_index": None,
                "damage": 0,
                "weapon": weapon_name,
                "side": side.owner,
                "die": die,
                "self_hit": False,
            }
        else:
            target_index = self._select_target_index(opponent, self.cfg.targeting)
            outcome = {
                "target_index": target_index,
                "damage": profile.damage if die == 5 else profile.damage + 1,
                "weapon": weapon_name,
                "side": side.owner,
                "die": die,
                "self_hit": False,
            }
            hits.append(outcome)
            return
        hits.append(outcome)

    def _apply_hits(self, target: Combatant, hits: Iterable[Dict[str, Any]]) -> None:
        for hit in hits:
            damage = hit.get("damage", 0)
            target_index = hit.get("target_index")
            if damage <= 0 or target_index is None:
                continue
            self._apply_damage_to_index(target, target_index, damage)

    # ----- Retreat -----

    def _handle_retreats(self) -> None:
        attacker_retreats = (
            self.attacker.retreat_requested and not self.attacker.pinned
        )
        defender_retreats = (
            self.defender.retreat_requested and not self.defender.pinned
        )
        if attacker_retreats and defender_retreats:
            self.retreating_side = "both"
        elif attacker_retreats:
            self.retreating_side = "attacker"
        elif defender_retreats:
            self.retreating_side = "defender"

    # ----- Utility -----

    def _determine_winner(self) -> Optional[str]:
        if self.retreating_side == "attacker":
            return "defender"
        if self.retreating_side == "defender":
            return "attacker"
        if not self.attacker.alive() and not self.defender.alive():
            return None
        if self.attacker.alive() and not self.defender.alive():
            return "attacker"
        if self.defender.alive() and not self.attacker.alive():
            return "defender"
        return None

    def _apply_damage_to_index(self, fleet: Combatant, idx: int, dmg: int) -> None:
        if idx >= len(fleet.ships):
            return
        ship = fleet.ships[idx]
        if not ship.alive():
            return
        ship.hull -= dmg
        if ship.hull < 0:
            ship.hull = 0

    def _max_initiative(self) -> int:
        max_ini = 0
        for ship in self.attacker.ships + self.defender.ships:
            if ship.alive():
                if ship.initiative > max_ini:
                    max_ini = ship.initiative
        return max_ini

    def _roll_die(self) -> int:
        return self.rng.randint(1, 6)

    def _ordered_target_indices(self, fleet: Combatant, policy: str) -> List[int]:
        alive_indices = [i for i, ship in enumerate(fleet.ships) if ship.alive()]
        if not alive_indices:
            return []
        if policy == "random":
            indices = alive_indices[:]
            self.rng.shuffle(indices)
            return indices

        def key_focus(i: int) -> Tuple[int, int, str]:
            ship = fleet.ships[i]
            return (ship.hull, ship.initiative, ship.cls)

        def key_lowest_ini(i: int) -> Tuple[int, int, str]:
            ship = fleet.ships[i]
            return (ship.initiative, ship.hull, ship.cls)

        def key_highest_ini(i: int) -> Tuple[int, int, str]:
            ship = fleet.ships[i]
            return (-ship.initiative, ship.hull, ship.cls)

        if policy == "lowest_initiative":
            return sorted(alive_indices, key=key_lowest_ini)
        if policy == "highest_initiative":
            return sorted(alive_indices, key=key_highest_ini)
        return sorted(alive_indices, key=key_focus)

    def _select_target_index(self, fleet: Combatant, policy: str) -> int:
        ordered = self._ordered_target_indices(fleet, policy)
        if not ordered:
            return 0
        return ordered[0]


# =============================
# Legacy Monte Carlo wrapper
# =============================


@dataclass
class CombatResult:
    win_prob: float
    expected_vp_swing: float
    expected_losses_attacker: float
    expected_losses_defender: float


@dataclass
class _SimConfig:
    weapon_profiles: Dict[str, WeaponProfile]
    n_sims: int
    seed: int
    rep_tile_ev: float
    ship_vp: Dict[str, float]
    round_cap: int
    simul_same_initiative: bool
    targeting: str
    enable_point_defense: bool
    enable_rift_cannons: bool
    antimatter_splitter_enabled: bool
    attacker: Combatant = field(default_factory=lambda: Combatant(owner="attacker"))
    defender: Combatant = field(default_factory=lambda: Combatant(owner="defender"))
    attacker_initial_counts: Dict[str, int] = field(default_factory=dict)
    defender_initial_counts: Dict[str, int] = field(default_factory=dict)

    @staticmethod
    def _default_weapon_profiles() -> Dict[str, WeaponProfile]:
        return {
            "ion": WeaponProfile(base_to_hit=6, damage=1),
            "plasma": WeaponProfile(base_to_hit=5, damage=1),
            "gauss": WeaponProfile(base_to_hit=4, damage=1),
            "antimatter": WeaponProfile(base_to_hit=4, damage=2),
            "rift": WeaponProfile(base_to_hit=4, damage=2, is_rift=True),
        }

    @classmethod
    def from_query(cls, query: Dict[str, Any]) -> "_SimConfig":
        weapon_profiles = cls._default_weapon_profiles()
        for name, info in query.get("weapon_profiles", {}).items():
            weapon_profiles[name] = WeaponProfile(
                base_to_hit=int(info.get("base_to_hit", 6)),
                damage=int(info.get("damage", 1)),
                is_rift=bool(info.get("is_rift", False)),
            )
        n_sims = int(query.get("n_sims", 4000))
        seed = int(query.get("seed", 12345))
        rep_tile_ev = float(query.get("rep_tile_ev", 1.0))
        ship_vp = {
            "interceptor": 0.5,
            "cruiser": 1.0,
            "dreadnought": 2.0,
            "starbase": 1.0,
            "ancient": 1.0,
        }
        ship_vp.update(query.get("ship_vp", {}))
        round_cap = int(query.get("round_cap", 20))
        simul = bool(query.get("simultaneous_at_same_initiative", True))
        targeting = str(query.get("targeting", "focus_fire"))
        enable_pd = bool(query.get("enable_point_defense", False))
        enable_rift = bool(query.get("enable_rift_cannons", False))
        splitter = bool(query.get("antimatter_splitter_enabled", False))

        atk = query.get("attacker", {})
        dfd = query.get("defender", {})
        atk_fleet, atk_init = _build_fleet("attacker", atk)
        dfd_fleet, dfd_init = _build_fleet("defender", dfd)

        atk_pd = atk.get("point_defense", {})
        dfd_pd = dfd.get("point_defense", {})
        atk_fleet.has_point_defense = bool(atk_pd.get("enabled", False))
        atk_fleet.point_defense_dice = int(atk_pd.get("dice", 0))
        atk_fleet.point_defense_base = int(atk_pd.get("base", 6))
        atk_fleet.point_defense_computer = int(atk_pd.get("computer", 0))
        dfd_fleet.has_point_defense = bool(dfd_pd.get("enabled", False))
        dfd_fleet.point_defense_dice = int(dfd_pd.get("dice", 0))
        dfd_fleet.point_defense_base = int(dfd_pd.get("base", 6))
        dfd_fleet.point_defense_computer = int(dfd_pd.get("computer", 0))

        atk_fleet.retreat_requested = bool(atk.get("retreat", False))
        atk_fleet.pinned = bool(atk.get("pinned", False))
        dfd_fleet.retreat_requested = bool(dfd.get("retreat", False))
        dfd_fleet.pinned = bool(dfd.get("pinned", False))

        return cls(
            weapon_profiles=weapon_profiles,
            n_sims=n_sims,
            seed=seed,
            rep_tile_ev=rep_tile_ev,
            ship_vp=ship_vp,
            round_cap=round_cap,
            simul_same_initiative=simul,
            targeting=targeting,
            enable_point_defense=enable_pd,
            enable_rift_cannons=enable_rift,
            antimatter_splitter_enabled=splitter,
            attacker=atk_fleet,
            defender=dfd_fleet,
            attacker_initial_counts=atk_init,
            defender_initial_counts=dfd_init,
        )


def _build_fleet(owner: str, side: Dict[str, Any]) -> Tuple[Combatant, Dict[str, int]]:
    ships_by_class: Dict[str, int] = {k: int(v) for k, v in side.get("ships", {}).items()}
    designs_by_class: Dict[str, Dict[str, Any]] = dict(side.get("designs", {}))

    if not designs_by_class:
        aggregate = {
            "computer": int(side.get("computer", 0)),
            "shield": int(side.get("shield", 0)),
            "weapons": dict(side.get("weapons", {})),
            "missiles": int(side.get("missiles", 0)),
            "hull": int(side.get("hull", 1)),
            "initiative": int(side.get("initiative", 2)),
        }
        designs_by_class = {
            cls: _generic_design_for(cls, aggregate) for cls in ships_by_class
        }
        if not designs_by_class and not ships_by_class:
            ships_by_class = {"interceptor": 1}
            designs_by_class = {
                "interceptor": _generic_design_for("interceptor", aggregate)
            }

    fleet = Combatant(owner=owner)
    for cls_name, count in ships_by_class.items():
        design = designs_by_class.get(cls_name, _generic_design_for(cls_name, {}))
        for _ in range(count):
            fleet.ships.append(
                Ship(
                    cls=cls_name,
                    initiative=int(design.get("initiative", 2)),
                    hull=int(design.get("hull", 1)),
                    max_hull=int(design.get("hull", 1)),
                    computer=int(design.get("computer", 0)),
                    shield=int(design.get("shield", 0)),
                    weapons=dict(design.get("weapons", {"ion": 1})),
                    missiles=int(design.get("missiles", 0)),
                    missile_damage=int(design.get("missile_damage", 1)),
                )
            )
    initial_counts = {k: int(v) for k, v in ships_by_class.items()}
    return fleet, initial_counts


def _generic_design_for(cls: str, aggregate: Dict[str, Any]) -> Dict[str, Any]:
    base = {
        "interceptor": {
            "initiative": 3,
            "hull": 1,
            "computer": aggregate.get("computer", 0),
            "shield": aggregate.get("shield", 0),
            "weapons": aggregate.get("weapons", {"ion": 1}),
            "missiles": aggregate.get("missiles", 0),
        },
        "cruiser": {
            "initiative": 2,
            "hull": 2,
            "computer": aggregate.get("computer", 0),
            "shield": aggregate.get("shield", 0),
            "weapons": aggregate.get("weapons", {"ion": 2}),
            "missiles": aggregate.get("missiles", 0),
        },
        "dreadnought": {
            "initiative": 1,
            "hull": 3,
            "computer": aggregate.get("computer", 0),
            "shield": aggregate.get("shield", 0),
            "weapons": aggregate.get("weapons", {"ion": 3}),
            "missiles": aggregate.get("missiles", 0),
        },
        "starbase": {
            "initiative": 4,
            "hull": 2,
            "computer": aggregate.get("computer", 0),
            "shield": aggregate.get("shield", 0),
            "weapons": aggregate.get("weapons", {"ion": 2}),
            "missiles": aggregate.get("missiles", 0),
        },
        "ancient": {
            "initiative": 2,
            "hull": 2,
            "computer": 1,
            "shield": 1,
            "weapons": {"ion": 2},
            "missiles": 0,
        },
    }
    return base.get(
        cls,
        {
            "initiative": aggregate.get("initiative", 2),
            "hull": aggregate.get("hull", 1),
            "computer": aggregate.get("computer", 0),
            "shield": aggregate.get("shield", 0),
            "weapons": aggregate.get("weapons", {"ion": 1}),
            "missiles": aggregate.get("missiles", 0),
        },
    )


class _CombatSim:
    def __init__(self, cfg: _SimConfig, rng: random.Random):
        self.cfg = cfg
        self.rng = rng
        self.attacker_start = sum(1 for s in cfg.attacker.ships if s.alive())
        self.defender_start = sum(1 for s in cfg.defender.ships if s.alive())

    def run(self) -> CombatResolution:
        seed = self.rng.randint(1, 10_000_000)
        resolver = CombatResolver(
            CombatConfig(
                attacker=self.cfg.attacker,
                defender=self.cfg.defender,
                weapon_profiles=self.cfg.weapon_profiles,
                simul_same_initiative=self.cfg.simul_same_initiative,
                enable_point_defense=self.cfg.enable_point_defense,
                enable_rift_cannons=self.cfg.enable_rift_cannons,
                antimatter_splitter_enabled=self.cfg.antimatter_splitter_enabled,
                targeting=self.cfg.targeting,
                round_cap=self.cfg.round_cap,
                seed=seed,
            )
        )
        return resolver.resolve()


def score_combat(query: Dict[str, Any]) -> CombatResult:
    cfg = _SimConfig.from_query(query)
    rng = random.Random(cfg.seed)
    wins = 0
    att_losses = 0.0
    def_losses = 0.0
    vp_swing_total = 0.0

    for _ in range(cfg.n_sims):
        sim = _CombatSim(cfg, rng)
        outcome = sim.run()
        if outcome.winner == "attacker":
            wins += 1
            vp_swing_total += cfg.rep_tile_ev
        elif outcome.winner == "defender":
            vp_swing_total -= cfg.rep_tile_ev
        att_losses += _losses(cfg.attacker_initial_counts, outcome.attacker)
        def_losses += _losses(cfg.defender_initial_counts, outcome.defender)
        vp_swing_total += _vp_delta(cfg, outcome)

    n = max(1, cfg.n_sims)
    return CombatResult(
        win_prob=wins / n,
        expected_vp_swing=vp_swing_total / n,
        expected_losses_attacker=att_losses / n,
        expected_losses_defender=def_losses / n,
    )


def _losses(initial_counts: Dict[str, int], fleet: Combatant) -> int:
    destroyed = 0
    for cls, start in initial_counts.items():
        alive = sum(1 for s in fleet.ships if s.alive() and s.cls == cls)
        destroyed += max(0, start - alive)
    return destroyed


def _vp_delta(cfg: _SimConfig, outcome: CombatResolution) -> float:
    attacker_vp = 0.0
    defender_vp = 0.0
    for cls, start in cfg.defender_initial_counts.items():
        alive = sum(1 for s in outcome.defender.ships if s.alive() and s.cls == cls)
        destroyed = max(0, start - alive)
        attacker_vp += cfg.ship_vp.get(cls, 0.0) * destroyed
    for cls, start in cfg.attacker_initial_counts.items():
        alive = sum(1 for s in outcome.attacker.ships if s.alive() and s.cls == cls)
        destroyed = max(0, start - alive)
        defender_vp += cfg.ship_vp.get(cls, 0.0) * destroyed
    return attacker_vp - defender_vp


__all__ = [
    "CombatConfig",
    "CombatResolution",
    "CombatResult",
    "Combatant",
    "CombatResolver",
    "Ship",
    "WeaponProfile",
    "cannon_threshold",
    "missile_hit",
    "resolve_combat",
    "score_combat",
]


def resolve_combat(config: CombatConfig, debug: bool = False) -> CombatResolution:
    resolver = CombatResolver(config, debug=debug)
    return resolver.resolve()

===== FILE: eclipse_ai/simulators/exploration.py =====

from __future__ import annotations
from typing import Dict, Any, List, Tuple, Optional
from dataclasses import dataclass, field
from collections import Counter, defaultdict
import random
import re
import math

try:
    # Optional: use combat EV for clearing Ancients if provided
    from .combat import score_combat
except Exception:
    score_combat = None

# =============================
# Public API
# =============================

@dataclass
class ExplorationEV:
    expected_value_vp: float
    notes: str

def exploration_ev(query: Dict[str, Any]) -> ExplorationEV:
    """
    Robust Monte Carlo exploration EV.
    Inputs (all optional except 'bag'):
      query = {
        "ring": 2,
        "bag": {"ancient":3, "monolith":1, "money2":4, "science2":4, "materials2":4},
        # How many tiles you draw and choose 1 from
        "draws": 1,                     # default 1 (set 2 or 3 if tech allows)
        "n_sims": 5000,
        "seed": 123,
        # Placement feasibility
        "p_connect_default": 0.70,      # chance drawn tile connects on the chosen edge (no WH Generator)
        "p_connect_by_category": {},    # overrides per category
        "wormhole_generator": False,    # if True, connection is guaranteed
        "discs_available": 1,           # if 0 and require_disc_to_claim=True, no immediate colonization EV
        "require_disc_to_claim": True,
        # Colonization capability
        "colony_ships": {"yellow": 1, "blue": 1, "brown": 1, "wild": 0},
        # Economy valuation (VP per round per colonized planet of each color)
        "vp_per_income": {"yellow": 0.20, "blue": 0.20, "brown": 0.20},
        "horizon_rounds": 3,            # project income this many rounds
        "discount": 0.90,               # per-round discount
        # Endgame / one-time values
        "monolith_vp": 3.0,
        "endgame_weight": 0.5,          # weight monolith VP toward present EV
        "discovery_vp": 1.0,            # if a category is flagged with discovery, value of the chit
        "discard_reward_vp": 0.0,       # value if you discard all draws (set >0 if using a house rule/variant)
        # Ancients modeling
        "ancient_block_penalty": 0.6,   # penalty for tile being blocked by Ancients in near-term
        "prob_clear_by_horizon": 0.40,  # chance you clear Ancients within horizon
        # Optional detailed fight EV if you intend to clear: will call combat.score_combat if provided
        "ancient_combat_query": None,   # dict accepted by combat.score_combat()
        "ancient_fallback_ev": -0.3,    # if no combat query or combat module missing, use this EV
        # Category feature overrides (see _parse_category for defaults)
        # e.g., "category_overrides": {"money2":{"discovery":True}, "ancient":{"money":0,"science":0,"materials":0}}
        "category_overrides": {},
      }
    Returns:
      ExplorationEV(expected_value_vp, notes_json)
    """
    cfg = _Config.from_query(query)
    rng = random.Random(cfg.seed)

    # Precompute PV factor per round for income
    pv = _present_value_factor(cfg.horizon_rounds, cfg.discount)

    # Monte Carlo over draws without replacement
    total_ev = 0.0
    pick_counts: Counter[str] = Counter()
    pick_scores: defaultdict[str, float] = defaultdict(float)

    for _ in range(cfg.n_sims):
        drawn = _weighted_sample_without_replacement(cfg.bag, cfg.draws, rng)
        # Evaluate each drawn category
        best_score = cfg.discard_reward_vp
        best_cat = None
        for cat in drawn:
            td = _tile_from_category(cat, cfg.category_overrides)
            score = _score_tile(td, cfg, pv, rng)
            if score > best_score:
                best_score = score
                best_cat = cat
        total_ev += best_score
        if best_cat is not None:
            pick_counts[best_cat] += 1
            pick_scores[best_cat] += best_score

    n = max(1, cfg.n_sims)
    avg_ev = total_ev / n

    # Build concise notes
    top = pick_counts.most_common(5)
    summary = {
        "ring": cfg.ring,
        "avg_ev": round(avg_ev, 3),
        "draws": cfg.draws,
        "connect_default": cfg.p_connect_default,
        "wormhole_generator": cfg.wormhole_generator,
        "pv_factor": round(pv, 3),
        "top_picks": [
            {"category": c, "pick_rate": round(cnt/n, 3), "avg_score": round(pick_scores[c]/max(1,cnt), 3)}
            for c, cnt in top
        ],
        "bag_size": sum(cfg.bag.values()),
    }
    return ExplorationEV(expected_value_vp=avg_ev, notes=_safe_json(summary))

# =============================
# Internal config and helpers
# =============================

@dataclass
class _Config:
    ring: int
    bag: Dict[str, float]
    draws: int
    n_sims: int
    seed: int
    p_connect_default: float
    p_connect_by_category: Dict[str, float]
    wormhole_generator: bool
    discs_available: int
    require_disc_to_claim: bool
    colony_ships: Dict[str, int]
    vp_per_income: Dict[str, float]
    horizon_rounds: int
    discount: float
    monolith_vp: float
    endgame_weight: float
    discovery_vp: float
    discard_reward_vp: float
    ancient_block_penalty: float
    prob_clear_by_horizon: float
    ancient_combat_query: Optional[Dict[str, Any]]
    ancient_fallback_ev: float
    category_overrides: Dict[str, Dict[str, Any]]

    @classmethod
    def from_query(cls, q: Dict[str, Any]) -> "_Config":
        bag = {k: float(v) for k, v in q.get("bag", {}).items() if float(v) > 0}
        ring = int(q.get("ring", 2))
        draws = int(q.get("draws", 1))
        n_sims = int(q.get("n_sims", 5000))
        seed = int(q.get("seed", 123))
        p_def = float(q.get("p_connect_default", 0.70))
        p_by = dict(q.get("p_connect_by_category", {}))
        whg = bool(q.get("wormhole_generator", False))
        discs = int(q.get("discs_available", 1))
        req_disc = bool(q.get("require_disc_to_claim", True))
        colony = {k:int(v) for k,v in q.get("colony_ships", {"yellow":1,"blue":1,"brown":1,"wild":0}).items()}
        vpincome = {"yellow":0.20,"blue":0.20,"brown":0.20}
        vpincome.update({k: float(v) for k, v in q.get("vp_per_income", {}).items()})
        horizon = int(q.get("horizon_rounds", 3))
        disc = float(q.get("discount", 0.90))
        mono = float(q.get("monolith_vp", 3.0))
        endw = float(q.get("endgame_weight", 0.5))
        disc_vp = float(q.get("discard_reward_vp", 0.0))
        discov = float(q.get("discovery_vp", 1.0))
        anc_pen = float(q.get("ancient_block_penalty", 0.6))
        p_clear = float(q.get("prob_clear_by_horizon", 0.40))
        anc_q = q.get("ancient_combat_query", None)
        anc_fb = float(q.get("ancient_fallback_ev", -0.3))
        overrides = dict(q.get("category_overrides", {}))
        return cls(
            ring=ring, bag=bag, draws=draws, n_sims=n_sims, seed=seed,
            p_connect_default=p_def, p_connect_by_category=p_by, wormhole_generator=whg,
            discs_available=discs, require_disc_to_claim=req_disc, colony_ships=colony,
            vp_per_income=vpincome, horizon_rounds=horizon, discount=disc,
            monolith_vp=mono, endgame_weight=endw, discovery_vp=discov,
            discard_reward_vp=disc_vp, ancient_block_penalty=anc_pen,
            prob_clear_by_horizon=p_clear, ancient_combat_query=anc_q,
            ancient_fallback_ev=anc_fb, category_overrides=overrides
        )

@dataclass
class _TileDesc:
    category: str
    money: int = 0       # yellow planets
    science: int = 0     # blue planets
    materials: int = 0   # brown planets
    wild: int = 0        # wild planets
    ancient: bool = False
    monolith: bool = False
    discovery: bool = False

def _present_value_factor(h: int, d: float) -> float:
    # PV of 1 unit per round for h rounds with discount d
    if h <= 0: return 0.0
    if abs(d - 1.0) < 1e-9:
        return float(h)
    return (1.0 - d**h) / (1.0 - d)

def _safe_json(obj: Any) -> str:
    try:
        import json
        return json.dumps(obj, separators=(',',':'))
    except Exception:
        return str(obj)

# =============================
# Sampling
# =============================

def _weighted_sample_without_replacement(weights: Dict[str, float], k: int, rng: random.Random) -> List[str]:
    """
    Efraimidis-Spirakis method for weighted sampling without replacement.
    Weights can be non-integers. Returns up to k unique categories.
    """
    items = [(cat, max(0.0, float(w))) for cat, w in weights.items() if w > 0]
    if not items or k <= 0:
        return []
    k = min(k, len(items))
    keys = []
    for cat, w in items:
        if w <= 0:
            continue
        u = rng.random()
        # Larger weights -> larger key
        key = u**(1.0 / w)
        keys.append((key, cat))
    keys.sort(reverse=True)  # take top-k
    return [cat for _, cat in keys[:k]]

# =============================
# Category parsing
# =============================

_RES_ALIASES = {
    "money":"money", "credit":"money", "yellow":"money", "y":"money",
    "science":"science", "blue":"science", "b":"science",
    "materials":"materials", "brown":"materials", "m":"materials", "r":"materials",
    "wild":"wild", "w":"wild"
}

def _tile_from_category(cat: str, overrides: Dict[str, Dict[str, Any]]) -> _TileDesc:
    base = _parse_category(cat)
    # Apply overrides
    ov = overrides.get(cat, {})
    for k, v in ov.items():
        if hasattr(base, k):
            setattr(base, k, v)
    return base

def _parse_category(cat: str) -> _TileDesc:
    td = _TileDesc(category=cat)
    s = cat.lower()
    # simple flags
    if "ancient" in s:
        td.ancient = True
    if "monolith" in s:
        td.monolith = True
    if "discovery" in s:
        td.discovery = True
    # tokenized counts like 'money2', 'science1_materials1', 'y1b1'
    tokens = re.split(r'[^a-z0-9]+', s)
    for tok in tokens:
        if not tok:
            continue
        # match <res><count>, e.g., money2, y1, blue3, wild1
        m = re.match(r'([a-z]+)(\d+)$', tok)
        if m:
            res_raw, cnt = m.group(1), int(m.group(2))
            res = _RES_ALIASES.get(res_raw)
            if res == "money":
                td.money += cnt
            elif res == "science":
                td.science += cnt
            elif res == "materials":
                td.materials += cnt
            elif res == "wild":
                td.wild += cnt
            continue
    return td

# =============================
# Scoring
# =============================

def _score_tile(td: _TileDesc, cfg: _Config, pv: float, rng: random.Random) -> float:
    """
    Score a tile's VP-equivalent EV given capabilities and weights.
    """
    # Placement feasibility via wormhole compatibility
    p_conn = 1.0 if cfg.wormhole_generator else cfg.p_connect_by_category.get(td.category, cfg.p_connect_default)

    # If no discs and claiming requires a disc, you can still place but cannot claim now => no immediate income EV
    can_claim_now = cfg.discs_available > 0 or not cfg.require_disc_to_claim

    # Planet counts available to colonize now. Ancients block colonization until cleared.
    money = td.money
    science = td.science
    materials = td.materials
    wild = td.wild

    # Colonization now if not ancient-blocked and you can claim
    colonize_now = {"money":0, "science":0, "materials":0}
    if can_claim_now and not td.ancient:
        colonize_now = _allocate_colony_ships(money, science, materials, wild, dict(cfg.colony_ships))

    income_ev = (
        colonize_now["money"]     * cfg.vp_per_income["yellow"] * pv
      + colonize_now["science"]   * cfg.vp_per_income["blue"]   * pv
      + colonize_now["materials"] * cfg.vp_per_income["brown"]  * pv
    )

    # Monolith endgame value (weighted to present)
    monolith_ev = cfg.monolith_vp * cfg.endgame_weight if td.monolith else 0.0

    # Discovery chit value if flagged (rare unless user overrides)
    discovery_ev = cfg.discovery_vp if td.discovery else 0.0

    # Connectivity bonus
    connectivity_ev = 0.15 * pv  # baseline bonus
    # Scale by planet presence as a proxy for tile "goodness"
    connectivity_ev *= 0.5 + 0.5 * min(1.0, (money+science+materials+wild)/3.0)

    # Ancients: apply near-term block penalty and optional future clear EV
    ancient_penalty = cfg.ancient_block_penalty if td.ancient else 0.0
    future_clear_ev = 0.0
    if td.ancient and cfg.prob_clear_by_horizon > 0.0:
        if cfg.ancient_combat_query and score_combat is not None:
            try:
                res = score_combat(cfg.ancient_combat_query)
                future_clear_ev = cfg.prob_clear_by_horizon * float(getattr(res, "expected_vp_swing", 0.0))
            except Exception:
                future_clear_ev = cfg.prob_clear_by_horizon * cfg.ancient_fallback_ev
        else:
            future_clear_ev = cfg.prob_clear_by_horizon * cfg.ancient_fallback_ev

    # Total EV if placed
    placed_ev = (income_ev + monolith_ev + discovery_ev + connectivity_ev + future_clear_ev - ancient_penalty)

    # Final EV: account for placement probability; compare to discard option
    place_ev = p_conn * placed_ev + (1.0 - p_conn) * cfg.discard_reward_vp

    return place_ev

def _allocate_colony_ships(money: int, science: int, materials: int, wild: int, ships: Dict[str,int]) -> Dict[str,int]:
    """
    Greedy allocation: use color-specific ships first, then wild ships to fill remaining.
    Returns colonized counts per resource color (money/science/materials). Wild planets can be claimed by any.
    """
    m = min(money, max(0, ships.get("yellow", 0)))
    b = min(science, max(0, ships.get("blue", 0)))
    r = min(materials, max(0, ships.get("brown", 0)))
    rem_y = money - m
    rem_b = science - b
    rem_r = materials - r
    # allocate wild planets using whichever color ships remain (yellow->blue->brown priority)
    wild_left = max(0, wild)
    for color_key, need in [("yellow", rem_y), ("blue", rem_b), ("brown", rem_r)]:
        if wild_left <= 0:
            break
        have = max(0, ships.get(color_key, 0) - (m if color_key=="yellow" else b if color_key=="blue" else r))
        take = min(need, have, wild_left)
        if color_key=="yellow": m += take
        elif color_key=="blue": b += take
        else: r += take
        wild_left -= take
    # Use wild colony ships to fill remaining across any planet types
    wships = max(0, ships.get("wild", 0))
    for need_key, need in [("yellow", money - m), ("blue", science - b), ("brown", materials - r)]:
        if wships <= 0:
            break
        take = min(need, wships)
        if need_key=="yellow": m += take
        elif need_key=="blue": b += take
        else: r += take
        wships -= take
    return {"money": m, "science": b, "materials": r}


===== FILE: eclipse_ai/species_data.py =====

"""Utilities for loading faction/species configuration data."""
from __future__ import annotations

from dataclasses import dataclass
import json
import os
from typing import Dict, Any, Optional


@dataclass(frozen=True)
class SpeciesConfig:
    """Immutable wrapper around a species configuration block."""

    species_id: str
    raw: Dict[str, Any]

    def get(self, key: str, default: Any = None) -> Any:
        return self.raw.get(key, default)

    @property
    def name(self) -> str:
        return self.raw.get("name", self.species_id)

    @property
    def expansion(self) -> str:
        return self.raw.get("expansion", "base")

    @property
    def trade_rate(self) -> Any:
        return self.raw.get("trade_rate")


class SpeciesRegistry:
    """Singleton-style registry that loads JSON data on demand."""

    def __init__(self, path: Optional[str] = None) -> None:
        self._path = path or os.path.join(os.path.dirname(__file__), "data", "species.json")
        self._data: Dict[str, SpeciesConfig] = {}
        self._meta: Dict[str, Any] = {}
        self._loaded = False

    def load(self) -> None:
        if self._loaded:
            return
        with open(self._path, "r", encoding="utf-8") as handle:
            payload = json.load(handle)
        self._meta = payload.get("_meta", {})
        species_entries = {k: v for k, v in payload.items() if not k.startswith("_")}
        for species_id, block in species_entries.items():
            self._data[species_id] = SpeciesConfig(species_id=species_id, raw=block)
        self._loaded = True

    @property
    def meta(self) -> Dict[str, Any]:
        self.load()
        return self._meta

    def get(self, species_id: str) -> SpeciesConfig:
        self.load()
        try:
            return self._data[species_id]
        except KeyError as exc:
            available = ", ".join(sorted(self._data))
            raise KeyError(f"Unknown species '{species_id}'. Available: {available}") from exc

    def all_species(self) -> Dict[str, SpeciesConfig]:
        self.load()
        return dict(self._data)


_registry: Optional[SpeciesRegistry] = None


def get_registry(path: Optional[str] = None) -> SpeciesRegistry:
    global _registry
    if _registry is None or path is not None:
        _registry = SpeciesRegistry(path=path)
    return _registry


def get_species(species_id: str) -> SpeciesConfig:
    return get_registry().get(species_id)


def all_species() -> Dict[str, SpeciesConfig]:
    return get_registry().all_species()

===== FILE: eclipse_ai/state_assembler.py =====

from __future__ import annotations
from typing import Optional, Dict, Any, Set
from collections import Counter
from dataclasses import dataclass
from copy import deepcopy

from .game_models import GameState, PlayerState, Resources, MapState, TechDisplay, Pieces
from .technology import load_tech_definitions
from .data.exploration_tiles import tile_counts_by_ring, tile_numbers_by_ring

_ROUND_EXPLORED_FRACTION = 0.33


@dataclass(frozen=True)
class _TileCatalog:
    total_by_ring: Dict[int, int]
    tile_ids_by_ring: Dict[int, Set[str]]
    all_tile_ids: Set[str]


def _load_tile_catalog() -> _TileCatalog:
    """Read the exploration tile CSV and index counts by ring."""
    totals_map = tile_counts_by_ring()
    numbers_map = tile_numbers_by_ring()
    if not totals_map:
        return _TileCatalog(total_by_ring={}, tile_ids_by_ring={}, all_tile_ids=set())

    all_ids = set().union(*(set(ids) for ids in numbers_map.values())) if numbers_map else set()
    return _TileCatalog(
        total_by_ring=dict(totals_map),
        tile_ids_by_ring={ring: set(ids) for ring, ids in numbers_map.items()},
        all_tile_ids=all_ids,
    )


_TILE_CATALOG = _load_tile_catalog()

# -----------------------------
# Public API
# -----------------------------

def assemble_state(
    map_state: MapState,
    tech_display: TechDisplay,
    prior_state: Optional[GameState]=None,
    manual_inputs: Optional[Dict[str,Any]]=None
) -> GameState:
    """
    Combine parsed board + tech into a canonical GameState.

    Rules:
      - If prior_state is provided, it is deep-copied then updated in place.
      - Players discovered from the board are auto-added with neutral defaults.
      - Bags are ensured for any rings observed on the map. Existing bag counts are preserved.
      - manual_inputs can be nested dicts or dot-path overrides (e.g., "players.you.resources.money": 12).
    """
    gs = deepcopy(prior_state) if prior_state is not None else _default_state()
    if not gs.tech_definitions:
        gs.tech_definitions = load_tech_definitions()
    # Update core
    gs.map = map_state
    gs.tech_display = tech_display

    # Ensure players seen on the board exist
    _reconcile_players_from_map(gs)

    # Ensure bag placeholders for observed rings
    _ensure_bags_for_rings(gs)
    _populate_explore_bags(gs)

    # Ensure player tech state derived from any known tech lists remains consistent.
    for p in gs.players.values():
        _initialise_player_state(p, gs.tech_definitions)

    # Apply manual inputs
    if manual_inputs:
        _apply_manual_inputs(gs, manual_inputs)
        for p in gs.players.values():
            _initialise_player_state(p, gs.tech_definitions)

    _validate_existing_designs(gs)

    return gs

# -----------------------------
# Defaults and reconciliation
# -----------------------------

def from_dict(fake_state: Dict[str, Any]) -> GameState:
    """Build a GameState directly from a test dict."""
    return GameState.from_dict(fake_state)


def apply_overrides(state: GameState, manual_inputs: Dict[str, Any]) -> GameState:
    """Apply targeted overrides onto an existing state."""
    if not manual_inputs:
        return state
    # Special-case persisted belief if you use it
    belief = manual_inputs.pop("belief", None)
    state.apply_overrides(manual_inputs)
    if belief is not None:
        # allow full replacement or merge, depending on your belief type
        try:
            state.belief = belief if not hasattr(state.belief, "apply_overrides") else state.belief.apply_overrides(belief)
        except Exception:
            state.belief = belief
    return state

def _default_state() -> GameState:
    players = {
        "you": PlayerState(player_id="you", color="orange", resources=Resources(10,7,6), influence_discs=3),
        "blue": PlayerState(player_id="blue", color="blue", resources=Resources(8,6,7), influence_discs=3)
    }
    gs = GameState(round=6, active_player="you", players=players, map=MapState(), tech_display=TechDisplay())
    for p in gs.players.values():
        _initialise_player_state(p, gs.tech_definitions)
    gs.tech_definitions = load_tech_definitions()
    # Provide a minimal example bag so exploration math runs. Caller should replace with real counts.
    gs.bags = {"R2": {"ancient":3, "monolith":1, "money2":4, "science2":4, "materials2":4}}
    return gs

def _reconcile_players_from_map(gs: GameState) -> None:
    # Discover player ids present in map pieces
    present: Set[str] = set(gs.players.keys())
    for hx in gs.map.hexes.values():
        for pid in hx.pieces.keys():
            if pid not in present:
                present.add(pid)
                # Neutral defaults
                new_player = PlayerState(player_id=pid, color=pid, resources=Resources(6,6,6))
                _initialise_player_state(new_player, gs.tech_definitions)
                gs.players[pid] = new_player
            # Ensure Pieces data structure is well-formed
            p = hx.pieces[pid]
            if p.cubes is None:
                p.cubes = {}
            if p.ships is None:
                p.ships = {}

def _ensure_bags_for_rings(gs: GameState) -> None:
    rings = set()
    for hx in gs.map.hexes.values():
        rings.add(max(1, int(getattr(hx, "ring", 1))))
    if not hasattr(gs, "bags") or gs.bags is None:
        gs.bags = {}
    for r in sorted(rings):
        key = f"R{r}"
        if key not in gs.bags:
            gs.bags[key] = {}  # placeholder; upstream uncertainty module can populate a PF on demand


def _populate_explore_bags(gs: GameState) -> None:
    """Backfill exploration bag sizes using CSV totals and board state."""
    if not _TILE_CATALOG.total_by_ring:
        return
    round_num = max(1, int(getattr(gs, "round", 1)))
    player_count = max(1, len(getattr(gs, "players", {}) or {}))
    explored_by_ring = _count_explored_tiles(gs, player_count)

    for ring, total in _TILE_CATALOG.total_by_ring.items():
        key = f"R{ring}"
        bag = gs.bags.setdefault(key, {})
        if bag and sum(bag.values()) > 0:
            # Caller already supplied explicit bag contents; trust it.
            continue

        # Estimate explored tiles either from the board or heuristic round progression.
        heuristic = int(total * min(1.0, max(0.0, (round_num - 1) * _ROUND_EXPLORED_FRACTION)))
        explored = max(explored_by_ring.get(ring, 0), heuristic)
        remaining = max(0, total - explored)

        if remaining > 0:
            gs.bags[key] = {"unknown": remaining}
        else:
            gs.bags[key] = {}


def _count_explored_tiles(gs: GameState, player_count: int) -> Counter[int]:
    counts: Counter[int] = Counter()
    fallback: Counter[int] = Counter()
    for hx in gs.map.hexes.values():
        ring = max(1, int(getattr(hx, "ring", 1)))
        fallback[ring] += 1
        hid = str(getattr(hx, "id", "")).strip()
        if hid and hid in _TILE_CATALOG.tile_ids_by_ring.get(ring, set()):
            counts[ring] += 1

    for ring, fallback_count in fallback.items():
        if counts[ring] >= fallback_count:
            continue
        additional = fallback_count - counts[ring]
        if ring == 1:
            additional = max(0, additional - player_count)
        if additional > 0:
            counts[ring] += additional

    return counts


def _initialise_player_state(player: PlayerState, definitions: Optional[Dict[str, "Tech"]]=None) -> None:
    from .technology import load_tech_definitions  # local import to avoid cycles

    tech_defs = definitions or load_tech_definitions()
    player.science = int(player.science or player.resources.science)
    if player.influence_discs is None:
        player.influence_discs = 0
    player.influence_discs = int(player.influence_discs)
    player.owned_tech_ids = set(player.owned_tech_ids or set())
    player.tech_count_by_category = dict(player.tech_count_by_category or {})
    player.unlocked_parts = set(player.unlocked_parts or set())
    player.unlocked_structures = set(player.unlocked_structures or set())
    player.species_flags = dict(player.species_flags or {})
    player.action_overrides = dict(player.action_overrides or {})
    player.build_overrides = dict(player.build_overrides or {})
    player.move_overrides = dict(player.move_overrides or {})
    player.explore_overrides = dict(player.explore_overrides or {})
    player.cannot_build = set(player.cannot_build or set())
    player.vp_bonuses = dict(player.vp_bonuses or {})
    player.species_pools = dict(player.species_pools or {})
    player.special_resources = dict(player.special_resources or {})

    name_to_id = {t.name.lower(): tid for tid, t in tech_defs.items()}
    for entry in list(player.known_techs or []):
        tid = name_to_id.get(entry.lower())
        if tid:
            player.owned_tech_ids.add(tid)

    # Recompute caches from owned techs
    player.tech_count_by_category.clear()
    player.unlocked_parts.clear()
    player.unlocked_structures.clear()
    for tid in list(player.owned_tech_ids):
        tech = tech_defs.get(tid)
        if not tech:
            continue
        player.tech_count_by_category[tech.category] = player.tech_count_by_category.get(tech.category, 0) + 1
        player.unlocked_parts.update(tech.grants_parts)
        player.unlocked_structures.update(tech.grants_structures)
        if tech.name not in player.known_techs:
            player.known_techs.append(tech.name)
            
def _validate_existing_designs(gs: GameState) -> None:
    try:
        from .rules_engine import validate_design
    except ImportError:
        return

    for player in gs.players.values():
        for ship_type, design in (player.ship_designs or {}).items():
            try:
                validate_design(player, ship_type, design)
            except Exception:
                raise

# -----------------------------
# Manual inputs
# -----------------------------

def _apply_manual_inputs(gs: GameState, manual: Dict[str,Any]) -> None:
    """
    Supports two forms:
      1) Nested dicts mirroring GameState structure for deep merge.
      2) Dot-path keys for targeted sets, e.g. {"players.you.resources.money": 12}
    """
    # Split dot-path keys from nested dict blocks
    dot_items = {k:v for k,v in manual.items() if isinstance(k, str) and "." in k}
    tree_items = {k:v for k,v in manual.items() if k not in dot_items}

    # Deep merge dict-style patches
    if tree_items:
        _deep_merge_object(gs, tree_items)

    # Dot-path sets
    for path, value in dot_items.items():
        _set_by_path(gs, path, value)

def _deep_merge_object(obj: Any, patch: Dict[str,Any]) -> None:
    """
    Recursively merge dictionaries into dataclass-like objects by attribute.
    """
    for key, val in patch.items():
        if not hasattr(obj, key):
            # create attribute if missing
            setattr(obj, key, deepcopy(val))
            continue
        curr = getattr(obj, key)
        if isinstance(val, dict) and not isinstance(curr, (int, float, str, list, tuple, set)):
            _deep_merge_object(curr, val)
        else:
            setattr(obj, key, deepcopy(val))

def _set_by_path(root: Any, path: str, value: Any) -> None:
    parts = path.split(".")
    obj = root
    for p in parts[:-1]:
        if isinstance(obj, dict):
            obj = obj.setdefault(p, {})
        else:
            if not hasattr(obj, p) or getattr(obj, p) is None:
                setattr(obj, p, {})
            obj = getattr(obj, p)
    last = parts[-1]
    if isinstance(obj, dict):
        obj[last] = value
    else:
        setattr(obj, last, value)

===== FILE: eclipse_ai/tech_parser.py =====


from __future__ import annotations
from dataclasses import dataclass, field
from typing import Dict, Any, List, Optional, Tuple
import os, json, re

from .game_models import TechDisplay

# Optional deps
try:
    import cv2  # type: ignore
    import numpy as np  # type: ignore
except Exception:  # pragma: no cover
    cv2 = None  # type: ignore
    np = None   # type: ignore

try:
    import pytesseract  # type: ignore
except Exception:  # pragma: no cover
    pytesseract = None  # type: ignore

# ==================================
# Config
# ==================================

@dataclass
class TechParseConfig:
    prefer_sidecar: bool = True
    enable_ocr: bool = True
    min_area: int = 2_000
    max_area_ratio: float = 0.2      # ignore huge rectangles
    rect_eps: float = 0.02           # approxPolyDP epsilon factor
    dedupe_similarity: float = 0.80  # Jaccard similarity to dedupe OCR strings
    # Fallback known tech tokens for normalization (subset; extend as needed)
    known_tokens: List[str] = field(default_factory=lambda: [
        "PLASMA CANNON", "POSITRON COMPUTER", "FUSION DRIVE", "GAUSS SHIELD",
        "ION CANNON", "ANTIMATTER CANNON", "ADVANCED MINING", "ADVANCED LABS",
        "WORMHOLE GENERATOR", "NANOROBOTS", "PHASE SHIELD", "IMPROVED HULL",
        "ELECTRONIC COUNTERMEASURES", "GLUON COMPUTER", "PLASMA MISSILES",
    ])

# ==================================
# Public API
# ==================================

def parse_tech(cal_img, config: Optional[TechParseConfig]=None) -> TechDisplay:
    """
    Parse the public tech display.
    Priority:
      1) Sidecar JSON: <image>.tech.json or <image>.annotations.json["tech_display"]
      2) OCR over detected rectangular tech tiles (OpenCV + pytesseract)
      3) Fallback minimal stub
    """
    cfg = config or TechParseConfig()

    # 1) Sidecar
    if cfg.prefer_sidecar:
        side = _load_sidecar(cal_img.path)
        if side:
            return _from_sidecar(side)

    # 2) OCR if possible
    if cfg.enable_ocr and cv2 is not None and np is not None and pytesseract is not None:
        try:
            img = cv2.imread(cal_img.path, cv2.IMREAD_COLOR)
            if img is not None:
                tiles = _detect_tile_rects(img, cfg)
                texts = _ocr_tiles(img, tiles)
                cleaned = _normalize_texts(texts, cfg.known_tokens)
                tiers = _infer_tiers_from_positions(tiles, img.shape[:2], cleaned)
                available = sorted(cleaned)
                return TechDisplay(available=available, tier_counts=tiers)
        except Exception:
            pass

    # 3) Fallback
    return TechDisplay(available=["Plasma Cannon","Fusion Drive","Positron Computer"], tier_counts={"I":6,"II":5,"III":4})

# ==================================
# Sidecar
# ==================================

def _sidecar_paths(img_path: str) -> List[str]:
    cands = [img_path + ".tech.json", img_path + ".annotations.json"]
    return [p for p in cands if os.path.exists(p)]

def _load_sidecar(img_path: str) -> Optional[Dict[str, Any]]:
    for p in _sidecar_paths(img_path):
        try:
            with open(p, "r", encoding="utf-8") as f:
                data = json.load(f)
            # If it's an annotations blob, extract subkey
            if p.endswith(".annotations.json") and isinstance(data, dict) and "tech_display" in data:
                return data["tech_display"]
            return data
        except Exception:
            continue
    return None

def _from_sidecar(data: Dict[str, Any]) -> TechDisplay:
    avail = list(data.get("available", []))
    tiers = dict(data.get("tier_counts", {}))
    # Ensure all three tiers exist
    for k in ("I","II","III"):
        tiers.setdefault(k, 0)
    return TechDisplay(available=avail, tier_counts=tiers)

# ==================================
# CV + OCR
# ==================================

def _detect_tile_rects(img, cfg: TechParseConfig) -> List[Tuple[int,int,int,int]]:
    """
    Return list of bounding boxes (x,y,w,h) for likely tech tiles.
    Approach: Canny -> contours -> quadrilateral-ish with reasonable aspect and area.
    """
    H, W = img.shape[:2]
    gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
    blur = cv2.GaussianBlur(gray, (3,3), 0)
    edges = cv2.Canny(blur, 60, 180)
    cnts, _ = cv2.findContours(edges, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
    rects: List[Tuple[int,int,int,int]] = []
    for c in cnts:
        area = cv2.contourArea(c)
        if area < cfg.min_area or area > cfg.max_area_ratio * (H*W):
            continue
        peri = cv2.arcLength(c, True)
        approx = cv2.approxPolyDP(c, cfg.rect_eps * peri, True)
        x,y,w,h = cv2.boundingRect(approx)
        aspect = w / float(h) if h>0 else 1.0
        # Tech tiles tend to be rectangular moderately wide
        if 1.2 <= aspect <= 3.5 and h >= 20 and w >= 40:
            rects.append((x,y,w,h))
    # Non-maximum suppression by IoU to dedupe overlapping rects
    rects = _nms(rects, iou_thresh=0.3)
    # Sort top-to-bottom, then left-to-right
    rects.sort(key=lambda r: (r[1], r[0]))
    return rects[:24]  # cap

def _nms(rects: List[Tuple[int,int,int,int]], iou_thresh: float=0.3) -> List[Tuple[int,int,int,int]]:
    out: List[Tuple[int,int,int,int]] = []
    for r in sorted(rects, key=lambda r: r[2]*r[3], reverse=True):
        keep = True
        for q in out:
            if _iou(r, q) > iou_thresh:
                keep = False
                break
        if keep:
            out.append(r)
    return out

def _iou(a, b) -> float:
    ax,ay,aw,ah = a
    bx,by,bw,bh = b
    x1, y1 = max(ax, bx), max(ay, by)
    x2, y2 = min(ax+aw, bx+bw), min(ay+ah, by+bh)
    iw, ih = max(0, x2-x1), max(0, y2-y1)
    inter = iw*ih
    union = aw*ah + bw*bh - inter
    return inter/union if union>0 else 0.0

def _ocr_tiles(img, rects: List[Tuple[int,int,int,int]]) -> List[Tuple[str, Tuple[int,int,int,int]]]:
    results: List[Tuple[str, Tuple[int,int,int,int]]] = []
    if pytesseract is None:
        return results
    for (x,y,w,h) in rects:
        roi = img[y:y+h, x:x+w]
        # preprocess for OCR
        gray = cv2.cvtColor(roi, cv2.COLOR_BGR2GRAY)
        # invert if mostly dark background
        if gray.mean() < 100:
            _, th = cv2.threshold(gray, 0, 255, cv2.THRESH_BINARY_INV + cv2.THRESH_OTSU)
        else:
            _, th = cv2.threshold(gray, 0, 255, cv2.THRESH_BINARY + cv2.THRESH_OTSU)
        config = "--psm 6 --oem 3 -l eng"
        try:
            txt = pytesseract.image_to_string(th, config=config)
        except Exception:
            txt = ""
        cleaned = _clean_text(txt)
        if cleaned:
            results.append((cleaned, (x,y,w,h)))
    return results

def _clean_text(t: str) -> str:
    t = t.upper()
    t = re.sub(r'[^A-Z ]+', ' ', t)
    t = re.sub(r'\s+', ' ', t).strip()
    return t

def _normalize_texts(texts: List[Tuple[str, Tuple[int,int,int,int]]], known_tokens: List[str]) -> List[str]:
    # Map OCR outputs to known tokens by simple containment or Jaccard similarity; else keep as-is
    out: List[str] = []
    for s, _ in texts:
        best = None
        best_sim = 0.0
        for k in known_tokens:
            sim = _jaccard(_token_set(s), _token_set(k))
            if sim > best_sim:
                best, best_sim = k, sim
        if best and best_sim >= 0.5:
            out.append(_title(best))
        else:
            out.append(_title(s))
    # Deduplicate while preserving order
    seen = set()
    uniq = []
    for s in out:
        if s not in seen:
            seen.add(s)
            uniq.append(s)
    return uniq

def _infer_tiers_from_positions(tiles: List[Tuple[int,int,int,int]], shape: Tuple[int,int], texts: List[str]) -> Dict[str, int]:
    H, W = shape
    # Partition by y-location band thirds: top=I, mid=II, low=III
    counts = {"I":0,"II":0,"III":0}
    for (_, y, _w, h) in tiles[:len(texts)]:
        cy = y + h/2.0
        if cy < H/3.0:
            counts["I"] += 1
        elif cy < 2*H/3.0:
            counts["II"] += 1
        else:
            counts["III"] += 1
    return counts

def _token_set(s: str) -> set:
    return set(_clean_text(s).split())

def _jaccard(a: set, b: set) -> float:
    if not a and not b:
        return 1.0
    inter = len(a & b)
    union = len(a | b) or 1
    return inter / union

def _title(s: str) -> str:
    return " ".join(w.capitalize() for w in s.split())

===== FILE: eclipse_ai/technology.py =====

from __future__ import annotations

import json
from pathlib import Path
from typing import Dict, List, Optional, Set, Tuple

from .game_models import GameState, PlayerState, Tech
from .research import discounted_cost as _expansion_discounted_cost, can_afford


class ResearchError(RuntimeError):
    """Raised when a research action is illegal."""


_TECH_DATA_CACHE: Optional[Dict[str, Tech]] = None


MARKET_SIZES_BY_PLAYER_COUNT = {
    2: 4,
    3: 5,
    4: 6,
    5: 7,
    6: 8,
}


def _tech_data_path() -> Path:
    return Path(__file__).resolve().parent / "data" / "tech.json"


def load_tech_definitions() -> Dict[str, Tech]:
    """Load the canonical tech definitions from disk (cached)."""

    global _TECH_DATA_CACHE
    if _TECH_DATA_CACHE is not None:
        return _TECH_DATA_CACHE

    path = _tech_data_path()
    try:
        with path.open("r", encoding="utf-8") as handle:
            raw = json.load(handle)
    except FileNotFoundError as exc:  # pragma: no cover - configuration error
        raise ResearchError(f"technology data file missing: {path}") from exc

    entries = raw.get("techs", raw) if isinstance(raw, dict) else raw

    catalog: Dict[str, Tech] = {}
    for entry in entries:
        if not isinstance(entry, dict):
            continue
        category = str(entry.get("category", "grid")).lower()
        base_cost = int(entry.get("base_cost", entry.get("min_cost", 4)))
        cost_range = entry.get("cost_range") or [base_cost, entry.get("max_cost", base_cost)]
        if isinstance(cost_range, list) and len(cost_range) == 2:
            cost_tuple = (int(cost_range[0]), int(cost_range[1]))
        else:
            cost_tuple = (base_cost, base_cost)

        parts = entry.get("grants_parts", entry.get("unlocks_parts", [])) or []
        structs = entry.get("grants_structures", entry.get("unlocks_structures", [])) or []

        tech = Tech(
            id=entry["id"],
            name=entry.get("name", entry["id"]),
            category=category,
            base_cost=base_cost,
            is_rare=bool(entry.get("is_rare", False)),
            cost_range=cost_tuple,
            grants_parts=list(parts),
            grants_structures=list(structs),
            immediate_effect=entry.get("immediate_effect"),
        )
        catalog[tech.id] = tech
        catalog.setdefault(tech.name, tech)

    _TECH_DATA_CACHE = catalog
    return catalog


def discounted_cost(player: PlayerState, tech: Tech, band_cost: Optional[int] = None) -> int:
    """Return the Science cost after applying category discounts."""

    return _expansion_discounted_cost(player, tech, band_cost)


def _assert_phase_is_action(state: GameState) -> None:
    if state.phase.lower() != "action":
        raise ResearchError("cannot research during Reaction")


def _assert_disc_available(player: PlayerState) -> None:
    if player.influence_discs <= 0:
        raise ResearchError("no influence discs available for Research")


def _market_size_for_players(state: GameState) -> int:
    count = max(2, len(state.players) or 2)
    return MARKET_SIZES_BY_PLAYER_COUNT.get(count, 8)


def _market_without_duplicates(state: GameState, taken_rare_ids: Set[str]) -> List[str]:
    """Return the market list filtered for duplicates and illegal rares."""

    seen: Set[str] = set()
    filtered: List[str] = []
    for tech_id in state.market:
        if tech_id in seen:
            continue
        tech = state.tech_definitions.get(tech_id)
        if tech is None:
            continue
        if tech.is_rare and tech_id in taken_rare_ids:
            continue
        seen.add(tech_id)
        filtered.append(tech_id)
    return filtered


def cleanup_refresh_market(state: GameState) -> None:
    """Refill the face-up market from the draw bags during Cleanup."""

    if not state.tech_definitions:
        state.tech_definitions = load_tech_definitions()

    taken_rares: Set[str] = set()
    for player in state.players.values():
        for tech_id in player.owned_tech_ids:
            tech = state.tech_definitions.get(tech_id)
            if tech and tech.is_rare:
                taken_rares.add(tech_id)

    state.market = _market_without_duplicates(state, taken_rares)
    target = _market_size_for_players(state)
    if len(state.market) >= target:
        state.market = state.market[:target]
        return

    # Draw from bags in key order (tiers typically I < II < III).
    for bag_name in sorted(state.tech_bags.keys()):
        bag = state.tech_bags[bag_name]
        draw_index = 0
        while draw_index < len(bag) and len(state.market) < target:
            tech_id = bag[draw_index]
            tech = state.tech_definitions.get(tech_id)
            draw_index += 1
            if tech is None:
                continue
            if tech.is_rare and tech_id in taken_rares:
                continue
            if tech_id in state.market:
                continue
            state.market.append(tech_id)

        # Remove the tiles that were effectively drawn.
        if draw_index > 0:
            del bag[:draw_index]
        if len(state.market) >= target:
            break


def can_research(state: GameState, player: PlayerState, tech_id: str) -> bool:
    try:
        validate_research(state, player, tech_id)
        return True
    except ResearchError:
        return False


def validate_research(state: GameState, player: PlayerState, tech_id: str) -> None:
    """Raise ResearchError if the research action is illegal."""

    if not state.tech_definitions:
        state.tech_definitions = load_tech_definitions()

    _assert_phase_is_action(state)
    _assert_disc_available(player)

    if tech_id not in state.market:
        raise ResearchError("tech not available in market")

    tech = state.tech_definitions.get(tech_id)
    if tech is None:
        raise ResearchError("unknown technology id")

    if tech.is_rare and tech_id in player.owned_tech_ids:
        raise ResearchError("Rare tech already taken")

    if tech_id in player.owned_tech_ids:
        raise ResearchError("technology already owned")

    if tech.is_rare:
        for other in state.players.values():
            if other is player:
                continue
            if tech_id in other.owned_tech_ids:
                raise ResearchError("Rare tech already taken")

    cost = discounted_cost(player, tech)
    if not can_afford(player, tech):
        raise ResearchError("insufficient Science after discount")


def _apply_immediate_effect(state: GameState, player: PlayerState, tech: Tech) -> None:
    effect = tech.immediate_effect or {}
    if not isinstance(effect, dict):
        return

    if effect.get("science"):
        delta = int(effect["science"])
        player.science += delta
        player.resources.science = max(0, player.science)
    if effect.get("money"):
        delta = int(effect["money"])
        player.resources.money += delta
    if effect.get("materials"):
        delta = int(effect["materials"])
        player.resources.materials += delta


def _recompute_category_cache(player: PlayerState, definitions: Dict[str, Tech]) -> None:
    counts: Dict[str, int] = {}
    for tech_id in player.owned_tech_ids:
        tech = definitions.get(tech_id)
        if tech is None:
            continue
        counts[tech.category] = counts.get(tech.category, 0) + 1
    player.tech_count_by_category = counts


def _unlock_from_tech(player: PlayerState, tech: Tech) -> None:
    if tech.grants_parts:
        player.unlocked_parts.update(tech.grants_parts)
    if tech.grants_structures:
        player.unlocked_structures.update(tech.grants_structures)


def do_research(state: GameState, player: PlayerState, tech_id: str) -> None:
    """Execute the research action for the player."""

    validate_research(state, player, tech_id)
    tech = state.tech_definitions[tech_id]
    cost = discounted_cost(player, tech)

    player.influence_discs -= 1
    player.science -= cost
    player.resources.science = max(0, player.science)

    state.market = [tid for tid in state.market if tid != tech_id]
    player.owned_tech_ids.add(tech_id)
    if tech.name not in player.known_techs:
        player.known_techs.append(tech.name)
    _unlock_from_tech(player, tech)
    _recompute_category_cache(player, state.tech_definitions)
    _apply_immediate_effect(state, player, tech)


def ensure_structure_allowed(player: PlayerState, structure: str) -> None:
    if structure not in player.unlocked_structures:
        raise ResearchError("required technology not owned")


def ensure_part_allowed(player: PlayerState, part: str) -> None:
    if part not in player.unlocked_parts:
        raise ResearchError("required technology not owned")

===== FILE: eclipse_ai/types.py =====

"""Shared lightweight dataclasses used across the rules engine."""

from __future__ import annotations

from dataclasses import dataclass, field
from typing import Dict, Literal, Tuple, TypedDict


class Tech(TypedDict):
    id: str
    name: str
    category: Literal["Military", "Grid", "Nano", "Rare"]
    is_rare: bool
    base_cost: int
    cost_range: Tuple[int, int]


@dataclass
class ShipDesign:
    """A ship blueprint broken down by part category.

    The legacy aggregate fields (computer/shield/etc.) are retained for
    compatibility with existing evaluation and combat code. Validators are
    expected to keep them in sync with the underlying part dictionaries.
    """

    computer: int = 0
    shield: int = 0
    initiative: int = 0
    hull: int = 1
    cannons: int = 0
    missiles: int = 0
    drive: int = 0

    computer_parts: Dict[str, int] = field(default_factory=dict)
    shield_parts: Dict[str, int] = field(default_factory=dict)
    cannon_parts: Dict[str, int] = field(default_factory=dict)
    missile_parts: Dict[str, int] = field(default_factory=dict)
    drive_parts: Dict[str, int] = field(default_factory=dict)
    energy_sources: Dict[str, int] = field(default_factory=dict)
    hull_parts: Dict[str, int] = field(default_factory=dict)

    movement_value: int = 0
    energy_consumption: int = 0
    energy_production: int = 0

    def clone(self) -> "ShipDesign":
        """Deep-copy mutable dictionaries for safe manipulation."""

        return ShipDesign(
            computer=self.computer,
            shield=self.shield,
            initiative=self.initiative,
            hull=self.hull,
            cannons=self.cannons,
            missiles=self.missiles,
            drive=self.drive,
            computer_parts=dict(self.computer_parts),
            shield_parts=dict(self.shield_parts),
            cannon_parts=dict(self.cannon_parts),
            missile_parts=dict(self.missile_parts),
            drive_parts=dict(self.drive_parts),
            energy_sources=dict(self.energy_sources),
            hull_parts=dict(self.hull_parts),
            movement_value=self.movement_value,
            energy_consumption=self.energy_consumption,
            energy_production=self.energy_production,
        )

    # Convenience accessors for compatibility with legacy code that expects a
    # cannon breakdown by colour or missile count by type.
    def cannon_breakdown(self) -> Dict[str, int]:
        return dict(self.cannon_parts)

    def missile_breakdown(self) -> Dict[str, int]:
        return dict(self.missile_parts)

    def drive_count(self) -> int:
        return sum(self.drive_parts.values())


===== FILE: eclipse_ai/uncertainty.py =====

from __future__ import annotations
from dataclasses import dataclass, field
from typing import Dict, List, Tuple, Optional, Any
import math, random
from collections import Counter

# -------- utilities --------

def _logcomb(n: int, k: int) -> float:
    """log(binomial(n,k)) via lgamma; returns -inf if invalid."""
    from math import lgamma
    if k < 0 or k > n:
        return float("-inf")
    return lgamma(n + 1) - lgamma(k + 1) - lgamma(n - k + 1)

# -------- Discrete HMM for enemy ship-design archetypes --------

@dataclass
class DiscreteHMM:
    states: List[str]
    observations: List[str]
    start_prob: Dict[str, float]
    trans_prob: Dict[Tuple[str,str], float]  # (s->s')
    emit_prob: Dict[Tuple[str,str], float]   # (s,obs)
    _min_p: float = 1e-12

    def _norm(self, d: Dict[str,float]) -> Dict[str,float]:
        total = sum(d.values())
        if total <= 0:
            n = 1.0/len(d) if d else 0.0
            return {k:n for k in d}
        return {k:max(self._min_p, v/total) for k,v in d.items()}

    def forward(self, obs_seq: List[str]) -> List[Dict[str,float]]:
        if not obs_seq:
            return []
        alpha: List[Dict[str,float]] = []
        a0 = {}
        for s in self.states:
            a0[s] = max(self._min_p, self.start_prob.get(s, self._min_p) * self.emit_prob.get((s, obs_seq[0]), self._min_p))
        a0 = self._norm(a0)
        alpha.append(a0)
        for t in range(1, len(obs_seq)):
            at = {}
            for s in self.states:
                summ = 0.0
                for sp, ap in alpha[t-1].items():
                    summ += ap * self.trans_prob.get((sp, s), self._min_p)
                at[s] = max(self._min_p, summ * self.emit_prob.get((s, obs_seq[t]), self._min_p))
            alpha.append(self._norm(at))
        return alpha

    def viterbi(self, obs_seq: List[str]) -> List[str]:
        if not obs_seq:
            return []
        V: List[Dict[str,float]] = []
        path: Dict[str, List[str]] = {s:[s] for s in self.states}
        v0 = {}
        for s in self.states:
            v0[s] = math.log(self.start_prob.get(s, self._min_p)) + math.log(self.emit_prob.get((s, obs_seq[0]), self._min_p))
        V.append(v0)
        for t in range(1, len(obs_seq)):
            Vt: Dict[str,float] = {}
            new_path: Dict[str,List[str]] = {}
            for s in self.states:
                best, best_s = -1e300, None
                for sp in self.states:
                    score = V[t-1][sp] + math.log(self.trans_prob.get((sp, s), self._min_p))
                    if score > best:
                        best, best_s = score, sp
                Vt[s] = best + math.log(self.emit_prob.get((s, obs_seq[t]), self._min_p))
                new_path[s] = path[best_s] + [s] if best_s else [s]
            V.append(Vt); path = new_path
        last = max(self.states, key=lambda s: V[-1][s])
        return path[last]

    def posterior(self, obs_seq: List[str]) -> Dict[str,float]:
        alpha = self.forward(obs_seq)
        return alpha[-1] if alpha else {s:1.0/len(self.states) for s in self.states}

    def posterior_with_forgetting(self, obs_seq: List[str], rho: float = 0.9) -> Dict[str, float]:
        """
        Exponential forgetting (rho in [0,1]). rho=1.0 -> standard forward.
        At each step, mix previous posterior with start distribution.
        """
        if not obs_seq:
            u = 1.0 / len(self.states)
            return {s: u for s in self.states}

        alpha = {}
        for s in self.states:
            alpha[s] = max(self._min_p, self.start_prob.get(s, self._min_p) *
                           self.emit_prob.get((s, obs_seq[0]), self._min_p))
        Z = sum(alpha.values()) or 1.0
        for s in alpha:
            alpha[s] = alpha[s] / Z

        for t in range(1, len(obs_seq)):
            prev = {sp: rho * alpha[sp] + (1.0 - rho) * self.start_prob.get(sp, self._min_p) for sp in self.states}
            at = {}
            for s in self.states:
                summ = 0.0
                for sp, ap in prev.items():
                    summ += ap * self.trans_prob.get((sp, s), self._min_p)
                at[s] = max(self._min_p, summ * self.emit_prob.get((s, obs_seq[t]), self._min_p))
            Z = sum(at.values()) or 1.0
            alpha = {s: at[s] / Z for s in self.states}
        return alpha

# -------- Particle filter for hidden sector tiles / bag composition --------

@dataclass
class TileParticle:
    bag: Dict[str,int]
    hidden_hex_types: Dict[str,str] = field(default_factory=dict)
    weight: float = 1.0

@dataclass
class TileParticleFilter:
    particles: List[TileParticle]
    min_particles: int = 256
    jitter: float = 0.0
    _min_w: float = 1e-20

    @staticmethod
    def from_bag(bag: Dict[str,int], n: int = 512) -> 'TileParticleFilter':
        pts = [TileParticle(bag=dict(bag), hidden_hex_types={}, weight=1.0) for _ in range(n)]
        return TileParticleFilter(particles=pts, min_particles=n)

    def predict(self):
        return

    def update_on_draw(self, drawn_type: str):
        for p in self.particles:
            total = sum(p.bag.values()) or 1
            like = max(self._min_w, p.bag.get(drawn_type, 0) / total)
            p.weight *= like
            if p.bag.get(drawn_type, 0) > 0:
                p.bag[drawn_type] -= 1
        self._normalize_and_resample()

    def update_on_peek(self, seen: Dict[str, int]):
        """
        Update weights after seeing a multiset of categories from a draw-and-look,
        then putting them back. Uses multivariate hypergeometric likelihood.
        """
        k = sum(int(v) for v in seen.values())
        if k <= 0:
            return
        for p in self.particles:
            total = sum(p.bag.values())
            if total < k:
                p.weight *= self._min_w
                continue
            loglike = -_logcomb(total, k)
            invalid = False
            for t, c in seen.items():
                c = int(c)
                bt = int(p.bag.get(t, 0))
                if c > bt:
                    invalid = True
                    break
                loglike += _logcomb(bt, c)
            if invalid:
                p.weight *= self._min_w
            else:
                p.weight *= max(self._min_w, math.exp(loglike))
        self._normalize_and_resample()

    def update_on_reveal(self, hex_id: str, tile_type: str):
        for p in self.particles:
            if hex_id in p.hidden_hex_types and p.hidden_hex_types[hex_id] != tile_type:
                p.weight *= self._min_w
            p.hidden_hex_types[hex_id] = tile_type
            if p.bag.get(tile_type, 0) > 0:
                p.bag[tile_type] -= 1
        self._normalize_and_resample()

    def marginal_bag(self) -> Dict[str,float]:
        tot_w = sum(p.weight for p in self.particles) or 1.0
        agg: Dict[str,float] = Counter()
        for p in self.particles:
            for k,v in p.bag.items():
                agg[k] += p.weight * v
        return {k: agg[k]/tot_w for k in agg}

    def _normalize_and_resample(self):
        tot = sum(p.weight for p in self.particles) or 1.0
        for p in self.particles:
            p.weight = max(self._min_w, p.weight / tot)
        ess = 1.0 / sum(p.weight**2 for p in self.particles)
        if ess < 0.5 * len(self.particles):
            self._systematic_resample()

    def _systematic_resample(self):
        N = len(self.particles)
        positions = [(random.random() + i)/N for i in range(N)]
        cumulative = []
        csum = 0.0
        for p in self.particles:
            csum += p.weight
            cumulative.append(csum)
        new_particles: List[TileParticle] = []
        i = 0
        for pos in positions:
            while pos > cumulative[i]:
                i += 1
            src = self.particles[i]
            new_particles.append(TileParticle(bag=dict(src.bag), hidden_hex_types=dict(src.hidden_hex_types), weight=1.0/N))
        self.particles = new_particles

# -------- Belief state composer --------

@dataclass
class BeliefState:
    hmm_by_player: Dict[str, DiscreteHMM] = field(default_factory=dict)
    obs_history_by_player: Dict[str, List[str]] = field(default_factory=dict)
    pf_by_bag: Dict[str, TileParticleFilter] = field(default_factory=dict)

    def ensure_enemy_model(self, player_id: str):
        if player_id not in self.hmm_by_player:
            states = ["brawler","turtle","missile_alpha","evasion"]
            obs = ["plasma","positron","fusion","gauss","shields","missiles","drive"]
            u = 1.0/len(states)
            start = {s:u for s in states}
            trans = {}
            for s1 in states:
                for s2 in states:
                    trans[(s1,s2)] = 0.7 if s1==s2 else 0.3/(len(states)-1)
            emit = {}
            for s in states:
                for o in obs:
                    base = 1.0/len(obs)
                    if s=="brawler" and o in ("plasma","positron"): base = 0.25
                    if s=="turtle" and o in ("shields","gauss"): base = 0.25
                    if s=="missile_alpha" and o=="missiles": base = 0.35
                    if s=="evasion" and o=="drive": base = 0.25
                    emit[(s,o)] = base
                tot = sum(emit[(s,o)] for o in obs)
                for o in obs:
                    emit[(s,o)] /= tot
            self.hmm_by_player[player_id] = DiscreteHMM(states, obs, start, trans, emit)
            self.obs_history_by_player[player_id] = []

    def observe_enemy_signal(self, player_id: str, signal: str):
        self.ensure_enemy_model(player_id)
        if signal not in self.hmm_by_player[player_id].observations:
            hmm = self.hmm_by_player[player_id]
            hmm.observations.append(signal)
            for s in hmm.states:
                hmm.emit_prob[(s, signal)] = 1e-6
        self.obs_history_by_player[player_id].append(signal)

    def enemy_posterior(self, player_id: str, rho: float = 1.0) -> Dict[str,float]:
        self.ensure_enemy_model(player_id)
        obs = self.obs_history_by_player[player_id]
        if not obs:
            u = 1.0/len(self.hmm_by_player[player_id].states)
            return {s:u for s in self.hmm_by_player[player_id].states}
        hmm = self.hmm_by_player[player_id]
        if rho >= 1.0:
            return hmm.posterior(obs)
        return hmm.posterior_with_forgetting(obs, rho=rho)

    def ensure_bag(self, bag_id: str, initial_bag: Dict[str,int], particles: int = 512):
        if bag_id not in self.pf_by_bag:
            self.pf_by_bag[bag_id] = TileParticleFilter.from_bag(initial_bag, n=particles)

    def draw_from_bag(self, bag_id: str, drawn_type: str):
        pf = self.pf_by_bag.get(bag_id)
        if not pf:
            return
        pf.update_on_draw(drawn_type)

    def reveal_hex_tile(self, bag_id: str, hex_id: str, tile_type: str):
        pf = self.pf_by_bag.get(bag_id)
        if not pf:
            return
        pf.update_on_reveal(hex_id, tile_type)

    def expected_bag(self, bag_id: str) -> Dict[str,float]:
        pf = self.pf_by_bag.get(bag_id)
        return pf.marginal_bag() if pf else {}

    def to_dict(self, include_particles: bool = False) -> Dict[str, Any]:
        out: Dict[str, Any] = {
            "obs_history_by_player": {k: list(v) for k, v in self.obs_history_by_player.items()},
            "bags": {}
        }
        for bag_id, pf in self.pf_by_bag.items():
            if include_particles:
                out["bags"][bag_id] = [
                    {"bag": dict(p.bag), "hidden": dict(p.hidden_hex_types), "w": float(p.weight)}
                    for p in pf.particles
                ]
            else:
                out["bags"][bag_id] = {
                    "expected": pf.marginal_bag(),
                    "n_particles": len(pf.particles)
                }
        return out

    @staticmethod
    def from_dict(data: Dict[str, Any]) -> "BeliefState":
        bs = BeliefState()
        bs.obs_history_by_player = {k: list(v) for k, v in data.get("obs_history_by_player", {}).items()}
        for bag_id, v in data.get("bags", {}).items():
            if isinstance(v, list):  # full particles
                parts = []
                for rec in v:
                    parts.append(
                        TileParticle(
                            bag=dict(rec.get("bag", {})),
                            hidden_hex_types=dict(rec.get("hidden", {})),
                            weight=float(rec.get("w", 1.0))
                        )
                    )
                bs.pf_by_bag[bag_id] = TileParticleFilter(particles=parts, min_particles=len(parts))
            elif isinstance(v, dict) and "expected" in v:  # summary only
                exp = v.get("expected", {})
                approx = {k: int(round(float(val))) for k, val in exp.items()}
                n = int(v.get("n_particles", 256))
                bs.pf_by_bag[bag_id] = TileParticleFilter.from_bag(approx, n=n)
        return bs

===== FILE: eclipse_ai/validators.py =====

from typing import Dict, Any, List, Tuple

from .rules_engine import legal_actions


class LegalityError(AssertionError):
    pass


def _fmt_action(a: Dict[str, Any]) -> str:
    t = a.get("action", a.get("type", ""))
    p = a.get("payload", {})
    return f"{t}:{p}"


def _extract_action_shape(candidate: Any) -> Tuple[Any, Dict[str, Any]]:
    """Return an action identifier and payload for dicts or dataclass actions."""
    if isinstance(candidate, dict):
        return (
            candidate.get("action") or candidate.get("type"),
            candidate.get("payload") or {},
        )
    act_type = getattr(candidate, "type", None)
    if hasattr(act_type, "value"):
        act_type = act_type.value
    payload = getattr(candidate, "payload", {}) or {}
    return act_type, payload


def _is_action_legal(state: Dict[str, Any], player_id: int, action: Dict[str, Any]) -> bool:
    allowed = legal_actions(state, player_id)
    # Normalize comparison: match on action type/name and required payload keys
    atype, payload = _extract_action_shape(action)
    have = set((payload or {}).keys())
    for candidate in allowed:
        cand_type, cand_payload = _extract_action_shape(candidate)
        if cand_type == atype:
            # Optional: shallow payload key subset check
            needed = set((cand_payload or {}).keys())
            if needed.issubset(have) or not needed:
                return True
    return False


def assert_test_case_legal(test: Dict[str, Any]) -> None:
    """
    Enforce legality before running a test.

    Required fields:
      test["state"]: full game state dict
      test["player_id"]: str | int
      test["proposed_action"]: {"action": str, "payload": dict}
    """
    state = test["state"]
    pid = test["player_id"]
    action = test["proposed_action"]

    if not _is_action_legal(state, pid, action):
        allowed = legal_actions(state, pid)
        allowed_str = ", ".join(_fmt_action(a) for a in allowed[:20])
        raise LegalityError(
            f"Illegal proposed_action for player {pid}: {_fmt_action(action)}. "
            f"Allowed now: [{allowed_str}]"
        )


def assert_plans_legal(output: Dict[str, Any], state: Dict[str, Any], player_id: int) -> None:
    """
    Enforce legality on engine output shaped like:
      output = {"plans":[{"steps":[{"action": str, "payload": {...}}, ...], "score":..., "risk":...}, ...]}
    Validates each step against current state, stepping state forward if your engine exposes a stepper.
    If no stepper, validate per-step against the original state (strict gate at least).

    Returns None or raises LegalityError.
    """
    plans: List[Dict[str, Any]] = output.get("plans", [])
    if not plans:
        return

    # Optional: if you have a state stepper, plug it here:
    # from .rules_engine import apply_action
    # cur_state = deepcopy(state)

    for p_idx, plan in enumerate(plans):
        steps = plan.get("steps", [])
        # cur_state = deepcopy(state)
        for s_idx, step in enumerate(steps):
            if not _is_action_legal(state, player_id, step):
                allowed = legal_actions(state, player_id)
                allowed_str = ", ".join(_fmt_action(a) for a in allowed[:20])
                raise LegalityError(
                    f"Plan {p_idx} step {s_idx} illegal: {_fmt_action(step)}. "
                    f"Allowed at check: [{allowed_str}]"
                )
            # If you have a true simulator, uncomment:
            # cur_state = apply_action(cur_state, player_id, step)

===== FILE: tests/Agent_Legality_Checklist.md =====

# Agent Legality Checklist

Goal: never produce illegal tests or illegal recommended actions.

## Required test case schema
- `state`  full game state dict the engine understands
- `player_id`  integer
- `proposed_action`  object with:
  - `action` (or `type`)  string
  - `payload`  dict (IDs, coords, costs, etc.)
- `provenance`  short string: how this test was generated
- `expectations`  optional oracle:
  - `should_be_legal`: true|false
  - `notes`: string

## Hard gate before submit
1. Call `validators.assert_test_case_legal(test)`  
   - If it raises, **do not submit**. Either fix payload or discard.
2. For recommendations you produce, call  
   `validators.assert_plans_legal(output, state, player_id)`  
   - If it raises, regenerate using only actions from `rules_engine.legal_actions(state, player_id)`.

## Generation rules
- Only propose actions present in `rules_engine.legal_actions(state, player_id)`.
- Do not fabricate components you do not own or cannot afford.
- Respect phase constraints:
  - Action allowed only in the current phase.
  - One action per action step unless the rules permit chains.
- Respect costs and limits:
  - Pay resources exactly. No negative banks. No exceeding tracks.
  - Ship part limits and hull slots respected.
  - Influence discs, colony ships, and diplomats must exist in supply.
- Respect map and ownership:
  - Only use explored hexes as required.
  - Only move across valid wormholes and within speed.
  - Only place/build where you have rights per rules.

## What to log on rejection
- `player_id`
- `_fmt_action(proposed_action)`
- Top 10 `legal_actions` at the time
- Diff of missing payload keys vs required keys
- Reason you chose the action (short text)

## Sanity list before finalizing
- Phase consistent
- Resources non-negative post-action
- Component and slot counts valid
- Movement path valid
- Target hex ownership and adjacency valid
- No duplicate steps that would violate one action limits

## CI expectations
- Unit: generator emits zero illegal tests across a seeded batch.
- Integration: planner outputs contain zero illegal steps on fixed fixtures.
- Any LegalityError fails CI.

===== FILE: tests/legal_cases/__init__.py =====

"""Curated legality test cases for regression checks."""

===== FILE: tests/legal_cases/orion_turn1.py =====

"""Legality fixtures for the Orion Hegemony opening."""
from __future__ import annotations

from typing import Any, Dict, List


_ORION_TURN1_ROUND1_4P: Dict[str, Any] = {
    "round": 1,
    "active_player": "P1",
    "phase": "ACTION",
    "turn_order": ["P1", "P2", "P3", "P4"],
    "players": {
        "P1": {
            "player_id": "P1",
            "color": "purple",
            "known_techs": ["Gauss Shield", "Neutron Bombs"],
            "resources": {"money": 3, "science": 1, "materials": 5},
            "ship_designs": {
                "interceptor": {
                    "computer": 1,
                    "shield": 1,
                    "initiative": 4,
                    "hull": 1,
                    "cannons": 1,
                    "missiles": 0,
                    "drive": 1,
                },
                "cruiser": {
                    "computer": 1,
                    "shield": 1,
                    "initiative": 3,
                    "hull": 2,
                    "cannons": 1,
                    "missiles": 0,
                    "drive": 1,
                },
            },
        },
        "P2": {
            "player_id": "P2",
            "color": "orange",
            "known_techs": [],
            "resources": {"money": 2, "science": 2, "materials": 2},
            "ship_designs": {
                "interceptor": {
                    "computer": 1,
                    "shield": 0,
                    "initiative": 2,
                    "hull": 1,
                    "cannons": 1,
                    "missiles": 0,
                    "drive": 1,
                },
            },
        },
        "P3": {
            "player_id": "P3",
            "color": "green",
            "known_techs": [],
            "resources": {"money": 3, "science": 1, "materials": 3},
            "ship_designs": {
                "interceptor": {
                    "computer": 1,
                    "shield": 0,
                    "initiative": 2,
                    "hull": 1,
                    "cannons": 1,
                    "missiles": 0,
                    "drive": 1,
                },
            },
        },
        "P4": {
            "player_id": "P4",
            "color": "white",
            "known_techs": [],
            "resources": {"money": 2, "science": 2, "materials": 2},
            "ship_designs": {
                "interceptor": {
                    "computer": 0,
                    "shield": 0,
                    "initiative": 2,
                    "hull": 1,
                    "cannons": 1,
                    "missiles": 0,
                    "drive": 1,
                },
            },
        },
    },
    "map": {
        "hexes": {
            "230": {
                "id": "230",
                "ring": 1,
                "planets": [
                    {"type": "yellow", "colonized_by": "P1"},
                    {"type": "blue", "colonized_by": "P1"},
                    {"type": "brown", "colonized_by": "P1"},
                ],
                "pieces": {
                    "P1": {
                        "ships": {"interceptor": 0, "cruiser": 1},
                        "starbase": 0,
                        "discs": 1,
                        "cubes": {"yellow": 1, "blue": 1, "brown": 1},
                    }
                },
            },
            "Terran": {
                "id": "Terran",
                "ring": 1,
                "planets": [
                    {"type": "yellow", "colonized_by": "P2"},
                    {"type": "blue", "colonized_by": "P2"},
                    {"type": "brown", "colonized_by": "P2"},
                ],
                "pieces": {
                    "P2": {
                        "ships": {"interceptor": 2},
                        "starbase": 0,
                        "discs": 1,
                        "cubes": {"yellow": 1, "blue": 1, "brown": 1},
                    }
                },
            },
            "Outer": {
                "id": "Outer",
                "ring": 2,
                "planets": [
                    {"type": "yellow", "colonized_by": None},
                    {"type": "blue", "colonized_by": None},
                ],
                "pieces": {},
            },
            "Sigma": {
                "id": "Sigma",
                "ring": 1,
                "planets": [
                    {"type": "yellow", "colonized_by": "P3"},
                    {"type": "blue", "colonized_by": "P3"},
                ],
                "pieces": {
                    "P3": {
                        "ships": {"interceptor": 2},
                        "starbase": 0,
                        "discs": 1,
                        "cubes": {"yellow": 1, "blue": 1},
                    }
                },
            },
            "Hydra": {
                "id": "Hydra",
                "ring": 1,
                "planets": [
                    {"type": "yellow", "colonized_by": "P4"},
                    {"type": "blue", "colonized_by": "P4"},
                ],
                "pieces": {
                    "P4": {
                        "ships": {"interceptor": 2},
                        "starbase": 0,
                        "discs": 1,
                        "cubes": {"yellow": 1, "blue": 1},
                    }
                },
            },
        }
    },
    "tech_display": {
        "available": [
            "Plasma Cannon I",
            "Fusion Drive I",
            "Advanced Mining",
            "Positron Computer",
            "Gauss Shield",
            "Neutron Absorber",
            "Advanced Robotics",
            "Quantum Grid",
            "Wormhole Generator",
            "Antimatter Cannon",
            "Nanorobots",
            "Improved Hull",
        ],
        "tier_counts": {"I": 6, "II": 4, "III": 2},
    },
    "bags": {"R1": {"unknown": 4}, "R2": {"unknown": 3}},
}

ORION_TURN1_TEST_CASES: List[Dict[str, Any]] = [
    {
        "state": _ORION_TURN1_ROUND1_4P,
        "player_id": "P1",
        "proposed_action": {
            "action": "Influence",
            "payload": {"hex": "Outer", "income_delta": {"yellow": 1, "blue": 0, "brown": 0}},
        },
        "provenance": "manual/orion_hegemony/round1/action1",
        "expectations": {"should_be_legal": True, "notes": "Influence the richest adjacent neutral hex."},
    }
]

===== FILE: tests/test_build_and_design.py =====

from __future__ import annotations

import pytest

from eclipse_ai.game_models import (
    GameState,
    MapState,
    PlayerState,
    Resources,
    Hex,
    Pieces,
    ShipDesign as LegacyShipDesign,
)
from eclipse_ai.rules_engine import (
    BUILD_COST,
    FLEET_CAP,
    RulesViolation,
    validate_build,
    validate_design,
)
from eclipse_ai.types import ShipDesign


def _base_player() -> PlayerState:
    player = PlayerState(
        player_id="P1",
        color="orange",
        known_techs=[],
        resources=Resources(money=5, science=5, materials=20),
    )
    player.available_components = {
        "interceptor": 8,
        "cruiser": 4,
        "dreadnought": 2,
        "starbase": 4,
        "orbital": 4,
        "monolith": 4,
    }
    return player


def _state_with_hex(player: PlayerState, hex_id: str = "H1") -> GameState:
    hx = Hex(
        id=hex_id,
        ring=1,
        pieces={
            player.player_id: Pieces(ships={}, starbase=0, discs=1, cubes={})
        },
    )
    state = GameState(
        round=1,
        active_player=player.player_id,
        players={player.player_id: player},
        map=MapState(hexes={hex_id: hx}),
    )
    return state


def test_upgrade_requires_researched_tech():
    player = _base_player()
    design = ShipDesign(
        computer_parts={"Electron Computer": 1},
        cannon_parts={"Ion Cannon": 1},
        drive_parts={"Fusion Drive": 1},
        energy_sources={"Nuclear Source": 1},
        hull_parts={"Hull": 1},
    )

    with pytest.raises(RulesViolation):
        validate_design(player, "interceptor", design)

    player.known_techs.append("Fusion Drive")
    validate_design(player, "interceptor", design)
    assert design.drive == 1
    assert design.movement_value == 2


def test_energy_balance_enforced():
    player = _base_player()
    player.known_techs.extend(["Plasma Cannon"])
    design = ShipDesign(
        cannon_parts={"Plasma Cannon": 1},
        drive_parts={"Nuclear Drive": 1},
        hull_parts={"Hull": 1},
    )

    with pytest.raises(RulesViolation):
        validate_design(player, "cruiser", design)

    design.energy_sources["Nuclear Source"] = 1
    validate_design(player, "cruiser", design)
    assert design.energy_production >= design.energy_consumption


def test_drive_required_mobile_starbase_no_drive():
    player = _base_player()
    player.known_techs.extend(["Nuclear Drive", "Starbase"])

    mobile = ShipDesign(hull_parts={"Hull": 1}, energy_sources={"Nuclear Source": 1})
    with pytest.raises(RulesViolation):
        validate_design(player, "interceptor", mobile)

    mobile.drive_parts["Nuclear Drive"] = 1
    validate_design(player, "interceptor", mobile)

    starbase = ShipDesign(
        cannon_parts={"Ion Cannon": 1},
        drive_parts={"Nuclear Drive": 1},
        energy_sources={"Nuclear Source": 1},
        hull_parts={"Hull": 1},
    )
    with pytest.raises(RulesViolation):
        validate_design(player, "starbase", starbase)

    starbase.drive_parts.clear()
    validate_design(player, "starbase", starbase)


def test_values_cumulative():
    player = _base_player()
    player.known_techs.extend(["Fusion Drive"])
    design = ShipDesign(
        drive_parts={"Fusion Drive": 2},
        energy_sources={"Nuclear Source": 2},
        hull_parts={"Hull": 1},
    )

    validate_design(player, "cruiser", design)
    assert design.drive == 2
    assert design.movement_value == 4
    assert design.initiative == 4
    assert design.energy_consumption == 4


def test_legacy_game_model_design_supported():
    player = _base_player()
    legacy = LegacyShipDesign(drive=1, drives=1)

    # Should not raise for pre-part aggregated blueprints.
    validate_design(player, "interceptor", legacy)
    assert legacy.drive == 1
    assert legacy.movement_value() == 1


def test_build_caps():
    player = _base_player()
    player.known_techs.append("Starbase")
    state = _state_with_hex(player)
    hx = state.map.hexes["H1"]
    hx.pieces[player.player_id].ships["dreadnought"] = FLEET_CAP["dreadnought"]

    with pytest.raises(RulesViolation):
        validate_build(player, {"state": state, "ships": {"dreadnought": 1}}, "H1")

    # Fill interceptors to the cap across two hexes
    hx2 = Hex(
        id="H2",
        ring=1,
        pieces={player.player_id: Pieces(ships={"interceptor": 4}, discs=1)},
    )
    state.map.hexes["H2"] = hx2
    hx.pieces[player.player_id].ships["interceptor"] = 4

    with pytest.raises(RulesViolation):
        validate_build(player, {"state": state, "ships": {"interceptor": 1}}, "H1")


def test_build_costs_and_limit_two_per_action():
    player = _base_player()
    state = _state_with_hex(player)

    with pytest.raises(RulesViolation):
        validate_build(player, {"state": state, "ships": {"interceptor": 3}}, "H1")

    player.resources.materials = BUILD_COST["cruiser"] + BUILD_COST["interceptor"] - 1
    with pytest.raises(RulesViolation):
        validate_build(
            player,
            {"state": state, "ships": {"cruiser": 1, "interceptor": 1}},
            "H1",
        )

    player.resources.materials = BUILD_COST["cruiser"] + BUILD_COST["interceptor"]
    validate_build(
        player,
        {"state": state, "ships": {"cruiser": 1, "interceptor": 1}},
        "H1",
    )


def test_build_requires_influence_disc_in_hex():
    player = _base_player()
    state = _state_with_hex(player)
    state.map.hexes["H1"].pieces[player.player_id].discs = 0

    with pytest.raises(RulesViolation):
        validate_build(player, {"state": state, "ships": {"interceptor": 1}}, "H1")


def test_structure_prereqs_and_per_hex_limits():
    player = _base_player()
    state = _state_with_hex(player)
    hx = state.map.hexes["H1"]

    with pytest.raises(RulesViolation):
        validate_build(player, {"state": state, "ships": {"starbase": 1}}, "H1")

    player.known_techs.append("Starbase")
    validate_build(player, {"state": state, "ships": {"starbase": 1}}, "H1")

    with pytest.raises(RulesViolation):
        validate_build(player, {"state": state, "structures": {"orbital": 1}}, "H1")

    player.known_techs.append("Orbital")
    validate_build(player, {"state": state, "structures": {"orbital": 1}}, "H1")
    hx.orbital = True
    with pytest.raises(RulesViolation):
        validate_build(player, {"state": state, "structures": {"orbital": 1}}, "H1")

    with pytest.raises(RulesViolation):
        validate_build(player, {"state": state, "structures": {"monolith": 1}}, "H1")

    player.known_techs.append("Monolith")
    validate_build(player, {"state": state, "structures": {"monolith": 1}}, "H1")
    hx.monolith = True
    with pytest.raises(RulesViolation):
        validate_build(player, {"state": state, "structures": {"monolith": 1}}, "H1")


def test_component_availability_limits():
    player = _base_player()
    player.available_components["dreadnought"] = 0
    state = _state_with_hex(player)

    with pytest.raises(RulesViolation):
        validate_build(player, {"state": state, "ships": {"dreadnought": 1}}, "H1")

    player.available_components["dreadnought"] = 2
    player.available_components["orbital"] = 0
    with pytest.raises(RulesViolation):
        validate_build(player, {"state": state, "structures": {"orbital": 1}}, "H1")

===== FILE: tests/test_cannons_computers_vs_shields.py =====

from eclipse_ai.simulators.combat import (
    CombatConfig,
    Combatant,
    Ship,
    WeaponProfile,
    resolve_combat,
)


def cannon_profiles():
    return {"ion": WeaponProfile(base_to_hit=6, damage=1)}


def shooter(computer: int) -> Ship:
    return Ship(
        cls="interceptor",
        initiative=3,
        hull=1,
        max_hull=1,
        computer=computer,
        shield=0,
        weapons={"ion": 1},
    )


def target(shield: int) -> Ship:
    return Ship(
        cls="interceptor",
        initiative=3,
        hull=1,
        max_hull=1,
        computer=0,
        shield=shield,
        weapons={},
    )


def test_cannon_threshold_uses_computers_and_shields():
    base_cfg = dict(
        weapon_profiles=cannon_profiles(),
        simul_same_initiative=True,
        seed=34,
    )

    res_low = resolve_combat(
        CombatConfig(
            attacker=Combatant(owner="attacker", ships=[shooter(computer=2)]),
            defender=Combatant(owner="defender", ships=[target(shield=0)]),
            **base_cfg,
        )
    )
    res_high = resolve_combat(
        CombatConfig(
            attacker=Combatant(owner="attacker", ships=[shooter(computer=2)]),
            defender=Combatant(owner="defender", ships=[target(shield=2)]),
            **base_cfg,
        )
    )

    low_alive = res_low.defender.ships[0].alive()
    high_alive = res_high.defender.ships[0].alive()

    assert low_alive is False
    assert high_alive is True

===== FILE: tests/test_combat_missiles_ignore_shields.py =====

from eclipse_ai.simulators.combat import (
    CombatConfig,
    Combatant,
    Ship,
    WeaponProfile,
    resolve_combat,
)


def basic_profiles():
    return {"ion": WeaponProfile(base_to_hit=6, damage=1)}


def make_ship(shield: int = 0) -> Ship:
    return Ship(
        cls="cruiser",
        initiative=2,
        hull=2,
        max_hull=2,
        computer=0,
        shield=shield,
        weapons={},
        missiles=1,
    )


def test_missiles_ignore_defender_shields():
    attacker = Combatant(owner="attacker", ships=[make_ship(shield=0)])
    defender_no_shield = Combatant(owner="defender", ships=[make_ship(shield=0)])
    defender_shield = Combatant(owner="defender", ships=[make_ship(shield=2)])

    cfg_no_shield = CombatConfig(
        attacker=attacker,
        defender=defender_no_shield,
        weapon_profiles=basic_profiles(),
        seed=11,
    )
    cfg_with_shield = CombatConfig(
        attacker=attacker,
        defender=defender_shield,
        weapon_profiles=basic_profiles(),
        seed=11,
    )

    res_no_shield = resolve_combat(cfg_no_shield)
    res_with_shield = resolve_combat(cfg_with_shield)

    hull_after_no_shield = res_no_shield.defender.ships[0].hull
    hull_after_with_shield = res_with_shield.defender.ships[0].hull

    assert hull_after_no_shield == hull_after_with_shield

===== FILE: tests/test_combat_missiles_initiative.py =====

import pytest

from eclipse_ai.simulators.combat import (
    CombatConfig,
    Combatant,
    Ship,
    WeaponProfile,
    resolve_combat,
)


def basic_profiles():
    return {"ion": WeaponProfile(base_to_hit=6, damage=1)}


def make_ship(cls: str, initiative: int, missiles: int = 0) -> Ship:
    return Ship(
        cls=cls,
        initiative=initiative,
        hull=1,
        max_hull=1,
        computer=0,
        shield=0,
        weapons={},
        missiles=missiles,
    )


def make_side(name: str, ships):
    return Combatant(owner=name, ships=list(ships))


def test_missiles_fire_by_initiative_order():
    attacker = make_side(
        "attacker",
        [make_ship("interceptor", 3, missiles=1), make_ship("cruiser", 2, missiles=1)],
    )
    defender = make_side(
        "defender",
        [make_ship("interceptor", 3, missiles=1), make_ship("cruiser", 2, missiles=1)],
    )
    config = CombatConfig(
        attacker=attacker,
        defender=defender,
        weapon_profiles=basic_profiles(),
        seed=3,
    )
    result = resolve_combat(config, debug=True)
    steps = [(step["initiative"], step["side"]) for step in result.trace["missile_steps"]]
    assert steps == [
        (3, "attacker"),
        (3, "defender"),
        (2, "attacker"),
        (2, "defender"),
    ]

===== FILE: tests/test_diplomacy_alliances.py =====

from __future__ import annotations

import pytest

from eclipse_ai.game_models import GameState, MapState, Hex, Pieces, PlayerState
from eclipse_ai.diplomacy import (
    DiplomacyError,
    break_diplomacy,
    can_form_diplomacy,
    form_diplomacy,
    has_diplomatic_relation,
)
from eclipse_ai.alliances import (
    AllianceError,
    are_allied,
    can_found_alliance,
    found_alliance,
    join_alliance,
    leave_alliance,
    merge_combat_sides,
    ship_presence,
)
from eclipse_ai.scoring.endgame import alliance_average_vp, calculate_endgame_vp


def _basic_player(pid: str) -> PlayerState:
    player = PlayerState(player_id=pid, color="color")
    player.population["yellow"] = 5
    return player


def _setup_state(*player_ids: str) -> GameState:
    state = GameState()
    state.players = {pid: _basic_player(pid) for pid in player_ids}
    state.map = MapState(hexes={}, adjacency={})
    state.feature_flags["rotA"] = True
    return state


def _link_hexes(state: GameState, wormholes_a: list[int], wormholes_b: list[int]) -> tuple[Hex, Hex]:
    hex_a = Hex(id="A", ring=1, wormholes=list(wormholes_a), neighbors={0: "B"}, pieces={})
    hex_b = Hex(id="B", ring=1, wormholes=list(wormholes_b), neighbors={3: "A"}, pieces={})
    state.map.hexes = {"A": hex_a, "B": hex_b}
    return hex_a, hex_b


def _force_diplomacy(state: GameState, a_id: str, b_id: str, color: str = "yellow") -> None:
    state.players[a_id].ambassadors[b_id] = True
    state.players[b_id].ambassadors[a_id] = True
    state.players[a_id].diplomacy[b_id] = color
    state.players[b_id].diplomacy[a_id] = color
    state.players[a_id].population[color] -= 1
    state.players[b_id].population[color] -= 1


def test_form_diplomacy_requires_full_wormhole():
    state = _setup_state("p1", "p2", "p3", "p4")
    hex_a, hex_b = _link_hexes(state, [0], [])
    hex_a.pieces["p1"] = Pieces(discs=1)
    hex_b.pieces["p2"] = Pieces(discs=1)
    assert not can_form_diplomacy(state, "p1", "p2")

    hex_b.wormholes.append(3)
    assert can_form_diplomacy(state, "p1", "p2")


def test_no_diplomacy_if_ships_cohabit():
    state = _setup_state("p1", "p2", "p3", "p4")
    hex_a, hex_b = _link_hexes(state, [0], [3])
    hex_a.pieces["p1"] = Pieces(discs=1)
    hex_b.pieces["p2"] = Pieces(discs=1)
    hex_a.pieces["p2"] = Pieces(ships={"interceptor": 1})
    assert not can_form_diplomacy(state, "p1", "p2")

    hex_a.pieces["p2"] = Pieces()
    hex_b.pieces["p1"] = Pieces(ships={"interceptor": 1})
    assert not can_form_diplomacy(state, "p1", "p2")


def test_breaking_relations_on_move_into_enemy_hex():
    state = _setup_state("p1", "p2", "p3", "p4")
    hex_a, hex_b = _link_hexes(state, [0], [3])
    hex_a.pieces["p1"] = Pieces(discs=1)
    hex_b.pieces["p2"] = Pieces(discs=1)
    form_diplomacy(state, "p1", "p2")

    break_diplomacy(state, "p1", "p2")
    assert not has_diplomatic_relation(state, "p1", "p2")
    assert state.players["p1"].has_traitor
    assert state.players["p1"].population["yellow"] == 5
    assert state.players["p2"].population["yellow"] == 5


def test_ambassador_limits_and_vp():
    state = _setup_state("p1", "p2", "p3", "p4")
    hex_a, hex_b = _link_hexes(state, [0], [3])
    hex_a.pieces["p1"] = Pieces(discs=1)
    hex_b.pieces["p2"] = Pieces(discs=1)
    form_diplomacy(state, "p1", "p2")

    assert not can_form_diplomacy(state, "p1", "p2")
    with pytest.raises(DiplomacyError):
        form_diplomacy(state, "p1", "p2")

    assert calculate_endgame_vp(state, "p1") == 1
    assert calculate_endgame_vp(state, "p2") == 1


def test_found_alliance_requires_diplomacy_and_capacity():
    state = _setup_state("p1", "p2", "p3", "p4")
    hex_a, hex_b = _link_hexes(state, [0], [3])
    hex_a.pieces["p1"] = Pieces(discs=1)
    hex_b.pieces["p2"] = Pieces(discs=1)
    form_diplomacy(state, "p1", "p2")

    assert can_found_alliance(state, "p1", "p2")
    assert not can_found_alliance(state, "p1", "p2", third_id="p3")

    alliance = found_alliance(state, "p1", "p2")
    assert alliance.members == ["p1", "p2"]
    assert state.players["p1"].alliance_tile == "+2"

    # Expand to 6 players to allow a third member.
    state.players["p5"] = _basic_player("p5")
    state.players["p6"] = _basic_player("p6")
    _force_diplomacy(state, "p3", "p1")
    _force_diplomacy(state, "p3", "p2")
    join_alliance(state, alliance.id, "p3")
    assert are_allied(state, "p1", "p3")


def test_alliance_effects_on_move_pinning_combat():
    state = _setup_state("p1", "p2", "p3", "p4")
    hex_a, hex_b = _link_hexes(state, [0], [3])
    hex_a.pieces["p1"] = Pieces(discs=1, ships={"interceptor": 1})
    hex_a.pieces["p3"] = Pieces(discs=0, ships={"interceptor": 2})
    hex_b.pieces["p2"] = Pieces(discs=1)
    form_diplomacy(state, "p1", "p2")
    hex_a.pieces["p2"] = Pieces(discs=0, ships={"interceptor": 1})
    alliance = found_alliance(state, "p1", "p2")

    friendly, enemy = ship_presence(state, hex_a, "p1")
    assert friendly == 2  # p1 + allied p2 ships
    assert enemy == 2     # hostile p3 ships

    defenders, attackers, defender_tie = merge_combat_sides(state, ["p1"], ["p3"])
    assert set(defenders) == {"p1", "p2"}
    assert attackers == ["p3"]
    assert defender_tie


def test_leave_alliance_sets_betrayer_and_traitor_if_co_located():
    state = _setup_state("p1", "p2", "p3", "p4")
    hex_a, hex_b = _link_hexes(state, [0], [3])
    hex_a.pieces["p1"] = Pieces(discs=1)
    hex_b.pieces["p2"] = Pieces(discs=1)
    form_diplomacy(state, "p1", "p2")
    hex_b.pieces["p1"] = Pieces(ships={"interceptor": 1})
    alliance = found_alliance(state, "p1", "p2")

    leave_alliance(state, "p1")
    assert state.players["p1"].alliance_tile == "-3"
    assert state.players["p1"].has_traitor
    assert not has_diplomatic_relation(state, "p1", "p2")
    assert alliance.id not in state.alliances or "p1" not in state.alliances[alliance.id].members


def test_last_round_restriction():
    late_state = _setup_state("p1", "p2", "p3", "p4")
    late_state.round = 9
    hex_a, hex_b = _link_hexes(late_state, [0], [3])
    hex_a.pieces["p1"] = Pieces(discs=1)
    hex_b.pieces["p2"] = Pieces(discs=1)
    form_diplomacy(late_state, "p1", "p2")

    assert not can_found_alliance(late_state, "p1", "p2")

    active_state = _setup_state("p1", "p2", "p3", "p4")
    hex_a, hex_b = _link_hexes(active_state, [0], [3])
    hex_a.pieces["p1"] = Pieces(discs=1)
    hex_b.pieces["p2"] = Pieces(discs=1)
    form_diplomacy(active_state, "p1", "p2")
    found_alliance(active_state, "p1", "p2")
    active_state.round = 9
    with pytest.raises(AllianceError):
        leave_alliance(active_state, "p1")


def test_alliance_tile_vp_and_team_average():
    state = _setup_state("p1", "p2", "p3", "p4")
    hex_a, hex_b = _link_hexes(state, [0], [3])
    hex_a.pieces["p1"] = Pieces(discs=1)
    hex_b.pieces["p2"] = Pieces(discs=1)
    form_diplomacy(state, "p1", "p2")
    alliance = found_alliance(state, "p1", "p2")

    totals = {
        "p1": calculate_endgame_vp(state, "p1", base_vp=5),
        "p2": calculate_endgame_vp(state, "p2", base_vp=7),
        "p3": calculate_endgame_vp(state, "p3", base_vp=4),
    }
    averages = alliance_average_vp(state, totals)
    assert alliance.id in averages
    assert averages[alliance.id] == pytest.approx((totals["p1"] + totals["p2"]) / 2)

===== FILE: tests/test_exploration_tiles_data.py =====

from eclipse_ai.data.exploration_tiles import (
    load_exploration_tiles,
    tile_counts_by_ring,
    tile_numbers_by_ring,
    tiles_by_ring,
)


def test_loads_known_tile() -> None:
    tiles = load_exploration_tiles()
    assert "105" in tiles
    tile = tiles["105"]
    assert tile.ring == 1
    assert tile.discovery_tile is True
    assert tile.resources["science"] == 1
    assert tile.advanced_resources["money"] == 0


def test_counts_align_with_numbers() -> None:
    counts = tile_counts_by_ring()
    numbers = tile_numbers_by_ring()
    assert counts
    for ring, ids in numbers.items():
        assert counts[ring] == len(ids)
        assert all(rec.tile_number in ids for rec in tiles_by_ring(ring))

===== FILE: tests/test_explore.py =====

from __future__ import annotations

import random

import pytest

from eclipse_ai.explore import (
    ExploreState,
    PlayerExploreState,
    choose_explore_target,
    claim_discovery,
    draw_sector_tile,
    discard_sector_tile,
    place_tile,
)
from eclipse_ai.influence import (
    connection_allows_diplomacy,
    connection_allows_influence,
    place_influence_disc,
)
from eclipse_ai.map.decks import (
    DiscoveryDeck,
    DiscoveryTile,
    ExplorationDecks,
    HexTile,
    SectorDeck,
)
from eclipse_ai.map.hex import Hex, MapGraph


PLAYER_ID = "P1"


def _make_state(
    *,
    sector_tiles: list[HexTile] | None = None,
    discovery_tiles: list[DiscoveryTile] | None = None,
    home_wormholes: tuple[int, ...] = (0,),
    has_wormhole_generator: bool = False,
) -> ExploreState:
    map_state = MapGraph()
    home = Hex(id="Home", ring=1, wormholes=home_wormholes)
    home.owner = PLAYER_ID
    map_state.add_hex(home)
    map_state.register_exploration_target(origin="Home", edge=0, target="T1")
    sectors = {
        1: SectorDeck(ring=1, tiles=sector_tiles or [], rng=random.Random(0)),
    }
    discovery = DiscoveryDeck(tiles=discovery_tiles or [], rng=random.Random(0))
    decks = ExplorationDecks(sectors=sectors, discovery=discovery)
    players = {
        PLAYER_ID: PlayerExploreState(
            player_id=PLAYER_ID,
            has_wormhole_generator=has_wormhole_generator,
        )
    }
    return ExploreState(map=map_state, decks=decks, players=players, feature_flags={"warp_portals": True})


def test_explore_discard_ends_turn() -> None:
    tile = HexTile(id="New", ring=1, wormholes=(3,))
    state = _make_state(sector_tiles=[tile])
    choose_explore_target(state, PLAYER_ID, "T1")
    drawn = draw_sector_tile(state, PLAYER_ID, 1)
    discard_sector_tile(state, PLAYER_ID, drawn)
    assert state.players[PLAYER_ID].turn_ended is True


def test_place_requires_connection() -> None:
    tile = HexTile(id="New", ring=1, wormholes=(3,))
    state = _make_state(sector_tiles=[tile], home_wormholes=())
    choose_explore_target(state, PLAYER_ID, "T1")
    draw_sector_tile(state, PLAYER_ID, 1)
    with pytest.raises(ValueError):
        place_tile(state, PLAYER_ID, tile, orient=0)
    state.players[PLAYER_ID].has_wormhole_generator = True
    placed = place_tile(state, PLAYER_ID, tile, orient=0)
    assert placed.id == "T1"


def test_wormhole_generator_allows_neighbor_wormhole_only() -> None:
    tile = HexTile(id="Half", ring=1, wormholes=())
    state = _make_state(sector_tiles=[tile], home_wormholes=(0,))
    choose_explore_target(state, PLAYER_ID, "T1")
    draw_sector_tile(state, PLAYER_ID, 1)
    with pytest.raises(ValueError):
        place_tile(state, PLAYER_ID, tile, orient=0)
    state.players[PLAYER_ID].has_wormhole_generator = True
    placed = place_tile(state, PLAYER_ID, tile, orient=0)
    assert placed.id == "T1"


def test_spawn_discovery_and_ancients() -> None:
    tile = HexTile(
        id="AncientDiscovery",
        ring=1,
        wormholes=(3,),
        symbols=("discovery", "ancient", "ancient"),
    )
    discovery_tile = DiscoveryTile(id="D1", effect="money", amount=5)
    state = _make_state(sector_tiles=[tile], discovery_tiles=[discovery_tile])
    choose_explore_target(state, PLAYER_ID, "T1")
    draw_sector_tile(state, PLAYER_ID, 1)
    placed = place_tile(state, PLAYER_ID, tile, orient=0)
    assert placed.discovery_tile == discovery_tile
    assert placed.ancients == 2


def test_control_requires_clearing_ancients_and_gcds() -> None:
    map_state = MapGraph()
    target = Hex(id="Target", ring=1, wormholes=())
    target.ancients = 1
    map_state.add_hex(target)
    decks = ExplorationDecks(
        sectors={1: SectorDeck(ring=1, tiles=[], rng=random.Random(0))},
        discovery=DiscoveryDeck(tiles=[], rng=random.Random(0)),
    )
    players = {PLAYER_ID: PlayerExploreState(player_id=PLAYER_ID)}
    state = ExploreState(map=map_state, decks=decks, players=players, feature_flags={})
    with pytest.raises(ValueError):
        place_influence_disc(state, PLAYER_ID, "Target")
    target.ancients = 0
    target.gcds = True
    with pytest.raises(ValueError):
        place_influence_disc(state, PLAYER_ID, "Target")
    target.gcds = False
    place_influence_disc(state, PLAYER_ID, "Target")
    assert map_state.hexes["Target"].owner == PLAYER_ID


def test_discovery_vp_or_benefit_choice() -> None:
    discovery_tile = DiscoveryTile(id="D-money", effect="money", amount=5)
    map_state = MapGraph()
    hex_obj = Hex(id="DiscoveryHex", ring=1, wormholes=())
    hex_obj.owner = PLAYER_ID
    hex_obj.discovery_tile = discovery_tile
    map_state.add_hex(hex_obj)
    decks = ExplorationDecks(
        sectors={1: SectorDeck(ring=1, tiles=[], rng=random.Random(0))},
        discovery=DiscoveryDeck(tiles=[], rng=random.Random(0)),
    )
    players = {PLAYER_ID: PlayerExploreState(player_id=PLAYER_ID)}
    state = ExploreState(map=map_state, decks=decks, players=players, feature_flags={})
    claim_discovery(state, PLAYER_ID, "DiscoveryHex", keep_vp=False)
    assert players[PLAYER_ID].resources.money == 5
    assert state.decks.discovery.discard_pile  # spent tile is discarded
    hex_obj.discovery_tile = DiscoveryTile(id="D-vp", effect="materials", amount=3)
    claim_discovery(state, PLAYER_ID, "DiscoveryHex", keep_vp=True)
    assert players[PLAYER_ID].discovery_vp == 2
    assert hex_obj.discovery_tile is None


def test_sector_stack_reshuffle_on_empty() -> None:
    tile = HexTile(id="Sector", ring=1, wormholes=(3,))
    state = _make_state(sector_tiles=[tile])
    choose_explore_target(state, PLAYER_ID, "T1")
    first = draw_sector_tile(state, PLAYER_ID, 1)
    discard_sector_tile(state, PLAYER_ID, first)
    state.players[PLAYER_ID].turn_ended = False
    choose_explore_target(state, PLAYER_ID, "T1")
    second = draw_sector_tile(state, PLAYER_ID, 1)
    assert second == first


def test_discovery_reshuffle() -> None:
    deck = DiscoveryDeck(tiles=[DiscoveryTile(id="D1", effect="science", amount=3)], rng=random.Random(0))
    first = deck.draw()
    deck.discard(first)
    second = deck.draw()
    assert second == first


def test_warp_portal_adjacency_for_influence_and_diplomacy() -> None:
    map_state = MapGraph()
    a = Hex(id="A", ring=1, wormholes=())
    b = Hex(id="B", ring=1, wormholes=())
    a.warp_portal = True
    b.warp_portal = True
    map_state.add_hex(a)
    map_state.add_hex(b)
    flags = {"warp_portals": True}
    assert connection_allows_influence(map_state, "A", "B", feature_flags=flags)
    assert connection_allows_diplomacy(map_state, "A", "B", feature_flags=flags)
    flags["warp_portals"] = False
    assert not connection_allows_influence(map_state, "A", "B", feature_flags=flags)
    assert not connection_allows_diplomacy(map_state, "A", "B", feature_flags=flags)


def test_diplomacy_requires_full_link_not_wg() -> None:
    map_state = MapGraph()
    a = Hex(id="A", ring=1, wormholes=(0,))
    b = Hex(id="B", ring=1, wormholes=())
    map_state.add_hex(a)
    map_state.add_hex(b)
    map_state.ensure_neighbor_link("A", 0, "B")
    flags = {"warp_portals": False}
    assert not connection_allows_influence(map_state, "A", "B", feature_flags=flags)
    assert connection_allows_influence(map_state, "A", "B", feature_flags=flags, player_has_wg=True)
    assert not connection_allows_diplomacy(map_state, "A", "B", feature_flags=flags)

===== FILE: tests/test_legality_cases_orion.py =====

"""Ensure curated Orion legality fixtures remain valid."""
from __future__ import annotations

from copy import deepcopy
from typing import Dict, Any

import pytest

from eclipse_ai.game_models import GameState
from eclipse_ai.validators import assert_test_case_legal

from tests.legal_cases.orion_turn1 import ORION_TURN1_TEST_CASES


def _materialise_state(test_case: Dict[str, Any]) -> Dict[str, Any]:
    """Return a deep-copied test case with the state coerced into ``GameState``."""
    payload = deepcopy(test_case)
    payload["state"] = GameState.from_dict(deepcopy(test_case["state"]))
    return payload


@pytest.mark.parametrize(
    "test_case",
    ORION_TURN1_TEST_CASES,
    ids=lambda case: case.get("provenance", "orion-case"),
)
def test_orion_opening_case_is_legal(test_case: Dict[str, Any]) -> None:
    materialised = _materialise_state(test_case)
    assert_test_case_legal(materialised)
    expectations = test_case.get("expectations", {})
    if expectations:
        assert expectations.get("should_be_legal", True) is True

===== FILE: tests/test_legality_gate.py =====

import pytest

from eclipse_ai.validators import assert_test_case_legal, assert_plans_legal, LegalityError


@pytest.fixture(autouse=True)
def stub_legal_actions(monkeypatch):
    allowed = [
        {"action": "PASS", "payload": {}},
        {"action": "EXPLORE", "payload": {"sector": 1}},
    ]

    def _stub(state, player_id):
        return allowed

    monkeypatch.setattr("eclipse_ai.validators.legal_actions", _stub)
    return allowed


@pytest.fixture
def sample_state():
    return {"hexes": []}


@pytest.fixture
def sample_player_id():
    return 0


@pytest.fixture
def sample_test(sample_state, sample_player_id):
    return {
        "state": sample_state,
        "player_id": sample_player_id,
        "proposed_action": {"action": "PASS", "payload": {}},
    }


@pytest.fixture
def planner_output():
    return {
        "plans": [
            {
                "steps": [
                    {"action": "EXPLORE", "payload": {"sector": 1, "extra": True}},
                    {"action": "PASS", "payload": {}},
                ]
            }
        ]
    }


def test_generator_outputs_only_legal_cases(sample_test):
    assert_test_case_legal(sample_test)


def test_planner_outputs_only_legal_steps(sample_state, sample_player_id, planner_output):
    assert_plans_legal(planner_output, sample_state, sample_player_id)


def test_illegal_action_raises(sample_state, sample_player_id):
    bad_test = {
        "state": sample_state,
        "player_id": sample_player_id,
        "proposed_action": {"action": "BUILD", "payload": {}},
    }
    with pytest.raises(LegalityError):
        assert_test_case_legal(bad_test)

===== FILE: tests/test_movement_rules.py =====

"""Detailed movement legality tests for Eclipse MOVE actions."""

from __future__ import annotations

import copy

import pytest

from eclipse_ai.game_models import GameState
from eclipse_ai.search_policy import _apply_move_action


BASE_PLAYER = {
    "player_id": "P1",
    "color": "orange",
    "known_techs": [],
    "resources": {"money": 5, "science": 5, "materials": 5},
    "ship_designs": {
        "interceptor": {
            "computer": 0,
            "shield": 0,
            "initiative": 2,
            "hull": 1,
            "cannons": 1,
            "missiles": 0,
            "drives": 1,
            "has_jump_drive": False,
            "interceptor_bays": 0,
        },
        "cruiser": {
            "computer": 1,
            "shield": 0,
            "initiative": 3,
            "hull": 2,
            "cannons": 1,
            "missiles": 0,
            "drives": 1,
            "has_jump_drive": False,
            "interceptor_bays": 0,
        },
        "dreadnought": {
            "computer": 1,
            "shield": 1,
            "initiative": 2,
            "hull": 3,
            "cannons": 2,
            "missiles": 0,
            "drives": 1,
            "has_jump_drive": False,
            "interceptor_bays": 0,
        },
    },
    "has_wormhole_generator": False,
    "move_overrides": {},
}

ENEMY_PLAYER = {
    "player_id": "P2",
    "color": "blue",
    "known_techs": [],
    "resources": {"money": 3, "science": 3, "materials": 3},
    "ship_designs": copy.deepcopy(BASE_PLAYER["ship_designs"]),
    "has_wormhole_generator": False,
    "move_overrides": {},
}


def _state_with_hexes(hexes: dict, player_overrides: dict | None = None) -> GameState:
    data = {
        "round": 1,
        "active_player": "P1",
        "players": {
            "P1": copy.deepcopy(BASE_PLAYER),
            "P2": copy.deepcopy(ENEMY_PLAYER),
        },
        "map": {"hexes": hexes},
    }
    if player_overrides:
        for key, value in player_overrides.items():
            data["players"]["P1"][key] = value
    return GameState.from_dict(data)


def test_move_requires_explored_and_wormholes() -> None:
    def build_state(has_wg: bool) -> GameState:
        hexes = {
            "A": {
                "id": "A",
                "ring": 1,
                "wormholes": [0],
                "neighbors": {0: "B"},
                "pieces": {"P1": {"ships": {"interceptor": 1}}},
                "explored": True,
            },
            "B": {
                "id": "B",
                "ring": 1,
                "wormholes": [],
                "neighbors": {3: "A"},
                "pieces": {},
                "explored": True,
            },
        }
        overrides = {"has_wormhole_generator": has_wg}
        return _state_with_hexes(hexes, overrides)

    # Non-existent destination
    state = build_state(False)
    with pytest.raises(ValueError):
        _apply_move_action(
            state,
            "P1",
            {"activations": [{"ship_class": "interceptor", "from": "A", "path": ["A", "C"]}]},
        )

    # Half-wormhole without generator is illegal
    state = build_state(False)
    with pytest.raises(ValueError):
        _apply_move_action(
            state,
            "P1",
            {"activations": [{"ship_class": "interceptor", "from": "A", "path": ["A", "B"]}]},
        )

    # With Wormhole Generator it becomes legal
    state = build_state(True)
    _apply_move_action(
        state,
        "P1",
        {"activations": [{"ship_class": "interceptor", "from": "A", "path": ["A", "B"]}]},
    )
    assert state.map.hexes["B"].pieces["P1"].ships.get("interceptor", 0) == 1


def test_activation_count_moves_multiple_ships_and_validates() -> None:
    hexes = {
        "Start": {
            "id": "Start",
            "ring": 1,
            "wormholes": [0, 2],
            "neighbors": {0: "Left", 2: "Right"},
            "pieces": {"P1": {"ships": {"interceptor": 2}}},
        },
        "Left": {
            "id": "Left",
            "ring": 1,
            "wormholes": [3],
            "neighbors": {3: "Start"},
            "pieces": {},
        },
        "Right": {
            "id": "Right",
            "ring": 1,
            "wormholes": [5],
            "neighbors": {5: "Start"},
            "pieces": {},
        },
    }
    state = _state_with_hexes(hexes)
    _apply_move_action(
        state,
        "P1",
        {
            "activations": [
                {"ship_class": "interceptor", "from": "Start", "path": ["Start", "Left"], "count": 2}
            ]
        },
    )
    assert state.map.hexes["Left"].pieces["P1"].ships.get("interceptor", 0) == 2
    assert "interceptor" not in state.map.hexes["Start"].pieces["P1"].ships

    state = _state_with_hexes(hexes)
    with pytest.raises(ValueError):
        _apply_move_action(
            state,
            "P1",
            {
                "activations": [
                    {
                        "ship_class": "interceptor",
                        "from": "Start",
                        "path": ["Start", "Left"],
                        "count": 0,
                    }
                ]
            },
        )

    state = _state_with_hexes(hexes)
    with pytest.raises(ValueError):
        _apply_move_action(
            state,
            "P1",
            {
                "activations": [
                    {
                        "ship_class": "interceptor",
                        "from": "Start",
                        "path": ["Start", "Left"],
                        "count": 3,
                    }
                ]
            },
        )
    assert state.map.hexes["Start"].pieces["P1"].ships.get("interceptor", 0) == 2


def test_movement_points_stack_with_drives() -> None:
    hexes = {
        "H1": {"id": "H1", "ring": 1, "wormholes": [1], "neighbors": {1: "H2"}, "pieces": {"P1": {"ships": {"cruiser": 1}}}},
        "H2": {
            "id": "H2",
            "ring": 1,
            "wormholes": [4, 1],
            "neighbors": {4: "H1", 1: "H3"},
            "pieces": {},
        },
        "H3": {
            "id": "H3",
            "ring": 1,
            "wormholes": [4, 1],
            "neighbors": {4: "H2", 1: "H4"},
            "pieces": {},
        },
        "H4": {
            "id": "H4",
            "ring": 1,
            "wormholes": [4, 1],
            "neighbors": {4: "H3", 1: "H5"},
            "pieces": {},
        },
        "H5": {
            "id": "H5",
            "ring": 1,
            "wormholes": [4],
            "neighbors": {4: "H4"},
            "pieces": {},
        },
    }
    overrides = {
        "ship_designs": {
            **copy.deepcopy(BASE_PLAYER["ship_designs"]),
            "cruiser": {
                **copy.deepcopy(BASE_PLAYER["ship_designs"]["cruiser"]),
                "drives": 4,
            },
        }
    }
    state = _state_with_hexes(hexes, overrides)
    _apply_move_action(
        state,
        "P1",
        {"activations": [{"ship_class": "cruiser", "from": "H1", "path": ["H1", "H2", "H3", "H4", "H5"]}]},
    )
    assert "cruiser" not in state.map.hexes["H1"].pieces["P1"].ships
    assert state.map.hexes["H5"].pieces["P1"].ships.get("cruiser", 0) == 1

    state = _state_with_hexes(hexes, overrides)
    with pytest.raises(ValueError):
        _apply_move_action(
            state,
            "P1",
            {
                "activations": [
                    {
                        "ship_class": "cruiser",
                        "from": "H1",
                        "path": ["H1", "H2", "H3", "H4", "H5", "H4"],
                    }
                ]
            },
        )


def test_species_activation_limits_respected() -> None:
    hexes = {
        "Hub": {
            "id": "Hub",
            "ring": 1,
            "wormholes": [0, 2, 4],
            "neighbors": {0: "N1", 2: "N2", 4: "N3"},
            "pieces": {"P1": {"ships": {"interceptor": 3}}},
        },
        "N1": {"id": "N1", "ring": 1, "wormholes": [3], "neighbors": {3: "Hub"}, "pieces": {}},
        "N2": {"id": "N2", "ring": 1, "wormholes": [5], "neighbors": {5: "Hub"}, "pieces": {}},
        "N3": {"id": "N3", "ring": 1, "wormholes": [1], "neighbors": {1: "Hub"}, "pieces": {}},
    }
    overrides = {"move_overrides": {"move_ship_activations_per_action": 2}}
    state = _state_with_hexes(hexes, overrides)
    with pytest.raises(ValueError):
        _apply_move_action(
            state,
            "P1",
            {
                "activations": [
                    {"ship_class": "interceptor", "from": "Hub", "path": ["Hub", "N1"]},
                    {"ship_class": "interceptor", "from": "Hub", "path": ["Hub", "N2"]},
                    {"ship_class": "interceptor", "from": "Hub", "path": ["Hub", "N3"]},
                ]
            },
        )
    assert state.map.hexes["Hub"].pieces["P1"].ships.get("interceptor", 0) == 3

    state = _state_with_hexes(hexes, overrides)
    _apply_move_action(
        state,
        "P1",
        {
            "activations": [
                {"ship_class": "interceptor", "from": "Hub", "path": ["Hub", "N1"]},
                {"ship_class": "interceptor", "from": "Hub", "path": ["Hub", "N2"]},
            ]
        },
    )
    assert state.map.hexes["Hub"].pieces["P1"].ships.get("interceptor", 0) == 1
    assert state.map.hexes["N1"].pieces["P1"].ships.get("interceptor", 0) == 1
    assert state.map.hexes["N2"].pieces["P1"].ships.get("interceptor", 0) == 1


def test_pinning_on_exit_and_entry() -> None:
    contested_hexes = {
        "Start": {
            "id": "Start",
            "ring": 1,
            "wormholes": [1],
            "neighbors": {1: "Safe"},
            "pieces": {
                "P1": {"ships": {"interceptor": 2}},
                "P2": {"ships": {"interceptor": 1}},
            },
        },
        "Safe": {"id": "Safe", "ring": 1, "wormholes": [4], "neighbors": {4: "Start"}, "pieces": {}},
    }
    state = _state_with_hexes(contested_hexes)
    # Moving the first interceptor is legal
    _apply_move_action(
        state,
        "P1",
        {"activations": [{"ship_class": "interceptor", "from": "Start", "path": ["Start", "Safe"]}]},
    )
    # The second attempt should fail because it would leave the enemy unpinned
    with pytest.raises(ValueError):
        _apply_move_action(
            state,
            "P1",
            {"activations": [{"ship_class": "interceptor", "from": "Start", "path": ["Start", "Safe"]}]},
        )

    # Entry pinning: cannot move through a contested middle hex without leaving ships behind
    hexes = {
        "Start": {
            "id": "Start",
            "ring": 1,
            "wormholes": [1],
            "neighbors": {1: "Mid"},
            "pieces": {"P1": {"ships": {"interceptor": 1}}},
        },
        "Mid": {
            "id": "Mid",
            "ring": 1,
            "wormholes": [4, 1],
            "neighbors": {4: "Start", 1: "End"},
            "pieces": {"P2": {"ships": {"interceptor": 1}}},
        },
        "End": {"id": "End", "ring": 1, "wormholes": [4], "neighbors": {4: "Mid"}, "pieces": {}},
    }
    state = _state_with_hexes(hexes)
    with pytest.raises(ValueError):
        _apply_move_action(
            state,
            "P1",
            {"activations": [{"ship_class": "interceptor", "from": "Start", "path": ["Start", "Mid", "End"]}]},
        )
    # Illegal movement does not change the board state
    assert state.map.hexes["Start"].pieces["P1"].ships.get("interceptor", 0) == 1


def test_gcds_blocks_through_traffic() -> None:
    hexes = {
        "A": {
            "id": "A",
            "ring": 1,
            "wormholes": [1],
            "neighbors": {1: "Center"},
            "pieces": {"P1": {"ships": {"cruiser": 1}}},
        },
        "Center": {
            "id": "Center",
            "ring": 0,
            "wormholes": [4, 1],
            "neighbors": {4: "A", 1: "C"},
            "pieces": {},
            "has_gcds": True,
        },
        "C": {
            "id": "C",
            "ring": 1,
            "wormholes": [4],
            "neighbors": {4: "Center"},
            "pieces": {},
        },
    }
    overrides = {
        "ship_designs": {
            **copy.deepcopy(BASE_PLAYER["ship_designs"]),
            "cruiser": {
                **copy.deepcopy(BASE_PLAYER["ship_designs"]["cruiser"]),
                "drives": 2,
            },
        }
    }
    state = _state_with_hexes(hexes, overrides)
    with pytest.raises(ValueError):
        _apply_move_action(
            state,
            "P1",
            {"activations": [{"ship_class": "cruiser", "from": "A", "path": ["A", "Center", "C"]}]},
        )
    assert state.map.hexes["A"].pieces["P1"].ships.get("cruiser", 0) == 1

    hexes["Center"]["has_gcds"] = False
    state = _state_with_hexes(hexes, overrides)
    _apply_move_action(
        state,
        "P1",
        {"activations": [{"ship_class": "cruiser", "from": "A", "path": ["A", "Center", "C"]}]},
    )
    assert state.map.hexes["C"].pieces["P1"].ships.get("cruiser", 0) == 1


def test_jump_drive_once_per_activation() -> None:
    overrides = {
        "ship_designs": {
            **copy.deepcopy(BASE_PLAYER["ship_designs"]),
            "interceptor": {
                **copy.deepcopy(BASE_PLAYER["ship_designs"]["interceptor"]),
                "drives": 0,
                "has_jump_drive": True,
            },
        }
    }
    hexes = {
        "A": {
            "id": "A",
            "ring": 1,
            "wormholes": [],
            "neighbors": {1: "B"},
            "pieces": {"P1": {"ships": {"interceptor": 1}}},
        },
        "B": {
            "id": "B",
            "ring": 1,
            "wormholes": [],
            "neighbors": {4: "A", 1: "C"},
            "pieces": {},
        },
        "C": {
            "id": "C",
            "ring": 1,
            "wormholes": [],
            "neighbors": {4: "B"},
            "pieces": {},
        },
    }
    state = _state_with_hexes(hexes, overrides)
    with pytest.raises(ValueError):
        _apply_move_action(
            state,
            "P1",
            {
                "activations": [
                    {"ship_class": "interceptor", "from": "A", "path": ["A", "B", "C"]}
                ]
            },
        )
    # Ship should remain at the origin because the move failed entirely
    assert state.map.hexes["A"].pieces["P1"].ships.get("interceptor", 0) == 1

    state = _state_with_hexes(hexes, overrides)
    _apply_move_action(
        state,
        "P1",
        {
            "activations": [
                {"ship_class": "interceptor", "from": "A", "path": ["A", "B"]},
                {"ship_class": "interceptor", "from": "B", "path": ["B", "C"]},
            ]
        },
    )
    assert state.map.hexes["C"].pieces["P1"].ships.get("interceptor", 0) == 1


def test_warp_portal_adjacency() -> None:
    hexes = {
        "P1": {
            "id": "P1",
            "ring": 3,
            "wormholes": [],
            "neighbors": {},
            "pieces": {"P1": {"ships": {"cruiser": 1}}},
            "has_warp_portal": True,
        },
        "P2": {
            "id": "P2",
            "ring": 3,
            "wormholes": [],
            "neighbors": {},
            "pieces": {},
            "has_warp_portal": True,
        },
    }
    state = _state_with_hexes(hexes)
    _apply_move_action(
        state,
        "P1",
        {"activations": [{"ship_class": "cruiser", "from": "P1", "path": ["P1", "P2"]}]},
    )
    assert state.map.hexes["P2"].pieces["P1"].ships.get("cruiser", 0) == 1


def test_interceptor_bay_flow() -> None:
    overrides = {
        "ship_designs": {
            **copy.deepcopy(BASE_PLAYER["ship_designs"]),
            "cruiser": {
                **copy.deepcopy(BASE_PLAYER["ship_designs"]["cruiser"]),
                "drives": 1,
                "interceptor_bays": 2,
            },
        }
    }
    hexes = {
        "S": {
            "id": "S",
            "ring": 1,
            "wormholes": [1],
            "neighbors": {1: "D"},
            "pieces": {"P1": {"ships": {"cruiser": 1, "interceptor": 2}}},
        },
        "D": {
            "id": "D",
            "ring": 1,
            "wormholes": [4, 1],
            "neighbors": {4: "S", 1: "E"},
            "pieces": {},
        },
        "E": {
            "id": "E",
            "ring": 1,
            "wormholes": [4],
            "neighbors": {4: "D"},
            "pieces": {},
        },
    }
    state = _state_with_hexes(hexes, overrides)
    _apply_move_action(
        state,
        "P1",
        {
            "activations": [
                {
                    "ship_class": "cruiser",
                    "from": "S",
                    "path": ["S", "D"],
                    "bay": {"interceptors": 2},
                },
                {
                    "ship_class": "interceptor",
                    "from": "D",
                    "path": ["D", "E"],
                },
            ]
        },
    )
    assert state.map.hexes["E"].pieces["P1"].ships.get("interceptor", 0) == 1
    assert state.map.hexes["D"].pieces["P1"].ships.get("interceptor", 0) == 1

    # Carrying interceptors does not help bypass pinning
    contested = copy.deepcopy(hexes)
    contested["D"]["pieces"] = {"P2": {"ships": {"interceptor": 1}}}
    state = _state_with_hexes(contested, overrides)
    with pytest.raises(ValueError):
        _apply_move_action(
            state,
            "P1",
            {
                "activations": [
                    {
                        "ship_class": "cruiser",
                        "from": "S",
                        "path": ["S", "D", "E"],
                        "bay": {"interceptors": 2},
                    }
                ]
            },
        )
    # State remains unchanged because the illegal move was rejected
    assert state.map.hexes["S"].pieces["P1"].ships.get("interceptor", 0) == 2


def test_reaction_move_single_activation_only() -> None:
    hexes = {
        "A": {
            "id": "A",
            "ring": 1,
            "wormholes": [1],
            "neighbors": {1: "B"},
            "pieces": {"P1": {"ships": {"interceptor": 1}}},
        },
        "B": {
            "id": "B",
            "ring": 1,
            "wormholes": [4],
            "neighbors": {4: "A"},
            "pieces": {},
        },
    }
    state = _state_with_hexes(hexes)
    with pytest.raises(ValueError):
        _apply_move_action(
            state,
            "P1",
            {
                "is_reaction": True,
                "activations": [
                    {"ship_class": "interceptor", "from": "A", "path": ["A", "B"]},
                    {"ship_class": "interceptor", "from": "B", "path": ["B", "A"]},
                ],
            },
        )

    state = _state_with_hexes(hexes)
    _apply_move_action(
        state,
        "P1",
        {"is_reaction": True, "activations": [{"ship_class": "interceptor", "from": "A", "path": ["A", "B"]}]},
    )
    assert state.map.hexes["B"].pieces["P1"].ships.get("interceptor", 0) == 1

===== FILE: tests/test_no_damage_splitting.py =====

from eclipse_ai.simulators.combat import (
    CombatConfig,
    Combatant,
    Ship,
    WeaponProfile,
    resolve_combat,
)


def antimatter_profile():
    return {"antimatter": WeaponProfile(base_to_hit=4, damage=2)}


def attacker_ship() -> Ship:
    return Ship(
        cls="dreadnought",
        initiative=2,
        hull=3,
        max_hull=3,
        computer=2,
        shield=0,
        weapons={"antimatter": 1},
    )


def defenders() -> Combatant:
    return Combatant(
        owner="defender",
        ships=[
            Ship(
                cls="interceptor",
                initiative=1,
                hull=1,
                max_hull=1,
                computer=0,
                shield=0,
                weapons={},
            ),
            Ship(
                cls="interceptor",
                initiative=1,
                hull=1,
                max_hull=1,
                computer=0,
                shield=0,
                weapons={},
            ),
        ],
    )


def base_config(antimatter_splitter: bool):
    return CombatConfig(
        attacker=Combatant(owner="attacker", ships=[attacker_ship()]),
        defender=defenders(),
        weapon_profiles=antimatter_profile(),
        antimatter_splitter_enabled=antimatter_splitter,
        round_cap=1,
        seed=13,
    )


def test_damage_not_split_without_splitter():
    result = resolve_combat(base_config(False))
    destroyed = sum(1 for ship in result.defender.ships if not ship.alive())
    assert destroyed == 1


def test_damage_can_split_with_splitter():
    result = resolve_combat(base_config(True))
    destroyed = sum(1 for ship in result.defender.ships if not ship.alive())
    assert destroyed >= 2

===== FILE: tests/test_point_defense_optional.py =====

from eclipse_ai.simulators.combat import (
    CombatConfig,
    Combatant,
    Ship,
    WeaponProfile,
    resolve_combat,
)


def basic_profiles():
    return {"ion": WeaponProfile(base_to_hit=6, damage=1)}


def missile_boat() -> Ship:
    return Ship(
        cls="interceptor",
        initiative=3,
        hull=1,
        max_hull=1,
        computer=0,
        shield=0,
        weapons={},
        missiles=3,
    )


def target_ship(shield: int = 0) -> Ship:
    return Ship(
        cls="cruiser",
        initiative=2,
        hull=3,
        max_hull=3,
        computer=0,
        shield=shield,
        weapons={},
    )


def test_point_defense_absent_when_disabled():
    attacker = Combatant(owner="attacker", ships=[missile_boat()])
    defender = Combatant(owner="defender", ships=[target_ship()])
    config = CombatConfig(
        attacker=attacker,
        defender=defender,
        weapon_profiles=basic_profiles(),
        seed=7,
    )
    result = resolve_combat(config, debug=True)
    assert result.trace["pd_steps"] == []


def test_point_defense_intercepts_when_enabled():
    attacker = Combatant(owner="attacker", ships=[missile_boat()])
    defender = Combatant(
        owner="defender",
        ships=[target_ship()],
        has_point_defense=True,
        point_defense_dice=2,
        point_defense_base=6,
        point_defense_computer=1,
    )
    config = CombatConfig(
        attacker=attacker,
        defender=defender,
        weapon_profiles=basic_profiles(),
        enable_point_defense=True,
        seed=5,
    )
    result = resolve_combat(config, debug=True)
    assert result.trace["pd_steps"], "Expected PD trace entries"
    prevented = result.trace["pd_steps"][0]["prevented"]
    assert prevented > 0

    shielded_attacker = Combatant(owner="attacker", ships=[missile_boat()])
    shielded_attacker.ships[0].shield = 2
    defender_again = Combatant(
        owner="defender",
        ships=[target_ship()],
        has_point_defense=True,
        point_defense_dice=2,
        point_defense_base=6,
        point_defense_computer=1,
    )
    config_with_shield = CombatConfig(
        attacker=shielded_attacker,
        defender=defender_again,
        weapon_profiles=basic_profiles(),
        enable_point_defense=True,
        seed=5,
    )
    result_with_shield = resolve_combat(config_with_shield, debug=True)
    assert result_with_shield.trace["pd_steps"][0]["prevented"] == prevented

===== FILE: tests/test_research_costs.py =====

import json
import shutil
import types
from pathlib import Path

import pytest

from eclipse_ai.game_models import GameState, MapState, PlayerState, Resources
from eclipse_ai.technology import (
    ResearchError,
    discounted_cost,
    load_tech_definitions,
    validate_research,
)


def _make_state(defs):
    player = PlayerState(
        player_id="P1",
        color="orange",
        resources=Resources(money=5, science=0, materials=5),
        science=0,
        influence_discs=2,
    )
    state = GameState(
        round=1,
        active_player="P1",
        phase="action",
        players={"P1": player},
        map=MapState(),
        tech_bags={},
        market=[],
        tech_definitions=defs,
    )
    return state, player


def test_merge_applies_min_cost_as_base():
    defs = load_tech_definitions()
    seen = set()
    for tech in defs.values():
        if tech.id in seen:
            continue
        seen.add(tech.id)
        assert tech.base_cost == tech.cost_range[0]
        assert tech.cost_range[0] <= tech.cost_range[1]


def test_category_discount_only_regular():
    defs = load_tech_definitions()
    state, player = _make_state(defs)
    player.tech_count_by_category = {"military": 2, "rare": 3}

    plasma_cost = discounted_cost(player, defs["plasma_cannon"])
    rare_cost = discounted_cost(player, defs["rift_cannon"])

    assert plasma_cost == max(1, defs["plasma_cannon"].base_cost - 2)
    assert rare_cost == defs["rift_cannon"].base_cost


def test_affordability_uses_discounted_cost():
    defs = load_tech_definitions()
    state, player = _make_state(defs)
    state.market = ["plasma_cannon"]

    player.science = 2
    player.resources.science = 2
    player.tech_count_by_category = {"military": 2}

    validate_research(state, player, "plasma_cannon")

    player.tech_count_by_category = {}
    with pytest.raises(ResearchError, match="insufficient Science"):
        validate_research(state, player, "plasma_cannon")


def test_missing_name_creates_skeleton_entry(tmp_path):
    repo_root = Path(__file__).resolve().parents[1]
    src_costs = repo_root / "eclipse_ai" / "data" / "tech_costs_second_dawn.json"
    src_data = repo_root / "eclipse_ai" / "data" / "tech.json"

    target_root = tmp_path
    (target_root / "eclipse_ai" / "data").mkdir(parents=True)
    shutil.copyfile(src_costs, target_root / "eclipse_ai" / "data" / "tech_costs_second_dawn.json")
    with open(src_data, "r", encoding="utf-8") as handle:
        data = json.load(handle)
    data["techs"] = [entry for entry in data["techs"] if entry["name"] != "Antimatter Cannon"]
    with open(target_root / "eclipse_ai" / "data" / "tech.json", "w", encoding="utf-8") as handle:
        json.dump(data, handle, indent=2)

    script_path = repo_root / "scripts" / "merge_tech_costs_second_dawn.py"
    module = types.ModuleType("merge_script")
    module.__file__ = str(target_root / "scripts" / "merge_tech_costs_second_dawn.py")
    target_script_dir = target_root / "scripts"
    target_script_dir.mkdir(parents=True, exist_ok=True)
    target_script_path = target_script_dir / "merge_tech_costs_second_dawn.py"
    target_script_path.write_text(script_path.read_text(encoding="utf-8"), encoding="utf-8")
    code = compile(target_script_path.read_text(encoding="utf-8"), module.__file__, "exec")
    exec(code, module.__dict__)

    module.main()

    updated = json.loads((target_root / "eclipse_ai" / "data" / "tech.json").read_text(encoding="utf-8"))
    names = {entry["name"] for entry in updated["techs"]}
    assert "Antimatter Cannon" in names

===== FILE: tests/test_rift_cannon_optional.py =====

from eclipse_ai.simulators.combat import (
    CombatConfig,
    Combatant,
    Ship,
    WeaponProfile,
    resolve_combat,
)


def rift_profile():
    return {"rift": WeaponProfile(base_to_hit=4, damage=2, is_rift=True)}


def rift_ship() -> Ship:
    return Ship(
        cls="ancient",
        initiative=2,
        hull=3,
        max_hull=3,
        computer=0,
        shield=0,
        weapons={"rift": 1},
    )


def target_ship() -> Ship:
    return Ship(
        cls="cruiser",
        initiative=1,
        hull=3,
        max_hull=3,
        computer=0,
        shield=3,
        weapons={},
    )


def test_rift_cannon_requires_flag():
    attacker = Combatant(owner="attacker", ships=[rift_ship()])
    defender = Combatant(owner="defender", ships=[target_ship()])

    disabled_cfg = CombatConfig(
        attacker=attacker,
        defender=defender,
        weapon_profiles=rift_profile(),
        enable_rift_cannons=False,
        seed=19,
    )
    enabled_cfg = CombatConfig(
        attacker=attacker,
        defender=defender,
        weapon_profiles=rift_profile(),
        enable_rift_cannons=True,
        seed=19,
    )

    disabled_result = resolve_combat(disabled_cfg)
    enabled_result = resolve_combat(enabled_cfg)

    assert disabled_result.defender.ships[0].hull == 3
    assert enabled_result.defender.ships[0].hull < 3 or enabled_result.attacker.ships[0].hull < 3

===== FILE: tests/test_round_flow_engine.py =====

from __future__ import annotations

import pytest

from eclipse_ai.game_models import (
    GameState,
    Hex,
    MapState,
    Pieces,
    Planet,
    PlayerState,
    Resources,
    Disc,
)
from eclipse_ai import round_flow


def _make_player(pid: str, money: int = 5, science: int = 0, materials: int = 0, discs: int = 5) -> PlayerState:
    player = PlayerState(player_id=pid, color="test")
    player.resources = Resources(money=money, science=science, materials=materials)
    player.income = Resources(money=0, science=0, materials=0)
    player.influence_track = [Disc(f"{pid}-d{i}") for i in range(discs)]
    return player


def _basic_state(players: dict[str, PlayerState]) -> GameState:
    state = GameState(
        round=1,
        players=players,
        map=MapState(hexes={}),
        starting_player=next(iter(players)),
        turn_order=list(players.keys()),
    )
    round_flow.begin_round(state)
    return state


def test_turn_loop_until_all_pass():
    players = {pid: _make_player(pid) for pid in ("P1", "P2", "P3")}
    state = _basic_state(players)

    round_flow.take_action(state, "P1", "Explore")
    assert state.active_player == "P2"

    round_flow.pass_action(state, "P2")
    assert players["P2"].passed is True
    assert state.pending_starting_player == "P2"
    assert state.active_player == "P3"

    round_flow.take_action(state, "P3", "Build")
    assert state.active_player == "P1"

    round_flow.pass_action(state, "P1")
    assert state.active_player == "P2"

    # Passing again simply advances the turn without changing the marker.
    round_flow.pass_action(state, "P2")
    assert state.active_player == "P3"

    round_flow.pass_action(state, "P3")
    assert round_flow.end_action_phase_if_all_passed(state) is True
    assert state.phase == "COMBAT"

    # Advance through upkeep/cleanup so the starting player marker moves.
    state.phase = "UPKEEP"
    round_flow.run_upkeep(state)
    state.phase = "CLEANUP"
    round_flow.run_cleanup(state)

    assert state.starting_player == "P2"
    assert state.active_player == "P2"
    assert state.phase == "ACTION"


def test_action_spends_disc_and_cleanup_returns():
    player = _make_player("P1", discs=4)
    state = _basic_state({"P1": player})

    round_flow.take_action(state, "P1", "Build")
    round_flow.take_action(state, "P1", "Research")

    assert len(player.influence_track) == 2
    assert len(player.action_spaces["build"]) == 1
    assert len(player.action_spaces["research"]) == 1

    round_flow.pass_action(state, "P1")
    assert round_flow.end_action_phase_if_all_passed(state) is True

    state.phase = "UPKEEP"
    round_flow.run_upkeep(state)
    state.phase = "CLEANUP"
    round_flow.run_cleanup(state)

    assert len(player.influence_track) == 4
    assert all(len(player.action_spaces[key]) == 0 for key in round_flow.ACTION_SPACE_KEYS)


def test_reaction_limits_after_pass():
    player = _make_player("P1", discs=5)
    player.known_techs.append("Nanorobots")
    state = _basic_state({"P1": player})

    round_flow.pass_action(state, "P1")
    assert round_flow.can_take_reaction(state, "P1") is True

    round_flow.take_reaction(state, "P1", "Build", {"ships": {"interceptor": 1}})
    assert len(player.action_spaces["reaction"]) == 1
    assert len(player.influence_track) == 4

    with pytest.raises(ValueError):
        round_flow.take_reaction(state, "P1", "Research", {})

    with pytest.raises(ValueError):
        round_flow.take_reaction(state, "P1", "Build", {"ships": {"interceptor": 2}})

    with pytest.raises(round_flow.PhaseError):
        round_flow.take_action(state, "P1", "Explore")

    # Move reaction still allowed with one ship
    round_flow.take_reaction(state, "P1", "Move", {"ships": {"interceptor": 1}})


def test_upkeep_shortfall_removes_discs_only_then():
    player = _make_player("P1", money=0, discs=2)
    hex_state = Hex(
        id="H1",
        ring=2,
        planets=[Planet(type="yellow", colonized_by="P1")],
        pieces={
            "P1": Pieces(ships={}, starbase=0, discs=1, cubes={"yellow": 1}),
        },
    )
    state = GameState(
        round=1,
        players={"P1": player},
        map=MapState(hexes={"H1": hex_state}),
        starting_player="P1",
        turn_order=["P1"],
    )
    round_flow.begin_round(state)

    with pytest.raises(round_flow.InfluenceError):
        round_flow._remove_disc_from_hex(
            state, player, "H1", reason="shortfall"
        )

    state.phase = "UPKEEP"
    round_flow.run_upkeep(state)
    assert player.population["yellow"] == 1
    assert player.influence_track  # disc returned to track
    assert "P1" not in state.map.hexes["H1"].pieces
    assert state.map.hexes["H1"].planets[0].colonized_by is None


def test_extra_discs_stack_rightmost():
    player = _make_player("P1", discs=2)
    extras = [Disc("extra-1", extra=True), Disc("extra-2", extra=True)]
    player.influence_track.extend(extras)
    state = _basic_state({"P1": player})

    round_flow.take_action(state, "P1", "Explore")
    assert player.action_spaces["explore"][0].id == "extra-2"
    assert player.action_spaces["explore"][0].extra is True

    round_flow.take_action(state, "P1", "Move")
    assert player.action_spaces["move"][0].id == "extra-1"

    round_flow.pass_action(state, "P1")
    assert round_flow.end_action_phase_if_all_passed(state)

    state.phase = "UPKEEP"
    round_flow.run_upkeep(state)
    state.phase = "CLEANUP"
    round_flow.run_cleanup(state)

    assert len(player.influence_track) == 4
    assert player.influence_track[-1].extra is True
    assert player.influence_track[-2].extra is True

===== FILE: tests/test_rules_engine.py =====

"""Tests for the rules engine heuristics respecting Agents_Testing guidelines."""

from __future__ import annotations

import json
from typing import Any, Dict, Iterable, Set

import pytest

from eclipse_ai.rules_engine import RulesConfig, legal_actions
from eclipse_ai.game_models import Action, ActionType, GameState


_BASE_STATE: Dict[str, Any] = {
    "round": 2,
    "active_player": "P1",
    "players": {
        "P1": {
            "player_id": "P1",
            "color": "orange",
            "known_techs": [],
            "resources": {"money": 6, "science": 5, "materials": 6},
            "ship_designs": {
                "interceptor": {
                    "computer": 1,
                    "shield": 0,
                    "initiative": 2,
                    "hull": 1,
                    "cannons": 1,
                    "missiles": 0,
                    "drive": 1,
                },
                "cruiser": {
                    "computer": 1,
                    "shield": 0,
                    "initiative": 3,
                    "hull": 1,
                    "cannons": 1,
                    "missiles": 0,
                    "drive": 1,
                },
            },
        },
        "P2": {
            "player_id": "P2",
            "color": "blue",
            "known_techs": ["Positron Computer"],
            "resources": {"money": 4, "science": 3, "materials": 3},
            "ship_designs": {
                "interceptor": {
                    "computer": 1,
                    "shield": 0,
                    "initiative": 2,
                    "hull": 1,
                    "cannons": 1,
                    "missiles": 0,
                    "drive": 1,
                }
            },
        },
    },
    "map": {
        "hexes": {
            "H1": {
                "id": "H1",
                "ring": 1,
                "planets": [
                    {"type": "yellow", "colonized_by": "P1"},
                    {"type": "blue", "colonized_by": "P1"},
                ],
                "pieces": {
                    "P1": {
                        "ships": {"interceptor": 2},
                        "starbase": 0,
                        "discs": 1,
                        "cubes": {"yellow": 2, "blue": 1},
                    }
                },
            },
            "H2": {
                "id": "H2",
                "ring": 2,
                "planets": [
                    {"type": "brown", "colonized_by": "P1"},
                    {"type": "yellow", "colonized_by": "P2"},
                ],
                "pieces": {
                    "P1": {
                        "ships": {"cruiser": 1},
                        "starbase": 0,
                        "discs": 1,
                        "cubes": {"brown": 1},
                    },
                    "P2": {
                        "ships": {"interceptor": 1},
                        "starbase": 0,
                        "discs": 1,
                        "cubes": {"yellow": 1},
                    },
                },
            },
            "H3": {
                "id": "H3",
                "ring": 2,
                "planets": [
                    {"type": "yellow", "colonized_by": None},
                    {"type": "yellow", "colonized_by": None},
                ],
                "pieces": {},
            },
        }
    },
    "tech_display": {
        "available": ["Plasma Cannon I", "Fusion Drive II", "Advanced Mining"],
        "tier_counts": {"I": 6, "II": 3, "III": 1},
    },
    "bags": {"R1": {"unknown": 4}, "R2": {"unknown": 3}},
}


_ORION_OPENING: Dict[str, Any] = {
    "round": 1,
    "active_player": "P1",
    "players": {
        "P1": {
            "player_id": "P1",
            "color": "purple",
            "known_techs": ["Gauss Shield", "Neutron Bombs"],  # Orion Hegemony starting tech (Rise of the Ancients)
            "resources": {"money": 3, "science": 1, "materials": 5},
            "ship_designs": {
                "interceptor": {
                    "computer": 1,
                    "shield": 1,
                    "initiative": 4,
                    "hull": 1,
                    "cannons": 1,
                    "missiles": 0,
                    "drive": 1,
                },
                "cruiser": {
                    "computer": 1,
                    "shield": 1,
                    "initiative": 3,
                    "hull": 2,
                    "cannons": 1,
                    "missiles": 0,
                    "drive": 1,
                },
            },
        },
        "P2": {
            "player_id": "P2",
            "color": "orange",
            "known_techs": [],
            "resources": {"money": 2, "science": 2, "materials": 2},
            "ship_designs": {
                "interceptor": {
                    "computer": 1,
                    "shield": 0,
                    "initiative": 2,
                    "hull": 1,
                    "cannons": 1,
                    "missiles": 0,
                    "drive": 1,
                },
            },
        },
    },
    "map": {
        "hexes": {
            "230": {
                "id": "230",
                "ring": 1,
                "planets": [
                    {"type": "yellow", "colonized_by": "P1"},
                    {"type": "blue", "colonized_by": "P1"},
                    {"type": "brown", "colonized_by": "P1"},
                ],
                "pieces": {
                    "P1": {
                        "ships": {"interceptor": 2, "cruiser": 1},
                        "starbase": 0,
                        "discs": 1,
                        "cubes": {"yellow": 1, "blue": 1, "brown": 1},
                    }
                },
            },
            "Terran": {
                "id": "Terran",
                "ring": 1,
                "planets": [
                    {"type": "yellow", "colonized_by": "P2"},
                    {"type": "blue", "colonized_by": "P2"},
                    {"type": "brown", "colonized_by": "P2"},
                ],
                "pieces": {
                    "P2": {
                        "ships": {"interceptor": 2},
                        "starbase": 0,
                        "discs": 1,
                        "cubes": {"yellow": 1, "blue": 1, "brown": 1},
                    }
                },
            },
            "Outer": {
                "id": "Outer",
                "ring": 2,
                "planets": [
                    {"type": "yellow", "colonized_by": None},
                    {"type": "blue", "colonized_by": None},
                ],
                "pieces": {},
            },
        }
    },
    "tech_display": {
        "available": ["Plasma Cannon I", "Fusion Drive I", "Advanced Mining"],
        "tier_counts": {"I": 6, "II": 4, "III": 2},
    },
    "bags": {"R1": {"unknown": 4}, "R2": {"unknown": 3}},
}


@pytest.fixture(name="base_state")
def fixture_base_state() -> GameState:
    """Return an independent copy of the representative base scenario."""

    payload = json.loads(json.dumps(_BASE_STATE))
    return GameState.from_dict(payload)


@pytest.fixture(name="orion_state")
def fixture_orion_state() -> GameState:
    """Return the Orion Hegemony opening from the Rise of the Ancients pack."""

    payload = json.loads(json.dumps(_ORION_OPENING))
    return GameState.from_dict(payload)


def _action_types(actions: Iterable[Action]) -> Set[ActionType]:
    return {a.type for a in actions}


def test_unknown_player_only_passes() -> None:
    """Missing players default to a solitary pass action."""

    state = GameState()
    actions = legal_actions(state, "ghost")
    assert actions == [Action(ActionType.PASS, {})]


def test_explore_considers_adjacent_rings(base_state: GameState) -> None:
    """Exploration proposals draw from rings touching the player's footprint."""

    actions = legal_actions(base_state, "P1")
    explore_rings = {a.payload["ring"] for a in actions if a.type is ActionType.EXPLORE}
    assert explore_rings == {1, 2}


def test_research_respects_affordability(base_state: GameState) -> None:
    """Research options ignore owned technologies and respect science availability."""

    base_state.players["P1"].known_techs = ["Plasma Cannon I"]
    base_state.players["P1"].resources.science = 4

    actions = legal_actions(base_state, "P1")
    research = [a for a in actions if a.type is ActionType.RESEARCH]

    researched_techs = {a.payload["tech"] for a in research}
    assert "Plasma Cannon I" not in researched_techs
    for act in research:
        approx_cost = act.payload["approx_cost"]
        is_stretch = act.payload.get("note") == "stretch"
        assert approx_cost <= 4 or is_stretch


def test_build_prioritises_contested_starbase(base_state: GameState) -> None:
    """A contested hex with sufficient materials yields a starbase recommendation."""

    actions = legal_actions(base_state, "P1")
    build_payloads = [a.payload for a in actions if a.type is ActionType.BUILD]
    assert any(p.get("hex") == "H2" and p.get("starbase") == 1 for p in build_payloads)


def test_influence_recommends_high_value_hex(base_state: GameState) -> None:
    """Influence suggestions target the richest available neutral hex."""

    actions = legal_actions(base_state, "P1")
    influence = [a for a in actions if a.type is ActionType.INFLUENCE]
    assert influence
    assert influence[0].payload["hex"] == "H3"


def test_influence_can_be_disabled(base_state: GameState) -> None:
    """When influence is disabled the rules engine omits those actions entirely."""

    config = RulesConfig(enable_influence=False)
    actions = legal_actions(base_state, "P1", config)
    assert ActionType.INFLUENCE not in _action_types(actions)


def test_diplomacy_toggle_removes_offers(base_state: GameState) -> None:
    """Disabling diplomacy removes diplomatic offers from the action list."""

    config = RulesConfig(enable_diplomacy=False)
    actions = legal_actions(base_state, "P1", config)
    assert ActionType.DIPLOMACY not in _action_types(actions)


def test_orion_opening_recommendations(orion_state: GameState) -> None:
    """On round one the Orion Hegemony gets explore, aggression, and influence suggestions."""

    actions = legal_actions(orion_state, "P1")

    # Explore should target both the current ring and the next ring (home sector 230 in Rise of the Ancients).
    explore_payloads = [a.payload for a in actions if a.type is ActionType.EXPLORE]
    assert {p["ring"] for p in explore_payloads} == {1, 2}

    # Limited science (1) means no immediate research options are offered.
    assert ActionType.RESEARCH not in _action_types(actions)

    # Building another interceptor in the home hex is the affordable combat reinforcement.
    build_payloads = [a.payload for a in actions if a.type is ActionType.BUILD]
    assert {"hex": "230", "ships": {"interceptor": 1}} in build_payloads

    # Aggressive move suggestion toward the Terran neighbour plus an influence target on the richest empty hex.
    move_targets = {(a.payload["from"], a.payload["to"]) for a in actions if a.type is ActionType.MOVE}
    assert ("230", "Terran") in move_targets

    influence_targets = [a.payload.get("hex") for a in actions if a.type is ActionType.INFLUENCE]
    assert influence_targets == ["Outer"]

===== FILE: tests/test_scoring.py =====

from __future__ import annotations

from dataclasses import dataclass, field
from typing import Dict, List, Optional

from eclipse_ai.models.player_state import EvolutionTile, PlayerState, ReputationTile
from eclipse_ai.scoring import compute_endgame_vp, score_game


@dataclass
class Hex:
    id: str
    vp_value: int = 0
    controller: Optional[str] = None


@dataclass
class MapState:
    hexes: Dict[str, Hex] = field(default_factory=dict)


@dataclass
class StubState:
    players: Dict[str, PlayerState]
    map: MapState = field(default_factory=MapState)
    alliance_teams: Optional[Dict[str, List[str]]] = None


def test_base_example() -> None:
    hexes = {
        "A": Hex(id="A", vp_value=2, controller="p1"),
        "B": Hex(id="B", vp_value=3, controller="p1"),
    }
    player = PlayerState(
        player_id="p1",
        reputation_kept=[
            ReputationTile(value=3),
            ReputationTile(value=2),
            ReputationTile(value=5, is_special=True),
        ],
        ambassadors=2,
        controlled_hex_ids=["A", "B"],
        discoveries_kept=1,
        monolith_count=2,
        tech_track_counts={"military": 4, "grid": 5, "nano": 6},
    )
    state = StubState(players={"p1": player}, map=MapState(hexes=hexes))

    result = compute_endgame_vp(state, "p1", modules={})

    assert result["vp_reputation"] == 5
    assert result["vp_ambassadors"] == 2
    assert result["vp_hexes"] == 5
    assert result["vp_discoveries"] == 2
    assert result["vp_monoliths"] == 6
    assert result["vp_tech_tracks"] == 6
    assert result["vp_traitor"] == 0
    assert result["total"] == 26


def test_tech_track_piecewise() -> None:
    player = PlayerState(
        player_id="p2",
        tech_track_counts={
            "military": 3,
            "grid": 4,
            "nano": 5,
            "quantum": 6,
            "biotech": 7,
            "economy": 8,
        },
    )
    state = StubState(players={"p2": player})

    result = compute_endgame_vp(state, "p2", modules={})

    assert result["vp_tech_tracks"] == 16
    assert result["total"] == 16


def test_traitor_penalty() -> None:
    state = StubState(
        players={
            "p1": PlayerState(player_id="p1", has_traitor=True),
            "p2": PlayerState(player_id="p2", has_traitor=False),
        }
    )

    result_with_traitor = compute_endgame_vp(state, "p1", modules={})
    result_without_traitor = compute_endgame_vp(state, "p2", modules={})

    assert result_with_traitor["vp_traitor"] == -2
    assert result_with_traitor["total"] == -2
    assert result_without_traitor["vp_traitor"] == 0
    assert result_without_traitor["total"] == 0


def test_discoveries_vp_kept_only() -> None:
    player = PlayerState(player_id="p3", discoveries_kept=3)
    state = StubState(players={"p3": player})

    result = compute_endgame_vp(state, "p3", modules={})

    assert result["vp_discoveries"] == 6
    assert result["total"] == 6


def test_alliance_tile_values_and_team_average() -> None:
    players = {
        "p1": PlayerState(player_id="p1", alliance_tile="faceup"),
        "p2": PlayerState(player_id="p2", alliance_tile="betrayer"),
    }
    state = StubState(players=players, alliance_teams={"team-alpha": ["p1", "p2"]})

    result = score_game(state, modules={"alliances": True})

    assert result["players"]["p1"]["vp_rise_alliance_tile"] == 2
    assert result["players"]["p2"]["vp_rise_alliance_tile"] == -3
    alliance_summary = result["alliances"]
    assert alliance_summary["team_totals"]["team-alpha"] == -1
    assert alliance_summary["team_average"]["team-alpha"] == -1


def test_ancient_kill_tokens_vp() -> None:
    tokens = {"cruiser": 2, "dreadnought": 1}
    player = PlayerState(player_id="p4", ancient_kill_tokens=tokens)
    state = StubState(players={"p4": player})

    result = compute_endgame_vp(state, "p4", modules={"new_ancients": True})

    assert result["vp_rise_ancient_kills"] == 3
    assert result["total"] == 3


def test_sor_evolution_examples() -> None:
    player = PlayerState(
        player_id="p5",
        monolith_count=2,
        controlled_hex_ids=["A", "B", "C", "D"],
        artifacts_controlled=3,
        controls_galactic_center=True,
        evolution_tiles=[
            EvolutionTile(endgame_key="per_monolith", value=1),
            EvolutionTile(endgame_key="per_two_hex", value=1),
            EvolutionTile(endgame_key="per_artifact", value=1),
            EvolutionTile(endgame_key="galactic_center", value=3),
            EvolutionTile(endgame_key=None, value=4),
        ],
    )
    state = StubState(players={"p5": player})

    modules_on = {"sor": True}
    modules_off = {}

    result_on = compute_endgame_vp(state, "p5", modules=modules_on)
    result_off = compute_endgame_vp(state, "p5", modules=modules_off)

    assert result_on["vp_sor_evolution"] == 14
    assert result_off["vp_sor_evolution"] == 0
    assert result_on["total"] - result_off["total"] == 14

===== FILE: tests/test_simultaneous_same_initiative.py =====

from eclipse_ai.simulators.combat import (
    CombatConfig,
    Combatant,
    Ship,
    WeaponProfile,
    resolve_combat,
)


def profiles():
    return {"ion": WeaponProfile(base_to_hit=6, damage=1)}


def ship() -> Ship:
    return Ship(
        cls="interceptor",
        initiative=3,
        hull=1,
        max_hull=1,
        computer=0,
        shield=0,
        weapons={"ion": 1},
    )


def test_same_initiative_volley_is_simultaneous():
    attacker = Combatant(owner="attacker", ships=[ship()])
    defender = Combatant(owner="defender", ships=[ship()])
    config = CombatConfig(
        attacker=attacker,
        defender=defender,
        weapon_profiles=profiles(),
        simul_same_initiative=True,
        seed=13,
    )
    result = resolve_combat(config)
    assert result.attacker.ships[0].hull == 0
    assert result.defender.ships[0].hull == 0

===== FILE: tests/test_species_data.py =====

from eclipse_ai import all_species, get_species, SpeciesConfig


def test_loads_species_registry() -> None:
    registry = all_species()
    assert "terrans" in registry
    assert "octantis_autonomy" in registry
    assert isinstance(registry["terrans"], SpeciesConfig)


def test_octantis_evolution_note_present() -> None:
    octantis = get_species("octantis_autonomy")
    notes = " ".join(octantis.get("notes", []))
    assert "Evolution" in notes
    assert "Colony Ships" in notes


def test_rho_indi_trade_rate_override() -> None:
    rho = get_species("rho_indi")
    trade_rate = rho.trade_rate
    assert trade_rate == {"goods": 3, "resources": 2}


def test_two_player_balance_note() -> None:
    planta_notes = " ".join(get_species("planta").get("notes", []))
    draco_notes = " ".join(get_species("draco").get("notes", []))
    assert "two-player" in planta_notes.lower()
    assert "two-player" in draco_notes.lower()

===== FILE: tests/test_state_assembler.py =====

from __future__ import annotations

from eclipse_ai import state_assembler
from eclipse_ai.game_models import GameState, MapState, TechDisplay, Hex, Planet, Pieces


def _make_prior(round_num: int = 1) -> GameState:
    return GameState(round=round_num, players={}, map=MapState(), tech_display=TechDisplay())


def test_populate_explore_bags_turn_one_full() -> None:
    catalog = state_assembler._TILE_CATALOG
    assert catalog.total_by_ring, "tile catalog failed to load"

    map_state = MapState(
        hexes={
            "Terran": Hex(
                id="Terran",
                ring=1,
                planets=[Planet("yellow", "P1")],
                pieces={"P1": Pieces(ships={}, starbase=0, discs=1, cubes={})},
            ),
            "Hydran": Hex(
                id="Hydran",
                ring=1,
                planets=[Planet("blue", "P2")],
                pieces={"P2": Pieces(ships={}, starbase=0, discs=1, cubes={})},
            ),
        }
    )

    gs = state_assembler.assemble_state(map_state, TechDisplay(), prior_state=_make_prior(1))

    for ring, total in catalog.total_by_ring.items():
        bag = gs.bags.get(f"R{ring}", {})
        assert bag.get("unknown", 0) == total


def test_populate_explore_bags_round_five_empty() -> None:
    catalog = state_assembler._TILE_CATALOG
    assert catalog.total_by_ring, "tile catalog failed to load"

    map_state = MapState(hexes={})
    gs = state_assembler.assemble_state(map_state, TechDisplay(), prior_state=_make_prior(5))

    for ring in catalog.total_by_ring:
        bag = gs.bags.get(f"R{ring}", {})
        assert sum(bag.values()) == 0

===== FILE: tests/test_technology.py =====

from __future__ import annotations

import pytest

from eclipse_ai.game_models import GameState, PlayerState, Resources, MapState
from eclipse_ai.technology import (
    ResearchError,
    can_research,
    cleanup_refresh_market,
    discounted_cost,
    do_research,
    ensure_part_allowed,
    ensure_structure_allowed,
    load_tech_definitions,
    MARKET_SIZES_BY_PLAYER_COUNT,
)


def _make_state(player_count: int = 1) -> GameState:
    defs = load_tech_definitions()
    players = {}
    for idx in range(player_count):
        pid = f"P{idx + 1}"
        resources = Resources(money=5, science=10, materials=5)
        players[pid] = PlayerState(
            player_id=pid,
            color="orange",
            resources=resources,
            science=resources.science,
            influence_discs=3,
        )
        players[pid].tech_count_by_category = {}
        players[pid].owned_tech_ids = set()
        players[pid].unlocked_parts = set()
        players[pid].unlocked_structures = set()
    return GameState(
        round=1,
        active_player="P1",
        phase="action",
        players=players,
        map=MapState(),
        tech_bags={},
        market=[],
        tech_definitions=defs,
    )


def test_research_spends_disc_and_science():
    state = _make_state()
    player = state.players["P1"]
    state.market = ["advanced_labs"]
    player.science = 6
    player.resources.science = 6
    player.influence_discs = 2

    do_research(state, player, "advanced_labs")

    assert player.influence_discs == 1
    # pay 6, immediate effect refunds +2 science
    assert player.science == 2
    assert "advanced_labs" in player.owned_tech_ids


def test_category_discount_applies_only_within_category():
    state = _make_state()
    player = state.players["P1"]
    player.owned_tech_ids.update({"plasma_cannon", "improved_hull"})
    player.tech_count_by_category = {"grid": 2}
    player.science = 10
    player.resources.science = 10

    defs = state.tech_definitions
    military_cost = discounted_cost(player, defs["gauss_shield"])
    grid_cost = discounted_cost(player, defs["advanced_labs"])

    assert military_cost == 1
    assert grid_cost == defs["advanced_labs"].base_cost


def test_no_research_as_reaction():
    state = _make_state()
    player = state.players["P1"]
    state.market = ["nanorobots"]
    player.science = 5
    player.resources.science = 5
    state.phase = "reaction"

    assert not can_research(state, player, "nanorobots")
    with pytest.raises(ResearchError, match="cannot research during Reaction"):
        do_research(state, player, "nanorobots")


def test_rare_uniqueness_and_starting_rare():
    state = _make_state(player_count=2)
    p1 = state.players["P1"]
    p2 = state.players["P2"]
    p1.owned_tech_ids.add("zero_point_source")
    p1.tech_count_by_category = {"rare": 1}
    state.market = ["zero_point_source"]
    state.tech_bags = {"III": ["zero_point_source", "quantum_grid"]}

    cleanup_refresh_market(state)

    assert "zero_point_source" not in state.market
    assert "zero_point_source" not in state.tech_bags["III"]

    state.market.append("quantum_grid")
    p2.science = 8
    p2.resources.science = 8
    p2.influence_discs = 2
    do_research(state, p2, "quantum_grid")

    assert "quantum_grid" not in state.market
    assert all("quantum_grid" not in bag for bag in state.tech_bags.values())
    with pytest.raises(ResearchError, match="tech not available in market"):
        do_research(state, p1, "zero_point_source")


def test_grants_parts_and_structures_gated():
    state = _make_state()
    player = state.players["P1"]

    with pytest.raises(ResearchError, match="required technology not owned"):
        ensure_structure_allowed(player, "starbase")
    with pytest.raises(ResearchError, match="required technology not owned"):
        ensure_part_allowed(player, "plasma_cannon")

    state.market = ["starbase", "plasma_cannon"]
    player.science = 12
    player.resources.science = 12

    do_research(state, player, "starbase")
    ensure_structure_allowed(player, "starbase")

    state.market.append("plasma_cannon")
    do_research(state, player, "plasma_cannon")
    ensure_part_allowed(player, "plasma_cannon")


def test_cleanup_refills_market_only_in_cleanup():
    state = _make_state(player_count=2)
    player = state.players["P1"]
    player.science = 8
    player.resources.science = 8
    player.influence_discs = 2
    state.market = ["plasma_cannon", "advanced_labs", "nanorobots"]
    state.tech_bags = {"I": ["gauss_shield", "improved_hull"]}

    do_research(state, player, "plasma_cannon")
    assert state.market == ["advanced_labs", "nanorobots"]

    cleanup_refresh_market(state)
    target = MARKET_SIZES_BY_PLAYER_COUNT[len(state.players)]
    assert len(state.market) <= target
    assert "gauss_shield" in state.market or "improved_hull" in state.market
